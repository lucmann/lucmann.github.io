<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CUDA Thread Hierarchy vs OpenGL Compute Shader Thread Hierarchy</title>
    <url>/comp/compute-model/</url>
    <content><![CDATA[<h1 id="cuda-thread-hierarchy"><a class="markdownIt-Anchor" href="#cuda-thread-hierarchy"></a> CUDA Thread Hierarchy</h1>
<img src="/comp/compute-model/cuda-thread-hier.png" class="">
<span id="more"></span>
<p>CUDA中的<code>kernel</code>是一段可在GPU独立运行的小程序，而且这段程序会被实例化(类似的说法还有<strong>launched</strong>, <strong>issued</strong>, <strong>executed</strong>, <strong>invoked</strong>)成非常多的<code>thread</code>, 这些线程可<strong>并发地</strong>在GPU上运行。程序员或者说编译器将这些线程组织成</p>
<ul>
<li>Thread</li>
<li>Thread Block</li>
<li>Grid of Thread Blocks</li>
</ul>
<h2 id="thread"><a class="markdownIt-Anchor" href="#thread"></a> Thread</h2>
<p>一个单独的线程必然属于一个<code>Thread Block</code>, 它有自己的</p>
<ul>
<li>thread ID</li>
<li>program counter</li>
<li>registers</li>
<li>per-thread private memory</li>
<li>inputs</li>
<li>output</li>
</ul>
<h2 id="thread-block"><a class="markdownIt-Anchor" href="#thread-block"></a> Thread Block</h2>
<p>一个<code>Thread Block</code>必然属于一个<code>Grid</code>, 它是一组并发执行的线程的集合，这些线程之间可以通过<code>barrier synchronization</code>和<code>per-Block shared memory</code>互相协同, 它也有一个<code>Block ID</code>用来索引它在<code>Grid</code>中的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dim3 blockDim;</span><br><span class="line">uint3 blockIdx;</span><br></pre></td></tr></table></figure>
<h2 id="grid-of-thread-blocks"><a class="markdownIt-Anchor" href="#grid-of-thread-blocks"></a> Grid of Thread Blocks</h2>
<p>一个<code>Grid</code>由一组执行相同<code>kernel</code>的<code>Thread Blocks</code>组成。可以这样说，一个<code>Grid</code>是所有执行同一个<code>Kernel</code>的线程的集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dim3 gridDim;</span><br></pre></td></tr></table></figure>
<h1 id="cuda-thread-map"><a class="markdownIt-Anchor" href="#cuda-thread-map"></a> CUDA Thread Map</h1>
<p>CUDA的threads层级结构可以映射到GPU的processors的层级结构上。</p>
<ul>
<li>一个GPU执行一个或多个grids(kernels)</li>
<li>一个SM(Streaming Multiprocessor)执行一个或多个Thread Blocks</li>
<li>CUDA Cores和一个SM里的其它执行单元(SFU, LDST)执行多个线程</li>
</ul>
<p>SM执行线程的单位是<code>warp</code>, 一般是32个线程一组，一个<code>warp</code>里的32个线程是真正并行执行的。</p>
<img src="/comp/compute-model/cuda-thread-map.png" class="">
<h2 id="cuda-memory"><a class="markdownIt-Anchor" href="#cuda-memory"></a> CUDA Memory</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cudaError_t cudaMemcpy(void *dst,</span><br><span class="line">                       const void *src,</span><br><span class="line">                       size_t count,</span><br><span class="line">                       cudaMemcpyKind kind);</span><br></pre></td></tr></table></figure>
<p>除了最后一个参数，其它参数都顾名知意。<code>kind</code>指示内存拷贝的方向:</p>
<ul>
<li>cudaMemcpyHostToHost</li>
<li>cudaMemcpyHostToDevice</li>
<li>cudaMemcpyDeviceToHost</li>
<li>cudaMemcpyDeviceToDevice</li>
</ul>
<h1 id="opengl-compute-shader-thread-hierarchy"><a class="markdownIt-Anchor" href="#opengl-compute-shader-thread-hierarchy"></a> OpenGL Compute Shader Thread Hierarchy</h1>
<p>有了前面的CUDA的Thread Hierarchy的了解，OpenGL的Compute Shader的线程层级就好理解了，本质上是一样的。一个OpenGL <code>Compute Shader(cs)</code>就相当于一个cuda中的<code>kernel</code>函数， 这些任务最终被分发到GPU的各个物理核心上去执行。在<code>cs</code>中，单个任务叫做<code>work item</code>, 除了<code>work item</code>之外, 还有以下概念:</p>
<ul>
<li>subgroups</li>
</ul>
<p>也就是<code>warps</code>或者<code>wavefronts</code>或者<code>Compute Units</code>, 它们实际上就是<code>threads</code>, <code>shader cores</code>, <code>cuda cores</code></p>
<ul>
<li>local workgroup</li>
</ul>
<p>它的大小(维度)在<code>cs</code>中通过<code>layout</code>修饰符指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;</span><br></pre></td></tr></table></figure>
<p><code>local workgroup</code>相当于cuda的<a href="#thread-block">Thread Block</a></p>
<ul>
<li>global workgroup</li>
</ul>
<p>它的大小(维度)通过OpenGL API设置, <code>glDispatchCompute</code>发起一个或多个compute work groups, 此处的work groups就是<strong>local work group</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glDispatchCompute(GLuint num_groups_x,</span><br><span class="line">                       GLuint num_groups_y,</span><br><span class="line">                       GLuint num_groups_z);</span><br></pre></td></tr></table></figure>
<p><code>global workgroup</code>相当于cuda的<a href="#grid-of-thread-blocks">Grid</a></p>
<h1 id="cuda和compute-shader变量对比"><a class="markdownIt-Anchor" href="#cuda和compute-shader变量对比"></a> CUDA和Compute Shader变量对比</h1>
<table>
<thead>
<tr>
<th style="text-align:left">type</th>
<th style="text-align:left">CUDA</th>
<th style="text-align:left">type</th>
<th style="text-align:left">Compute Shader</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">dim3</td>
<td style="text-align:left">gridDim</td>
<td style="text-align:left">uvec3</td>
<td style="text-align:left">gl_NumWorkGroups</td>
</tr>
<tr>
<td style="text-align:left">uint3</td>
<td style="text-align:left">blockIdx</td>
<td style="text-align:left">uvec3</td>
<td style="text-align:left">gl_WorkGroupID</td>
</tr>
<tr>
<td style="text-align:left">dim3</td>
<td style="text-align:left">blockDim</td>
<td style="text-align:left">const uvec3</td>
<td style="text-align:left">gl_WorkGroupSize</td>
</tr>
<tr>
<td style="text-align:left">uint3</td>
<td style="text-align:left">threadIdx</td>
<td style="text-align:left">uvec3</td>
<td style="text-align:left">gl_LocalInvocationID</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">uvec3</td>
<td style="text-align:left">gl_GlobalInvocationID</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">uint</td>
<td style="text-align:left">gl_LocalInvocationIndex</td>
</tr>
</tbody>
</table>
<p>References:</p>
<ol>
<li><a href="https://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIAFermiComputeArchitectureWhitepaper.pdf">NVIDIA Fermi Architecture Whitepaper</a></li>
<li><a href="https://developer.download.nvidia.cn/compute/DevZone/docs/html/C/doc/CUDA_C_Programming_Guide.pdf">NVIDIA CUDA Programming Guide</a></li>
<li><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDispatchCompute.xhtml">glDispatchCompute</a></li>
</ol>
]]></content>
      <categories>
        <category>computing</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning (ChatGPT said)</title>
    <url>/comp/machine-learning/</url>
    <content><![CDATA[<h1 id="问-机器学习深度学习和神经网络这些-ai-领域的专业名词有什么不同和联系"><a class="markdownIt-Anchor" href="#问-机器学习深度学习和神经网络这些-ai-领域的专业名词有什么不同和联系"></a> 问: 机器学习，深度学习和神经网络这些 AI 领域的专业名词有什么不同和联系？</h1>
<p><img src="/images/machine-learning/machine-learning.drawio.png" alt="Machine Learning branches" /></p>
]]></content>
      <categories>
        <category>computing</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>ROCm</title>
    <url>/comp/rocm/</url>
    <content><![CDATA[<blockquote>
<h3 id="高端硅片可以构建市场但最终软件支持往往决定了赢家和输家"><a class="markdownIt-Anchor" href="#高端硅片可以构建市场但最终软件支持往往决定了赢家和输家"></a> <em>高端硅片可以构建市场，但最终，软件支持往往决定了赢家和输家</em></h3>
<p>– Jack Huynh, AMD 高级副总裁兼计算和图形业务集团总经理</p>
</blockquote>
<p>AMD 的通用计算平台 ROCm (Radeon Open Compute) 是在通用计算领域与 NVIDIA 的 CUDA （Compute Unified Device Architecture) 相抗衡的软件基础设施。ROCm 实现的其实是由 AMD 发起的 HSA (Heterogeneous System Architecture) 标准，所以它的运行时主要由 3 个部分组成:</p>
<p>OOC: ROCm 平台又叫 Boltzmann 平台，原因据说是为了纪念统计力学和热力学领域著名物理学家路德维希·玻尔兹曼，他的工作对理解物质的微观行为和能量分布有着深远的影响。AMD 选取这个名字，可能是为了强调该平台在高性能计算领域的强大计算力和科学计算的应用前景。</p>
<span id="more"></span>
<ul>
<li><a href="https://github.com/ROCm/clr">AMD Compute Common Language Runtimes</a>
<ul>
<li><a href="https://github.com/ROCm/HIP">HIP runtime</a> (C++ Heterogeneous-Compute Interface for Portability)
<ul>
<li>可以算是一种 C++ 方言</li>
<li>AMD 提供工具 <a href="https://github.com/ROCm/HIPIFY">HIPIFY</a> 可以把 CUDA 源代码翻译成 HIP C++</li>
</ul>
</li>
<li><a href="https://www.khronos.org/opencl/">OpenCL runtime</a> （Open Computing Language)
<ul>
<li>由 Khronos Group 发布的开放异构系统并行编程语言</li>
<li>语言风格更接近 C</li>
</ul>
</li>
<li><a href="https://github.com/ROCm/clr/tree/amd-staging/rocclr">rocclr</a> HIP 和 OpenCL 共用的 runtime</li>
</ul>
</li>
<li><a href="https://github.com/ROCm/HIP">HIP</a>
<ul>
<li>这个仓库以前主要提供一个 compiler driver utility <code>hipcc</code> 脚本，目前 hipcc 已经被移到 AMD 自己 forked <a href="https://github.com/ROCm/llvm-project/tree/amd-staging/amd/hipcc">llvm-project/amd/hipcc</a></li>
<li>hipcc 之于 HIP-Clang 就像 gcc 之于 GCC</li>
</ul>
</li>
<li><a href="https://github.com/ROCm/ROCR-Runtime">ROCR</a>
<ul>
<li>
<p>ROCt libhsakmt-staticdrm HSA Kernel Mode Trunk 用户态库</p>
<ul>
<li>libhsakmt 总是被构建成静态库 .a</li>
<li>libhsakmt 通过 DRM 设备节点与 KFD 交互</li>
</ul>
</li>
<li>
<p>ROCr libhsa-runtime64</p>
<ul>
<li>用户可以通过 CMAKE 变量 <code>BUILD_SHARED_LIBS</code> 选择构建 libhsa-runtime64 为静态库或动态库</li>
</ul>
</li>
<li>
<p>ROCR 主要向用户提供 AMD GPU/NPU/HSA 设备内核驱动 (包括 KFD 和 <a href="https://patchwork.freedesktop.org/series/136294/">XDNA</a>) 的用户态封装和抽象, 类似 amdgpu.ko 与 libdrm_amdgpu 的关系。它的 libhsakmt 通过 KFD 提供的 IOCTL 直接访问 HSA 硬件，而 libhsa-runtime64 主要实现 HSA 标准的 Core Profile 和各厂家的扩展 (extension)。</p>
</li>
</ul>
</li>
</ul>
<p>可以说，ROCm 的整个运行时环境分的 3 大块，分别负责打通</p>
<ul>
<li>CLR   向上，面向编程语言</li>
<li>ROCR  向下，面向内核驱动</li>
<li>HIP   面向编译系统(HIP 原来提供的 hipcc 已并入 ROCm/llvm-project)</li>
</ul>
<h1 id="clr"><a class="markdownIt-Anchor" href="#clr"></a> <a href="https://github.com/ROCm/clr">CLR</a></h1>
<p>所谓 Common Language Runtimes, 就是指 HIP 和 OpenCL 两种编程语言的运行时, 类似 C/C++ 的 <a href="http://libc.so">libc.so</a> 和 <a href="http://libstdc++.so">libstdc++.so</a>。</p>
<ul>
<li><a href="http://libamdhip64.so">libamdhip64.so</a></li>
<li>libamdocl64.so.2.1.nnn</li>
</ul>
<p>这两个动态库各自都需要链接 rocclr</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_link_libraries(amdocl PUBLIC rocclr)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ROCclr abstracts the usage of multiple AMD compilers and runtimes.</span><br><span class="line"># It is possible to support multiple backends concurrently in the same binary.</span><br><span class="line">option(ROCCLR_ENABLE_HSAIL &quot;Enable support for HSAIL compiler&quot; OFF)</span><br><span class="line">option(ROCCLR_ENABLE_LC    &quot;Enable support for LC compiler&quot;    ON)</span><br><span class="line">option(ROCCLR_ENABLE_HSA   &quot;Enable support for HSA runtime&quot;    ON)</span><br><span class="line">option(ROCCLR_ENABLE_PAL   &quot;Enable support for PAL runtime&quot;    OFF)</span><br></pre></td></tr></table></figure>
<p>因为无论 amdhip64 还是 amdocl ，它们也都要调到编译器后端，在 CLR 的实现里支持两个编译器后端：</p>
<ul>
<li><code>ROCCLR_ENABLE_HSAIL</code> HSAIL (HSA Intermediate Language, 似乎已经废弃)
<ul>
<li>CLR 的源码中是通过宏 <code>WITH_COMPILER_LIB</code> guard</li>
</ul>
</li>
<li><code>ROCCLR_ENABLE_LC</code>    <a href="https://github.com/ROCm/llvm-project/tree/amd-staging/amd/comgr">COMGR</a> (Code Object Manager) 目前在 <code>ROCm/llvm-project/amd/comgr/</code> 下维护
<ul>
<li>CLR 的源码中是通过宏 <code>USE_COMGR_LIBRARY</code> guard</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Program::compileImpl(const std::string&amp; sourceCode,</span><br><span class="line">                          const std::vector&lt;const std::string*&gt;&amp; headers,</span><br><span class="line">                          const char** headerIncludeNames, amd::option::Options* options,</span><br><span class="line">                          const std::vector&lt;std::string&gt;&amp; preCompiledHeaders) &#123;</span><br><span class="line">  if (isLC()) &#123;</span><br><span class="line">    return compileImplLC(sourceCode, headers, headerIncludeNames, options, preCompiledHeaders);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return compileImplHSAIL(sourceCode, headers, headerIncludeNames, options);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CLR 也支持两个运行时后端：</p>
<ul>
<li><code>ROCCLR_ENABLE_HSA</code>
<ul>
<li>如果使用 HSA runtime, 那么 CLR 需要调用 ROCR (libhsa-runtime64)</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_package(hsa-runtime64 1.11 REQUIRED CONFIG</span><br><span class="line">  PATHS</span><br><span class="line">    /opt/rocm/</span><br><span class="line">    $&#123;ROCM_INSTALL_PATH&#125;</span><br><span class="line">  PATH_SUFFIXES</span><br><span class="line">    cmake/hsa-runtime64</span><br><span class="line">    lib/cmake/hsa-runtime64</span><br><span class="line">    lib64/cmake/hsa-runtime64)</span><br><span class="line">target_link_libraries(rocclr PUBLIC hsa-runtime64::hsa-runtime64)</span><br></pre></td></tr></table></figure>
</li>
<li><code>ROCCLR_ENABLE_PAL</code> <a href="https://github.com/GPUOpen-Drivers/pal">PAL</a> (Platform Abstraction Library)
<ul>
<li>如果使用 PAL runtime, rocclr 需要链接 <a href="http://libpal.so">libpal.so</a> 和 <a href="http://libamdhsaloader.so">libamdhsaloader.so</a></li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_package(AMD_PAL)</span><br><span class="line">find_package(AMD_HSA_LOADER)</span><br><span class="line">target_link_libraries(rocclr PUBLIC pal amdhsaloader)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="rocr"><a class="markdownIt-Anchor" href="#rocr"></a> <a href="https://github.com/ROCm/ROCR-Runtime">ROCR</a></h1>
<p>计算世界的 libdrm</p>
<p>ROCR 是 KMD 的封装(主要是 KMD 实现的 ioctl 和设备,内存管理接口)，类似 libdrm, 但 ROCR 也对驱动动本身(因为KMD可能会有 KFD, AMDGPU, XDNA)进行了抽象，便于扩展到新驱动架构。例如，在最近 ROCR 就增加了对 <a href="https://patchwork.freedesktop.org/series/136294/">AMD NPU 驱动 XDNA</a> 的支持。</p>
<p>OOC: <a href="http://libhsa-runtime64.so">libhsa-runtime64.so</a> 打开的是 <code>/dev/kfd</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hsa_status_t XdnaDriver::DiscoverDriver() &#123;</span><br><span class="line">  const int max_minor_num(64);</span><br><span class="line">  const std::string devnode_prefix(&quot;/dev/accel/accel&quot;);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; max_minor_num; ++i) &#123;</span><br><span class="line">    std::unique_ptr&lt;Driver&gt; xdna_drv(</span><br><span class="line">        new XdnaDriver(devnode_prefix + std::to_string(i)));</span><br><span class="line">    if (xdna_drv-&gt;Open() == HSA_STATUS_SUCCESS) &#123;</span><br><span class="line">      if (xdna_drv-&gt;QueryKernelModeDriver(</span><br><span class="line">              core::DriverQuery::GET_DRIVER_VERSION) == HSA_STATUS_SUCCESS) &#123;</span><br><span class="line">        core::Runtime::runtime_singleton_-&gt;RegisterDriver(xdna_drv);</span><br><span class="line">        return HSA_STATUS_SUCCESS;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        xdna_drv-&gt;Close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return HSA_STATUS_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rocmllvm-project"><a class="markdownIt-Anchor" href="#rocmllvm-project"></a> <a href="https://github.com/ROCm/llvm-project">ROCm/llvm-project</a></h1>
<p><a href="https://github.com/ROCm/llvm-project">ROCm/llvm-project</a> 是 AMD 专为 ROCm fork 出来的 LLVM 仓库，它里面包含所有 <a href="https://github.com/llvm/llvm-project">llvm-project</a> 上游变更，再加上 AMD 特有的 <strong>amd</strong> 子目录。 在 amd 目录下存在 3 个组件:</p>
<ul>
<li>amd_comgr</li>
<li>device-libs</li>
<li>hipcc</li>
</ul>
<p>这 3 个组件可以有两种构建方式:</p>
<ul>
<li>因为每个子目录下都有自己的 CMakeLists.txt, 所以可以通过 cmake 的 <code>-S</code> 选项分别逐个构建
<ul>
<li>虽然这 3 个组件是可以独立构建的，但 amd_comgr 依赖 device-libs</li>
</ul>
</li>
<li>也可以通过 llvm 构建选项 <code>LLVM_EXTERNAL_PROJECTS</code>, <code>LLVM_EXTERNAL_DEVICELIBS_SOURCE_DIR</code>, <code>LLVM_EXTERNAL_COMGR_SOURCE_DIR</code> 与 llvm 一起构建
<ul>
<li>这种方式好像需要运行 <code>amd/utils/omnibus.sh</code>, 试了一下没有成功，还是第一种方式相对简单些</li>
</ul>
</li>
</ul>
<p>构建顺序应该只能是：</p>
<ul>
<li><code>cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=On -DCMAKE_INSTALL_PREFIX=~/.local/rocm/6.2.0/llvm -DLLVM_ENABLE_PROJECTS=&quot;clang;lld;llvm&quot; -DLLVM_TARGETS_TO_BUILD=&quot;BPF;AMDGPU;host&quot; -DLLVM_LIBDIR_SUFFIX=64 -DLLVM_BUILD_LLVM_DYLIB=OFF -DBUILD_SHARED_LIBS=OFF -DLLVM_USE_LINKER=gold</code>
<ul>
<li>构建 comgr 不支持 shared libraries LLVM,  所以必须将 LLVM 编译成静态库 (<code>-DBUILD_SHARED_LIBS=OFF</code>)</li>
<li><a href="https://github.com/ROCm/llvm-project/issues/37"><code>CMAKE_BUILD_TYPE</code> 不要选 Debug 或 RelWithDebInfo, 除非你有足够的硬盘空间</a></li>
</ul>
</li>
<li><code> cmake -S amd/device-libs -B build-rocm -G &quot;Ninja&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=~/.local/rocm/6.2.0 -DLLVM_DIR=~/.local/rocm/6.2.0/llvm/lib64/cmake/llvm</code>
<ul>
<li><code>LLVM_DIR</code> 要设置的是包含 <code>LLVMConfig.cmake</code> 的路径, 而不是 <code>llvm-config --prefix</code> 输出的路径</li>
</ul>
</li>
<li><code>cmake -S amd/comgr -B build-rocm -G &quot;Ninja&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=~/.local/rocm/6.2.0 -DLLVM_DIR=~/.local/rocm/6.2.0/llvm/lib64/cmake/llvm -DCMAKE_MODULE_PATH=~/local/rocm/6.2.0/lib/cmake/AMDDeviceLibs</code></li>
</ul>
<h1 id="amdkfd"><a class="markdownIt-Anchor" href="#amdkfd"></a> <a href="https://github.com/ROCm/ROCK-Kernel-Driver">AMDKFD</a></h1>
<p>计算世界的 AMDGPU</p>
<p>AMDKFD 是 AMD Kernel Fusion Driver, 它基本上是 AMD HSA 在内核中的实现，所以 ROCm/OpenCL 都需要它。<a href="https://lwn.net/Articles/619581/">AMDKFD 在 2014 年合入 Linux kernel 3.19 的主线</a>, 而在 2018 年 AMDKFD 正式与 AMDGPU 合并成为一个单一内核模块 <a href="https://lists.freedesktop.org/archives/amd-gfx/2018-July/023673.html">amdgpu.ko</a>。</p>
<p>OOC: AMD “Fusion” 是 AMD 在 2011 年推出的一系列处理器，旨在将 CPU 和 GPU 集成到一个芯片上，称为 APU (加速处理单元)。这些处理器的目标是提供更高的性能和能效，特别是在图形和并行计算任务方面。</p>
<p>AMDKFD 有 3 个内核配置选项:</p>
<ul>
<li>HSA_AMD     基本上在 X86_64, ARM64 和 PPC64 系统上是默认打开的</li>
<li>HSA_AMD_SVM 基于 HMM 的共享虚拟内存管理器</li>
<li>HSA_AMD_P2P 基于 PCI_P2PDMA 的多 GPU 间数据传输功能</li>
</ul>
<h1 id="udna"><a class="markdownIt-Anchor" href="#udna"></a> <a href="https://winbuzzer.com/2024/09/10/amd-combines-rdna-and-cdna-into-udna-to-rival-nvidia-cuda-xcxwbn/">UDNA</a></h1>
<p>在未来， AMD 计划将 RDNA 和 CDNA 架构统一为 UDNA 架构，并为该架构引入张量计算单元，以更好地支持 AI 计算，统一的 UDNA 架构对开发者来说将更友好，可以让开发者利用相同的底层微架构来实现 AI, HPC 和游戏。</p>
<h1 id="hsa"><a class="markdownIt-Anchor" href="#hsa"></a> <a href="https://hsafoundation.com/">HSA</a> vs <a href="https://uxlfoundation.org/">UXL</a></h1>
<p>HSA 标准是 ROCm 的基石之一，它让用户在通用计算领域除了 CUDA 之外能有另外一个选择。而 UXL (Unified Acceleration) Foundation 旨在为不同架构不同厂商的加速器构建统一的软件生态系统，从而也成为另一个能与 nVIDIA 的 GPU 和 CUDA 相抗衡的计算平台。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://rocm.docs.amd.com/en/latest/what-is-rocm.html">What’s ROCm</a></li>
<li><a href="https://hsafoundation.com/standards/">Heterogeneous System Architecture standards</a></li>
<li><a href="https://www.hsafoundation.com/wp-content/uploads/2021/02/HSA-PRM-1.1.1.pdf">HSA Programmer’s Reference Manual: HSAIL Virtual ISA</a></li>
<li><a href="https://lwn.net/Articles/619581/">AMDKFD Kernel Driver</a></li>
</ul>
]]></content>
      <categories>
        <category>computing</category>
      </categories>
      <tags>
        <tag>ROCm</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL 中的一些概念对比</title>
    <url>/gfx/cg/</url>
    <content><![CDATA[<p><img src="/images/cg/fov.png" alt="Field-of-View" /></p>
<span id="more"></span>
<p>OpenGL (可能也有其它与 OpenGL 有关的)中的有些概念很相似，有些标准里也没有给出一个明确的定义，有些如果仅从字面意思理解很容易混淆，这里将平时自己查询的资料及自己的理解整理到一起，以备不时之需。</p>
<ul>
<li><a href="https://computergraphics.stackexchange.com/questions/9214/whats-the-difference-between-clipping-and-culling">Clip vs Cull</a></li>
<li><a href="https://graphicdesign.stackexchange.com/questions/45162/what-is-the-difference-between-glyph-and-font">Glyph vs Font</a></li>
</ul>
<h1 id="clip-vs-cull"><a class="markdownIt-Anchor" href="#clip-vs-cull"></a> Clip vs Cull</h1>
<ul>
<li>Clip 是一个<strong>做加减法</strong> 的过程，就是它会将处在 clip-space 边界的图元分成多个图元，新生成的在 clip-space 之外的图元就丢弃掉了</li>
<li>Cull 是一个<strong>做纯减法</strong> 的过程，它不会生成任何新的图元，只会丢弃图元</li>
</ul>
<h1 id="glfrustum"><a class="markdownIt-Anchor" href="#glfrustum"></a> <a href="https://blog.csdn.net/iteye_13202/article/details/82490241?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-82490241-blog-133176951.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-82490241-blog-133176951.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;utm_relevant_index=5"><code>glFrustum</code> vs <code>glm::perspective</code></a></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);</span><br><span class="line">glm::mat4 <span class="title function_">glm::perspective</span><span class="params">(<span class="type">float</span> fovy, <span class="type">float</span> aspect, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span>;</span><br></pre></td></tr></table></figure>
<p>这两组参数之间可以转换，首先 <code>zNear</code>, <code>zFar</code> 是一样的，不需要转换，剩下就是 <code>left, right, bottom, top</code> 和 <code>fovy, aspect</code> 的关系了。首先 <code>left, right</code> 和 <code>bottom, top</code> 分别是以原点对称的</p>
<h1 id="tessellation-vs-bézier"><a class="markdownIt-Anchor" href="#tessellation-vs-bézier"></a> Tessellation vs Bézier</h1>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Tessellation (OpenGL)</th>
<th>Bézier Curves/Surfaces</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Definition</strong></td>
<td>A technique that subdivides geometry into smaller pieces.</td>
<td>A mathematical way to define smooth curves/surfaces.</td>
</tr>
<tr>
<td><strong>Input</strong></td>
<td>Low-poly mesh, patches</td>
<td>Control points defining the shape</td>
</tr>
<tr>
<td><strong>Output</strong></td>
<td>Subdivided triangles</td>
<td>Interpolated curve/surface points</td>
</tr>
<tr>
<td><strong>Hardware Acceleration</strong></td>
<td>Uses GPU tessellation shaders</td>
<td>Requires CPU or GPU evaluation</td>
</tr>
<tr>
<td><strong>Level of Detail</strong></td>
<td>Dynamically adjustable</td>
<td>Fixed resolution unless re-evaluated</td>
</tr>
<tr>
<td><strong>Use Case</strong></td>
<td>Real-time rendering, adaptive detail</td>
<td>CAD, animation, precision modeling</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>DRI Configuration Infrastructure</title>
    <url>/gfx/driconf/</url>
    <content><![CDATA[<h1 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h1>
<p><strong>driconf</strong> 是一个基于 XML 的 DRI 驱动配置机制，它同时提供系统范围的和每用户的配置方式 (如果同时存在，后者覆盖前者)。driconf 提供统一的配置格式，并整理出驱动常见的配置选项，方便易用。 driconf 不仅可以针对指定设备，指定 screen, 指定驱动设置选项，而且可以针对每个应用设置选项。</p>
<span id="more"></span>
<p>一个 drirc XML 文件的示例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">driconf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">device</span> <span class="attr">screen</span>=<span class="string">&quot;0&quot;</span> <span class="attr">driver</span>=<span class="string">&quot;swrast&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Default options for all applications --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;pp_nogreen&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">name</span>=<span class="string">&quot;specific_application&quot;</span> <span class="attr">executable</span>=<span class="string">&quot;application_executable&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Specific options for &#x27;specific_application&#x27; --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;option_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;option_value&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Add more application-specific settings here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">device</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Add more device-specific settings here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">driconf</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个示例中用了 4 个 XML 元素，drirc 文件支持 5 个 XML 元素:</p>
<ul>
<li><code>&lt;driconf&gt;&lt;/driconf&gt;</code></li>
<li><code>&lt;device&gt;&lt;/device&gt;</code></li>
<li><code>&lt;application&gt;&lt;/application&gt;</code></li>
<li><code>&lt;engine&gt;&lt;/engine&gt;</code></li>
<li><code>&lt;option ... /&gt;</code></li>
</ul>
<p>Option 的值类型可以是以下 5 种, 但 bool 类型的值在 XML 文件中只能填 <code>true/false</code>, 不能填 <code>0/1</code>, 这应该和 XML Parser 有关。enum 和 int 类型在 XML 文件中都是填数字。</p>
<ul>
<li>bool</li>
<li>enum</li>
<li>int</li>
<li>float</li>
<li>string</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">driOptionValue</span> &#123;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> _bool; <span class="comment">/**&lt; \brief Boolean */</span></span><br><span class="line">   <span class="type">int</span> _int;      <span class="comment">/**&lt; \brief Integer or Enum */</span></span><br><span class="line">   <span class="type">float</span> _float;  <span class="comment">/**&lt; \brief Floating-point */</span></span><br><span class="line">   <span class="type">char</span> *_string;   <span class="comment">/**&lt; \brief String */</span></span><br><span class="line">&#125; driOptionValue;</span><br></pre></td></tr></table></figure>
<h1 id="setting-per-application"><a class="markdownIt-Anchor" href="#setting-per-application"></a> Setting Per-Application</h1>
<p>下面的例子展示将 glxgears 的红色通道禁用，而 glmark2 的绿色通道禁用的 <code>~/.drirc</code> 配置, 你可以同时在同一个驱动下运行这两个应用，对它们进行独立的驱动设置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">driconf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">device</span> <span class="attr">screen</span>=<span class="string">&quot;0&quot;</span> <span class="attr">driver</span>=<span class="string">&quot;swrast&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">name</span>=<span class="string">&quot;glmark2&quot;</span> <span class="attr">executable</span>=<span class="string">&quot;glmark2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;pp_nogreen&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">name</span>=<span class="string">&quot;glxgears&quot;</span> <span class="attr">executable</span>=<span class="string">&quot;glxgears&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">&quot;pp_nored&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">device</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Add more device-specific settings here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">driconf</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/driconf/per-application-dri-conf.png" alt="per-application driconf" /></p>
<p>更有意思的是 <code>application</code> 元素不仅提供 <code>executable</code> 这一种指定应用的方式，它还提供</p>
<ul>
<li><code>executable_regexp</code></li>
<li><code>sha1</code></li>
<li><code>application_name_match</code></li>
</ul>
<p>多种方式指定一个或多个应用，甚至可以指定应用的版本 <code>application_versions</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; attr[i]; i += <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(attr[i], <span class="string">&quot;name&quot;</span>)) <span class="comment">/* not needed here */</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(attr[i], <span class="string">&quot;executable&quot;</span>)) exec = attr[i+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(attr[i], <span class="string">&quot;executable_regexp&quot;</span>)) exec_regexp = attr[i+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(attr[i], <span class="string">&quot;sha1&quot;</span>)) sha1 = attr[i+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(attr[i], <span class="string">&quot;application_name_match&quot;</span>))</span><br><span class="line">      application_name_match = attr[i+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(attr[i], <span class="string">&quot;application_versions&quot;</span>))</span><br><span class="line">      application_versions = attr[i+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">else</span> XML_WARNING(<span class="string">&quot;unknown application attribute: %s.&quot;</span>, attr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="mesa-driconf-implementation"><a class="markdownIt-Anchor" href="#mesa-driconf-implementation"></a> Mesa DriConf Implementation</h1>
<h2 id="configuration-override"><a class="markdownIt-Anchor" href="#configuration-override"></a> Configuration Override</h2>
<p><strong>drirc</strong> 配置文件一般在 3 个地方</p>
<ul>
<li><code>$datadir</code>/drirc.d/* (e.g. <code>/usr/share/drirc.d/*</code> 或 <code>/usr/local/share/drirc.d/*</code>)</li>
<li><code>$sysconfdir</code>/drirc (e.g. <code>/etc/drirc</code>)</li>
<li><code>$HOME</code>/.drirc (e.g. <code>/home/luc/.drirc</code>)</li>
</ul>
<p>Mesa 实现的读取和解析的顺序是从上到下，后解析的会覆盖前面的</p>
<h2 id="xml-config-helpers"><a class="markdownIt-Anchor" href="#xml-config-helpers"></a> XML Config Helpers</h2>
<p>Mesa 中 (<code>util/xmlconfig.c</code>) 提供了读取和解析 XML 文件的 Helper 函数，并在 <code>util/driconf.h</code> 中定义好了常见配置选项。</p>
<ul>
<li><code>driParseOptionInfo</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">driParseOptionInfo(driOptionCache *info,</span><br><span class="line">                   const driOptionDescription *configOptions,</span><br><span class="line">                   unsigned numOptions);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>driParseConfigFiles</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">driParseConfigFiles(driOptionCache *cache, const driOptionCache *info,</span><br><span class="line">                    int screenNum, const char *driverName,</span><br><span class="line">                    const char *kernelDriverName,</span><br><span class="line">                    const char *deviceName,</span><br><span class="line">                    const char *applicationName, uint32_t applicationVersion,</span><br><span class="line">                    const char *engineName, uint32_t engineVersion)</span><br></pre></td></tr></table></figure>
<p>它们俩个都必须有两个 <code>driOptionCache</code> 作为入参，一个是调用者输入的 (const 修饰的)，驱动用它来初始化另一个 <code>driOptionCache</code>。调用者输入的 <code>driOptionCache</code> 是 Gallium <strong>pipe-loader</strong> 把从原始的 XML 文件解析出来的 Option 的描述 <code>driOptionDescription</code> 保存在 <code>struct drm_driver_descriptor</code> 结构体的 <code>.driconf</code> 成员中。</p>
<p>pipe-loader 甚至提供了一个 C 头文件 <em>src/gallium/auxiliary/pipe-loader/driinfo_gallium.h</em>， 里面包含了所有 Gallium 驱动都支持的 DRI 配置选项，就是说即使在系统中没有任何额外的 drirc XML 文件的情况下, 通过修改 <em>driinfo_gallium.h</em> 重新编译驱动，就能改变驱动的一些行为 (当然，系统路径下的 drirc 如果设置了相同的选项会覆盖 driinfo_gallium.h 的设置, 因为系统路径下的配置运行时才解析的)</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h b/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h</span></span><br><span class="line"><span class="comment">index 3b0ab726e8f..0e8184a6b95 100644</span></span><br><span class="line"><span class="comment">--- a/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h</span></span><br><span class="line"><span class="comment">+++ b/src/gallium/auxiliary/pipe-loader/driinfo_gallium.h</span></span><br><span class="line"><span class="meta">@@ -9,7 +9,7 @@</span> DRI_CONF_SECTION_END</span><br><span class="line"> DRI_CONF_SECTION_QUALITY</span><br><span class="line">    DRI_CONF_PP_CELSHADE(0)</span><br><span class="line">    DRI_CONF_PP_NORED(0)</span><br><span class="line"><span class="deletion">-   DRI_CONF_PP_NOGREEN(0)</span></span><br><span class="line"><span class="addition">+   DRI_CONF_PP_NOGREEN(1)</span></span><br><span class="line">    DRI_CONF_PP_NOBLUE(0)</span><br><span class="line">    DRI_CONF_PP_JIMENEZMLAA(0, 0, 32)</span><br><span class="line">    DRI_CONF_PP_JIMENEZMLAA_COLOR(0, 0, 32)</span><br></pre></td></tr></table></figure>
<p><img src="/images/driconf/scene-shadow-no-green.png" alt="glmark2 -bshadow" /></p>
<h2 id="how-to-add-driconf-support-in-gallium-driver"><a class="markdownIt-Anchor" href="#how-to-add-driconf-support-in-gallium-driver"></a> How to add driconf support in Gallium driver</h2>
<p>一般是在 gallium xxx_device (或 xxx_screen) 结构体中添加一个包含 <code>driOptionCache</code> 结构体和一大堆配置选项变量的结构体，在 <code>xxx_screen_create()</code> 函数里调用 <code>driParseConfigFiles()</code> 或 <code>driParseOptionInfo()</code> 函数把 <code>/etc/drirc</code> 文件里的选项解析到 xxx_device 或 xxx_screen 结构体中</p>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://dri.freedesktop.org/wiki/ConfigurationOptions/">Common Configuration Options</a></li>
<li><a href="https://dri.freedesktop.org/wiki/ConfigurationInfrastructure/">https://dri.freedesktop.org/wiki/ConfigurationInfrastructure/</a></li>
<li><a href="https://dri.freedesktop.org/wiki/DriConf/">GUI 工具 DriConf</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>DRI Legacy</title>
    <url>/gfx/dril/</url>
    <content><![CDATA[<h1 id="just-read-it"><a class="markdownIt-Anchor" href="#just-read-it"></a> Just read it</h1>
<p><a href="https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/28378">gallium/dril: Compatibility stub for the legacy DRI loader interface</a></p>
<span id="more"></span>
<h1 id="dri-extensions"><a class="markdownIt-Anchor" href="#dri-extensions"></a> DRI extensions</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define __DRI2_BLOB                        &quot;DRI2_Blob&quot;</span><br><span class="line">#define __DRI2_BUFFER_DAMAGE               &quot;DRI2_BufferDamage&quot;</span><br><span class="line">#define __DRI2_CONFIG_QUERY                &quot;DRI_CONFIG_QUERY&quot;</span><br><span class="line">#define __DRI2_FENCE                       &quot;DRI2_Fence&quot;</span><br><span class="line">#define __DRI2_FLUSH                       &quot;DRI2_Flush&quot;</span><br><span class="line">#define __DRI2_FLUSH_CONTROL               &quot;DRI_FlushControl&quot;</span><br><span class="line">#define __DRI2_INTEROP                     &quot;DRI2_Interop&quot;</span><br><span class="line">#define __DRI2_NO_ERROR                    &quot;DRI_NoError&quot;</span><br><span class="line">#define __DRI2_RENDERER_QUERY              &quot;DRI_RENDERER_QUERY&quot;</span><br><span class="line">#define __DRI2_ROBUSTNESS                  &quot;DRI_Robustness&quot;</span><br><span class="line">#define __DRI2_THROTTLE                    &quot;DRI2_Throttle&quot;</span><br><span class="line">#define __DRI_BACKGROUND_CALLABLE          &quot;DRI_BackgroundCallable&quot;</span><br><span class="line">#define __DRI_CONFIG_OPTIONS               &quot;DRI_ConfigOptions&quot;</span><br><span class="line">#define __DRI_COPY_SUB_BUFFER              &quot;DRI_CopySubBuffer&quot;</span><br><span class="line">#define __DRI_CORE                         &quot;DRI_Core&quot;</span><br><span class="line">#define __DRI_DRI2                         &quot;DRI_DRI2&quot;</span><br><span class="line">#define __DRI_DRI2_LOADER                  &quot;DRI_DRI2Loader&quot;</span><br><span class="line">#define __DRI_IMAGE                        &quot;DRI_IMAGE&quot;</span><br><span class="line">#define __DRI_IMAGE_DRIVER                 &quot;DRI_IMAGE_DRIVER&quot;</span><br><span class="line">#define __DRI_IMAGE_LOADER                 &quot;DRI_IMAGE_LOADER&quot;</span><br><span class="line">#define __DRI_IMAGE_LOOKUP                 &quot;DRI_IMAGE_LOOKUP&quot;</span><br><span class="line">#define __DRI_MEDIA_STREAM_COUNTER         &quot;DRI_MediaStreamCounter&quot;</span><br><span class="line">#define __DRI_MUTABLE_RENDER_BUFFER_DRIVER &quot;DRI_MutableRenderBufferDriver&quot;</span><br><span class="line">#define __DRI_MUTABLE_RENDER_BUFFER_LOADER &quot;DRI_MutableRenderBufferLoader&quot;</span><br><span class="line">#define __DRI_READ_DRAWABLE                &quot;DRI_ReadDrawable&quot;</span><br><span class="line">#define __DRI_SWAP_CONTROL                 &quot;DRI_SwapControl&quot;</span><br><span class="line">#define __DRI_SWRAST                       &quot;DRI_SWRast&quot;</span><br><span class="line">#define __DRI_SWRAST_LOADER                &quot;DRI_SWRastLoader&quot;</span><br><span class="line">#define __DRI_SYSTEM_TIME                  &quot;DRI_SystemTime&quot;</span><br><span class="line">#define __DRI_TEX_BUFFER                   &quot;DRI_TexBuffer&quot;</span><br><span class="line">#define __DRI_USE_INVALIDATE               &quot;DRI_UseInvalidate&quot;</span><br></pre></td></tr></table></figure>
<p>(extracted by <code>rg '^#define __DRI.* &quot;DRI.*&quot;' include/GL/internal/dri_interface.h | sort | awk '&#123;printf(&quot;%s %-34s %s\n&quot;, $1, $2, $3)&#125;'</code>)</p>
<p>这些扩展被定义在 <code>dri_interface.h</code>, 该文件有两个作用：</p>
<ul>
<li>它是 mesa 内部的 libGL 与 libgallium_dri 之间的约定</li>
<li>它是 mesa 与外部 <a href="http://X.org">X.org</a> 服务器家族的约定</li>
</ul>
<h1 id="libgl_drivers_path"><a class="markdownIt-Anchor" href="#libgl_drivers_path"></a> <s>LIBGL_DRIVERS_PATH</s></h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       14  armada-drm_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  exynos_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  gm12u320_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  hdlcd_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  hx8357d_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  ili9163_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  ili9225_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  ili9341_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  ili9486_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  imx-dcss_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  imx-drm_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  imx-lcdif_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  ingenic-drm_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  kirin_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  kms_swrast_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  komeda_dri.so -&gt; libdril_dri.so</span><br><span class="line">  1151904  libdril_dri.so</span><br><span class="line">124969400  libgallium.so</span><br><span class="line">       14  mali-dp_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  mcde_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  mediatek_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  meson_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  mi0283qt_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  mxsfb-drm_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  panel-mipi-dbi_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  panfrost_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  panthor_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  pl111_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  radeonsi_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  rcar-du_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  repaper_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  rockchip_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  rzg2l-du_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  ssd130x_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  st7586_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  st7735r_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  sti_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  stm_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  sun4i-drm_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  swrast_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  udl_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  vkms_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  zink_dri.so -&gt; libdril_dri.so</span><br><span class="line">       14  zynqmp-dpsub_dri.so -&gt; libdril_dri.so</span><br></pre></td></tr></table></figure>
<p>(generated by <code>ls -go --time-style=+ /home/luc/mesa-install/lib/x86_64-linux-gnu/dri | cut -c 14-</code>)</p>
<h1 id="gl-frontends"><a class="markdownIt-Anchor" href="#gl-frontends"></a> GL Frontends</h1>
<ul>
<li>GLX</li>
<li>EGL</li>
<li>GBM</li>
</ul>
<p>在有了 DRIL 之后，这些 GL 前端库可以直接链接 <code>libgallium.so</code></p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>Edge Function - A Little Math You Want to Know about CG</title>
    <url>/gfx/edge-func/</url>
    <content><![CDATA[<div class="tenor-gif-embed" data-postid="18866305" data-share-method="host" data-aspect-ratio="2.40601" data-width="100%"><a href="https://tenor.com/view/4points-gif-18866305">4points GIF</a>from <a href="https://tenor.com/search/4points-gifs">4points GIFs</a></div> <script type="text/javascript" async src="https://tenor.com/embed.js"></script>
<span id="more"></span>
<h1 id="edge-函数定义"><a class="markdownIt-Anchor" href="#edge-函数定义"></a> Edge 函数定义</h1>
<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>E</mi><mn>01</mn></msub><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>P</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo>−</mo><msub><mi>V</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi>y</mi><mo>−</mo><msub><mi>V</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><mi>y</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>P</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo>−</mo><msub><mi>V</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi>x</mi><mo>−</mo><msub><mi>V</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E_{01}(P)=(P.x - V_0.x) * (V_1.y - V_0.y) - (P.y - V_0.y) * (V_1.x - V_0.x)</annotation></semantics></math></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>01</mn></msub><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">E_{01}(P) &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><msub><mi>V</mi><mn>0</mn></msub><msub><mi>V</mi><mn>1</mn></msub></mrow><mo stretchy="true">⇀</mo></mover></mrow><annotation encoding="application/x-tex">\overrightharpoon{V_0V_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.35533em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.20533em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> 的<strong>右边</strong></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>01</mn></msub><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">E_{01}(P) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><msub><mi>V</mi><mn>0</mn></msub><msub><mi>V</mi><mn>1</mn></msub></mrow><mo stretchy="true">⇀</mo></mover></mrow><annotation encoding="application/x-tex">\overrightharpoon{V_0V_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.35533em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.20533em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> 的<strong>边上</strong></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mn>01</mn></msub><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">E_{01}(P) &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><msub><mi>V</mi><mn>0</mn></msub><msub><mi>V</mi><mn>1</mn></msub></mrow><mo stretchy="true">⇀</mo></mover></mrow><annotation encoding="application/x-tex">\overrightharpoon{V_0V_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.35533em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.20533em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span> 的<strong>左边</strong></li>
</ul>
<p>更好记的形式: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">∥</mo><mover accent="true"><mrow><msub><mi>V</mi><mn>1</mn></msub><msub><mi>V</mi><mn>0</mn></msub></mrow><mo stretchy="true">⇀</mo></mover><mo>×</mo><mover accent="true"><mrow><mi>P</mi><msub><mi>V</mi><mn>0</mn></msub></mrow><mo stretchy="true">⇀</mo></mover><mo stretchy="false">∥</mo></mrow><annotation encoding="application/x-tex">\lVert \overrightharpoon{V_1V_0} \times \overrightharpoon{PV_0} \rVert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.45533em;vertical-align:-0.25em;"></span><span class="mopen">∥</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.20533em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.45533em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.20533em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mclose">∥</span></span></span></span></p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a href="https://www.cs.drexel.edu/~deb39/Classes/Papers/comp175-06-pineda.pdf">A Parallel Algorithm for Polygon Rasteriztion</a></p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>EGLImage &amp; Direct Texture</title>
    <url>/gfx/egl-image/</url>
    <content><![CDATA[<h1 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h1>
<p>EGLImage的存在是为了更方便地在EGL client API之间共享2D Image Data. 那什么是EGL client API呢？OpenGL, OpenGL ES, OpenVG都是EGL client API. EGLImage与下面3个EGL Extensions有关:</p>
<ul>
<li>EGL_KHR_image</li>
<li>EGL_KHR_image_base</li>
<li>EGL_KHR_image_pixmap</li>
</ul>
<span id="more"></span>
<p>后两个扩展其实是从第一个开离出来的。涉及EGLImage新增的Token和API都是在后两个扩展里定义的。</p>
<h1 id="egl_khr_image_base"><a class="markdownIt-Anchor" href="#egl_khr_image_base"></a> EGL_KHR_image_base</h1>
<p>它定义了一个新的Opaque类型EGLImageKHR</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> * EGLImageKHR;</span><br></pre></td></tr></table></figure>
<p>两者它定义了2个新API</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EGLImageKHR <span class="title function_">eglCreateImageKHR</span><span class="params">(</span></span><br><span class="line"><span class="params">EGLDisplay dpy,</span></span><br><span class="line"><span class="params">EGLContext ctx,</span></span><br><span class="line"><span class="params">EGLenum target,</span></span><br><span class="line"><span class="params">EGLClientBuffer buffer,</span></span><br><span class="line"><span class="params"><span class="type">const</span> EGLint *attrib_list</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">EGLBoolean <span class="title function_">eglDestroyImageKHR</span><span class="params">(</span></span><br><span class="line"><span class="params">EGLDisplay dpy,</span></span><br><span class="line"><span class="params">EGLImageKHR image</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，EGLClientBuffer也是Opaque类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> * EGLClientBuffer;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>eglCreateImageKHR()</code> 接受的 <strong>targets</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">target</th>
<th style="text-align:left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">EGL_GL_TEXTURE_2D</td>
<td style="text-align:left">Used for GL 2D texture images</td>
</tr>
<tr>
<td style="text-align:left">EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X</td>
<td style="text-align:left">Used for the +X face of GL cubemap texture images</td>
</tr>
<tr>
<td style="text-align:left">EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X</td>
<td style="text-align:left">Used for the -X face of GL cubemap texture images</td>
</tr>
<tr>
<td style="text-align:left">EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y</td>
<td style="text-align:left">Used for the +Y face of GL cubemap texture images</td>
</tr>
<tr>
<td style="text-align:left">EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</td>
<td style="text-align:left">Used for the -Y face of GL cubemap texture images</td>
</tr>
<tr>
<td style="text-align:left">EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z</td>
<td style="text-align:left">Used for the +Z face of GL cubemap texture images</td>
</tr>
<tr>
<td style="text-align:left">EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</td>
<td style="text-align:left">Used for the -Z face of GL cubemap texture images</td>
</tr>
<tr>
<td style="text-align:left">EGL_GL_TEXTURE_3D</td>
<td style="text-align:left">Used for GL 3D texture images</td>
</tr>
<tr>
<td style="text-align:left">EGL_GL_RENDERBUFFER</td>
<td style="text-align:left">Used for GL renderbuffer images</td>
</tr>
<tr>
<td style="text-align:left">EGL_NATIVE_PIXMAP_KHR</td>
<td style="text-align:left">Used for X11 Pixmap (added EGL_KHR_image_pixmap)</td>
</tr>
</tbody>
</table>
<ul>
<li><code>eglCreateImageKHR()</code> 接受的 <strong>attributes</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">attribute</th>
<th style="text-align:left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">EGL_WIDTH</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">EGL_HEIGHT</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">EGL_LINUX_DRM_FOURCC_EXT</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">EGL_DMA_BUF_PLANE0_FD_EXT</td>
<td style="text-align:left">0x3272</td>
</tr>
<tr>
<td style="text-align:left">EGL_DMA_BUF_PLANE0_OFFSET_EXT</td>
<td style="text-align:left">0x3273</td>
</tr>
<tr>
<td style="text-align:left">EGL_DMA_BUF_PLANE0_PITCH_EXT</td>
<td style="text-align:left">0x3274</td>
</tr>
<tr>
<td style="text-align:left">EGL_DMA_BUF_PLANE1_FD_EXT</td>
<td style="text-align:left">0x3275</td>
</tr>
<tr>
<td style="text-align:left">EGL_DMA_BUF_PLANE1_OFFSET_EXT</td>
<td style="text-align:left">0x3276</td>
</tr>
<tr>
<td style="text-align:left">EGL_DMA_BUF_PLANE1_PITCH_EXT</td>
<td style="text-align:left">0x3277</td>
</tr>
<tr>
<td style="text-align:left">EGL_DMA_BUF_PLANE2_FD_EXT</td>
<td style="text-align:left">0x3278</td>
</tr>
<tr>
<td style="text-align:left">EGL_DMA_BUF_PLANE2_OFFSET_EXT</td>
<td style="text-align:left">0x3279</td>
</tr>
<tr>
<td style="text-align:left">EGL_DMA_BUF_PLANE2_PITCH_EXT</td>
<td style="text-align:left">0x327A</td>
</tr>
</tbody>
</table>
<ul>
<li><code>eglDestroyImageKHR()</code></li>
</ul>
<h2 id="eglimagekhr-in-kylin-wlcom"><a class="markdownIt-Anchor" href="#eglimagekhr-in-kylin-wlcom"></a> EGLImageKHR in <a href="https://gitee.com/openkylin/kylin-wayland-compositor">kylin-wlcom</a></h2>
<pre><code class="highlight mermaid">sequenceDiagram
    autonumber

    participant app
    participant compositor
    participant libwlroots
    participant mesa
    participant kernel

    app -&gt;&gt; compositor : REQUEST:create_prime_buffer &lt;- fd
    compositor --&gt;&gt; compositor : drm_handle_create_prime_buffer(..., fd, ...)
    compositor -&gt;&gt; libwlroots  : wlr_buffer_init(..., &amp;buffer_impl, ...)
    compositor --&gt;&gt; compositor : API:buffer_get_dmabuf(struct wlr_buffer *, struct wlr_dmabuf_attributes *)
    compositor -&gt;&gt; libwlroots  : wlr_buffer_get_dmabuf(struct wlr_buffer *, struct wlr_dmabuf_attributes *)
    compositor --&gt;&gt; compositor : gl_texture_from_dmabuf_buffer()
    compositor --&gt;&gt; compositor : gl_texture_from_dmabuf()
    compositor --&gt;&gt; compositor : ky_egl_create_image_from_dmabuf() -&gt; EGLImageKHR
    rect rgb(191, 223, 255)
        compositor -&gt;&gt; mesa        : eglCreateImageKHR() -&gt; EGLImageKHR
        mesa --&gt;&gt; mesa : dri2_create_image()
        mesa --&gt;&gt; mesa : dri2_create_image_dma_buf()
        mesa --&gt;&gt; mesa : xxx_resource_from_handle()
        mesa --&gt;&gt; mesa : xxx_bo_import(..., fd)
        mesa -&gt;&gt; kernel: drmPrimeFDToHandle(..., fd) -&gt; gem_handle
    end</code></pre>
<h1 id="egl_khr_image_pixmap"><a class="markdownIt-Anchor" href="#egl_khr_image_pixmap"></a> EGL_KHR_image_pixmap</h1>
<h1 id="gl_oes_egl_image"><a class="markdownIt-Anchor" href="#gl_oes_egl_image"></a> <a href="https://docs.imgtec.com/reference-manuals/open-gl-es-extensions/html/topics/GL_OES_EGL/image.html">GL_OES_EGL_image</a></h1>
<p>通过 <strong>EGLImage</strong> 允许在上下文之间，API 之间 (如 OpenGL ES 与 Vulkan) 共享纹理数据。但需要纹理的 format/type 要被 OpenGL ES 支持，不支持的那些要走 <a href="https://docs.imgtec.com/reference-manuals/open-gl-es-extensions/html/topics/GL_OES_EGL/image-external.html">GL_OES_EGL_image_external</a>, 因为 format/type 不是 OpenGL ES 原生支持，所以这个扩展相比 GL_OES_EGL_image 多了几个<strong>限制</strong></p>
<ul>
<li>不能在这些纹理对象上调用 <code>gl*Tex*Image*2D()</code> 和 <code>glGenerateMipmap()</code> 函数改变原本的存储内容(原因是这些导入进来的不被支持的格式可能依赖特定的硬件特性，所以不允许导入者修改它们)</li>
<li>纹理目前只能绑定 <code>GL_TEXTURE_EXTERNAL_OES</code>, 而不是 GL_TEXTURE_2D， GL_TEXTURE_3D 等</li>
<li>纹理采样时只允许使用 <code>GL_CLAMP_TO_EDGE</code> 这一个 wrap mode</li>
<li>纹理采样时会隐式地将任何格式转换成线性 RGB</li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Mesa</tag>
        <tag>EGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Generic Buffer Manager</title>
    <url>/gfx/gbm/</url>
    <content><![CDATA[<p><img src="/images/gbm/gbm.png" alt="gbm dri backend implemented in Mesa" /></p>
<span id="more"></span>
<p>GBM 是 Linux 图形栈中的重要组件，它定义了一组分配 GPU 缓冲区 (Buffer Object) 的<a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gbm/main/gbm.h">接口</a>。Mesa 中提供一个基于 DRI 的后端<a href="https://gitlab.freedesktop.org/mesa/mesa/-/tree/main/src/gbm/backends/dri">实现</a></p>
<h1 id="gralloc"><a class="markdownIt-Anchor" href="#gralloc"></a> <a href="https://android.googlesource.com/platform/hardware/libhardware/">Gralloc</a></h1>
<h1 id="minigbm"><a class="markdownIt-Anchor" href="#minigbm"></a> <a href="https://chromium.googlesource.com/chromiumos/platform/minigbm/">minigbm</a></h1>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>gfxstream - Graphics Streaming Kit</title>
    <url>/gfx/gfxstream/</url>
    <content><![CDATA[<h1 id="gfxstream"><a class="markdownIt-Anchor" href="#gfxstream"></a> <a href="https://android.googlesource.com/platform/hardware/google/gfxstream/">gfxstream</a></h1>
<span id="more"></span>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://source.android.com/docs/devices/cuttlefish/gpu?hl=zh-cn">Cuttlefish: GPU 图形加速</a></li>
<li><a href="https://github.com/google/android-cuttlefish">Virtual Device for Android host-side utilities</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>glamor</title>
    <url>/gfx/glamor/</url>
    <content><![CDATA[<h1 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h1>
<p>glamor是一个开源的2D加速驱动，它作为Xorg的一个模块被实现。相比传统的DDX 2D加速驱动，glamor主要有以下2个好处:</p>
<ul>
<li>使用非常通用的EGL/OpenGL API去操作GPU硬件，省去了手动为每个不同的GPU编写2D加速驱动的麻烦</li>
<li>有了glamor，不再需要传统的2D DDX驱动</li>
</ul>
<span id="more"></span>
<p>Xorg的glamor实现依赖3个组件:</p>
<ul>
<li>EGL/GLX   负责创建初始化reneder context</li>
<li>GL/GLES   负责绘制2D图形</li>
<li>GBM       负责管理Buffer Object（VRAM)</li>
</ul>
<h1 id="what-role-do-they-play-in-xorg-drivers"><a class="markdownIt-Anchor" href="#what-role-do-they-play-in-xorg-drivers"></a> What role do they play in Xorg drivers?</h1>
<img src="/gfx/glamor/glamor_sequence.png" class="" title="glamor_sequence">
<h1 id="gbm-generic-buffer-management"><a class="markdownIt-Anchor" href="#gbm-generic-buffer-management"></a> GBM - Generic Buffer Management</h1>
<img src="/gfx/glamor/gbm.png" class="" title="gbm internal &amp; backend">
<h1 id="how-to-get-egldisplay-from-gbm_device"><a class="markdownIt-Anchor" href="#how-to-get-egldisplay-from-gbm_device"></a> How to get EGLDisplay from gbm_device?</h1>
<img src="/gfx/glamor/glamor_egl_init.png" class="" title="glamor_egl_init">
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>glmark2 Benchmark</title>
    <url>/gfx/glmark2/</url>
    <content><![CDATA[<h1 id="something-you-should-know-about-glmark2"><a class="markdownIt-Anchor" href="#something-you-should-know-about-glmark2"></a> Something you should know about <a href="https://github.com/glmark2/glmark2">glmark2</a></h1>
<ol>
<li>glmark2 的命令行参数格式</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glmark2 -b desktop:nframes=1000000:show-fps=true -b build:duration=100</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol start="2">
<li>
<p>glmark2 每个场景 (Scene) 默认的运行时间 (duration) 是 10 秒</p>
</li>
<li>
<p>glmark2 提供一个公共选项 (Option) <strong>show-fps</strong>, 可以显示 Head-up Display (HUD) 形式的 FPS</p>
</li>
</ol>
<p><img src="/images/glmark2-desktop-show-fps.png" alt="glmark2-desktop show-fps" /></p>
<ol start="4">
<li>glmark2 计算 FPS 的时间精度 (resolution) 是 nanosecond. 它使用的是 <code>struct timespec</code>, 而不是 <code>struct timeval</code></li>
</ol>
<h1 id="desktop"><a class="markdownIt-Anchor" href="#desktop"></a> desktop</h1>
<p><strong>desktop</strong>这个场景在fragment shader中使用了<strong>convolution</strong>计算高斯模糊效果, 这里我们比较一下所有17个场景的fragment shader, 并记录一下在<strong>Mesa llvmpipe</strong>下以及<code>glmark2 -b desktop</code>不同的选项下的测试结果。</p>
<h2 id="fragment-shaders"><a class="markdownIt-Anchor" href="#fragment-shaders"></a> Fragment Shaders</h2>
<h3 id="build"><a class="markdownIt-Anchor" href="#build"></a> build</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">varying vec4 Color;</span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    gl_FragColor = Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="texture"><a class="markdownIt-Anchor" href="#texture"></a> texture</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">uniform sampler2D MaterialTexture0;</span><br><span class="line"></span><br><span class="line">varying vec4 Color;</span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 texel = texture2D(MaterialTexture0, TextureCoord);</span><br><span class="line">    gl_FragColor = texel * Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shading"><a class="markdownIt-Anchor" href="#shading"></a> shading</h3>
<figure class="highlight plaintext"><figcaption><span>shading=gouraud</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">varying vec4 Color;</span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    gl_FragColor = Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>shading=blinn-phong-inf</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const vec3 LightSourceHalfVector = vec3(0.408248, 0.408248, 0.816497);</span><br><span class="line">const vec4 LightSourcePosition = vec4(20.000000, 20.000000, 10.000000, 1.000000);</span><br><span class="line">varying vec3 Normal;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    const vec4 LightSourceAmbient = vec4(0.1, 0.1, 0.1, 1.0);</span><br><span class="line">    const vec4 LightSourceDiffuse = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 LightSourceSpecular = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 MaterialAmbient = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const vec4 MaterialDiffuse = vec4(0.0, 0.0, 1.0, 1.0);</span><br><span class="line">    const vec4 MaterialSpecular = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const float MaterialShininess = 100.0;</span><br><span class="line"></span><br><span class="line">    vec3 N = normalize(Normal);</span><br><span class="line"></span><br><span class="line">    // In the lighting model we are using here (Blinn-Phong with light at</span><br><span class="line">    // infinity, viewer at infinity), the light position/direction and the</span><br><span class="line">    // half vector is constant for the all the fragments.</span><br><span class="line">    vec3 L = normalize(LightSourcePosition.xyz);</span><br><span class="line">    vec3 H = normalize(LightSourceHalfVector);</span><br><span class="line"></span><br><span class="line">    // Calculate the diffuse color according to Lambertian reflectance</span><br><span class="line">    vec4 diffuse = MaterialDiffuse * LightSourceDiffuse * max(dot(N, L), 0.0);</span><br><span class="line"></span><br><span class="line">    // Calculate the ambient color</span><br><span class="line">    vec4 ambient = MaterialAmbient * LightSourceAmbient;</span><br><span class="line"></span><br><span class="line">    // Calculate the specular color according to the Blinn-Phong model</span><br><span class="line">    vec4 specular = MaterialSpecular * LightSourceSpecular *</span><br><span class="line">                    pow(max(dot(N,H), 0.0), MaterialShininess);</span><br><span class="line"></span><br><span class="line">    // Calculate the final color</span><br><span class="line">    gl_FragColor = vec4((ambient + specular + diffuse).xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>shading=phong</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const vec4 MaterialDiffuse = vec4(0.000000, 0.000000, 1.000000, 1.000000);</span><br><span class="line">const vec4 LightColor0 = vec4(0.800000, 0.800000, 0.800000, 1.000000);</span><br><span class="line">const vec4 LightSourcePosition0 = vec4(0.000000, 1.000000, 0.000000, 1.000000);</span><br><span class="line">varying vec3 vertex_normal;</span><br><span class="line">varying vec4 vertex_position;</span><br><span class="line"></span><br><span class="line">vec4</span><br><span class="line">compute_color(vec4 light_position, vec4 diffuse_light_color)</span><br><span class="line">&#123;</span><br><span class="line">    const vec4 lightAmbient = vec4(0.1, 0.1, 0.1, 1.0);</span><br><span class="line">    const vec4 lightSpecular = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 matAmbient = vec4(0.2, 0.2, 0.2, 1.0);</span><br><span class="line">    const vec4 matSpecular = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const float matShininess = 100.0;</span><br><span class="line">    vec3 eye_direction = normalize(-vertex_position.xyz);</span><br><span class="line">    vec3 light_direction = normalize(light_position.xyz/light_position.w -</span><br><span class="line">                                     vertex_position.xyz/vertex_position.w);</span><br><span class="line">    vec3 normalized_normal = normalize(vertex_normal);</span><br><span class="line">    vec3 reflection = reflect(-light_direction, normalized_normal);</span><br><span class="line">    float specularTerm = pow(max(0.0, dot(reflection, eye_direction)), matShininess);</span><br><span class="line">    float diffuseTerm = max(0.0, dot(normalized_normal, light_direction));</span><br><span class="line">    vec4 specular = (lightSpecular * matSpecular);</span><br><span class="line">    vec4 ambient = (lightAmbient * matAmbient);</span><br><span class="line">    vec4 diffuse = (diffuse_light_color * MaterialDiffuse);</span><br><span class="line">    vec4 result = (specular * specularTerm) + ambient + (diffuse * diffuseTerm);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);</span><br><span class="line">    gl_FragColor += compute_color(LightSourcePosition0, LightColor0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>shading=cel</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">varying vec3 vertex_normal;</span><br><span class="line">varying vec4 vertex_position;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    const vec4 OutlineColor = vec4(0.0, 0.0, 0.0, 1.0);</span><br><span class="line">    const vec2 OutlineThickness = vec2(0.1, 0.4);</span><br><span class="line">    const vec4 BaseColor = vec4(0.0, 0.3, 0.0, 1.0);</span><br><span class="line">    const vec4 LightColor = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const vec4 LightSourcePosition = vec4(4.0, 3.0, 1.0, 1.0);</span><br><span class="line">    const vec4 DiffuseColor = vec4(0.0, 0.6, 0.0, 1.0);</span><br><span class="line">    const vec4 SpecularColor = vec4(1.0, 1.0, 1.0, 0.7);</span><br><span class="line">    const float DiffuseThreshold = 0.1;</span><br><span class="line">    const float SpecularThreshold = 0.5;</span><br><span class="line">    const float Shininess = 10.0;</span><br><span class="line"></span><br><span class="line">    // Initialize the fragment color with an unlit value.</span><br><span class="line">    vec4 fragColor = BaseColor;</span><br><span class="line"></span><br><span class="line">    // Set up factors for computing diffuse illumination</span><br><span class="line">    vec3 vertex_light = LightSourcePosition.xyz - vertex_position.xyz;</span><br><span class="line">    vec3 N = normalize(vertex_normal);</span><br><span class="line">    vec3 L = normalize(vertex_light);</span><br><span class="line">    float NdotL = dot(N, L);</span><br><span class="line">    float maxNdotL = max(NdotL, 0.0);</span><br><span class="line">    float attenuation = length(LightSourcePosition) / length(vertex_light);</span><br><span class="line"></span><br><span class="line">    // See if we have a diffuse contribution...</span><br><span class="line">    // This will only be true if the interpolated normal and the light</span><br><span class="line">    // are pointing in the &quot;same&quot; direction, and the attenuation due to</span><br><span class="line">    // distance allows enough light for diffuse reflection.</span><br><span class="line">    if (attenuation * maxNdotL &gt;= DiffuseThreshold) &#123;</span><br><span class="line">        fragColor = LightColor * DiffuseColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // See if this fragment is part of the silhouette</span><br><span class="line">    // If it is facing away from the viewer enough not to get any</span><br><span class="line">    // diffuse illumination contribution, then it is close enough</span><br><span class="line">    // to the silouhette to be painted with the outline color rather</span><br><span class="line">    // than the unlit color.</span><br><span class="line">    vec3 V = normalize(-vertex_position.xyz);</span><br><span class="line">    if (dot(V, N) &lt;</span><br><span class="line">        mix(OutlineThickness.x, OutlineThickness.y, maxNdotL)) &#123;</span><br><span class="line">        fragColor = LightColor * OutlineColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // See if we have a specular contribution...</span><br><span class="line">    // If the interpolated normal direction and the light direction</span><br><span class="line">    // are facing the &quot;same&quot; direction, and the attenuated specular</span><br><span class="line">    // intensity is strong enough, then we have a contribution.</span><br><span class="line">    vec3 R = reflect(-L, N);</span><br><span class="line">    float specularIntensity = pow(max(0.0, dot(R, V)), Shininess);</span><br><span class="line">    if (NdotL &gt; 0.0 &amp;&amp; attenuation * specularIntensity &gt; SpecularThreshold) &#123;</span><br><span class="line">        fragColor = SpecularColor.a * LightColor * SpecularColor +</span><br><span class="line">            (1.0 - SpecularColor.a) * fragColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Emit the final color</span><br><span class="line">    gl_FragColor = vec4(fragColor.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bump"><a class="markdownIt-Anchor" href="#bump"></a> bump</h3>
<figure class="highlight plaintext"><figcaption><span>bump-render=high-poly</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const vec3 LightSourceHalfVector = vec3(0.408248, 0.408248, 0.816497);</span><br><span class="line">const vec4 LightSourcePosition = vec4(20.000000, 20.000000, 10.000000, 1.000000);</span><br><span class="line">varying vec3 Normal;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    const vec4 LightSourceAmbient = vec4(0.1, 0.1, 0.1, 1.0);</span><br><span class="line">    const vec4 LightSourceDiffuse = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 LightSourceSpecular = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 MaterialAmbient = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const vec4 MaterialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const vec4 MaterialSpecular = vec4(0.2, 0.2, 0.2, 1.0);</span><br><span class="line">    const float MaterialShininess = 100.0;</span><br><span class="line"></span><br><span class="line">    vec3 N = normalize(Normal);</span><br><span class="line"></span><br><span class="line">    // In the lighting model we are using here (Blinn-Phong with light at</span><br><span class="line">    // infinity, viewer at infinity), the light position/direction and the</span><br><span class="line">    // half vector is constant for the all the fragments.</span><br><span class="line">    vec3 L = normalize(LightSourcePosition.xyz);</span><br><span class="line">    vec3 H = normalize(LightSourceHalfVector);</span><br><span class="line"></span><br><span class="line">    // Calculate the diffuse color according to Lambertian reflectance</span><br><span class="line">    vec4 diffuse = MaterialDiffuse * LightSourceDiffuse * max(dot(N, L), 0.0);</span><br><span class="line"></span><br><span class="line">    // Calculate the ambient color</span><br><span class="line">    vec4 ambient = MaterialAmbient * LightSourceAmbient;</span><br><span class="line"></span><br><span class="line">    // Calculate the specular color according to the Blinn-Phong model</span><br><span class="line">    vec4 specular = MaterialSpecular * LightSourceSpecular *</span><br><span class="line">                    pow(max(dot(N,H), 0.0), MaterialShininess);</span><br><span class="line"></span><br><span class="line">    // Calculate the final color</span><br><span class="line">    gl_FragColor = ambient + specular + diffuse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>bump-render=normals</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const vec3 LightSourceHalfVector = vec3(0.408248, 0.408248, 0.816497);</span><br><span class="line">const vec4 LightSourcePosition = vec4(20.000000, 20.000000, 10.000000, 1.000000);</span><br><span class="line">uniform sampler2D NormalMap;</span><br><span class="line">uniform mat4 NormalMatrix;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    const vec4 LightSourceAmbient = vec4(0.1, 0.1, 0.1, 1.0);</span><br><span class="line">    const vec4 LightSourceDiffuse = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 LightSourceSpecular = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 MaterialAmbient = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const vec4 MaterialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const vec4 MaterialSpecular = vec4(0.2, 0.2, 0.2, 1.0);</span><br><span class="line">    const float MaterialShininess = 100.0;</span><br><span class="line"></span><br><span class="line">    // Get the raw normal XYZ data from the normal map</span><br><span class="line">    vec3 normal_raw = texture2D(NormalMap, TextureCoord).xyz;</span><br><span class="line">    // Map &quot;color&quot; range [0, 1.0] to normal range [-1.0, 1.0]</span><br><span class="line">    vec3 normal_scaled = normal_raw * 2.0 - 1.0;</span><br><span class="line"></span><br><span class="line">    // Convert the normal to eye coordinates. Note that the normal map</span><br><span class="line">    // we are using is using object coordinates (not tangent!) for the</span><br><span class="line">    // normals, so we can multiply by the NormalMatrix as usual.</span><br><span class="line">    vec3 N = normalize(vec3(NormalMatrix * vec4(normal_scaled, 1.0)));</span><br><span class="line"></span><br><span class="line">    // In the lighting model we are using here (Blinn-Phong with light at</span><br><span class="line">    // infinity, viewer at infinity), the light position/direction and the</span><br><span class="line">    // half vector is constant for the all the fragments.</span><br><span class="line">    vec3 L = normalize(LightSourcePosition.xyz);</span><br><span class="line">    vec3 H = normalize(LightSourceHalfVector);</span><br><span class="line"></span><br><span class="line">    // Calculate the diffuse color according to Lambertian reflectance</span><br><span class="line">    vec4 diffuse = MaterialDiffuse * LightSourceDiffuse * max(dot(N, L), 0.0);</span><br><span class="line"></span><br><span class="line">    // Calculate the ambient color</span><br><span class="line">    vec4 ambient = MaterialAmbient * LightSourceAmbient;</span><br><span class="line"></span><br><span class="line">    // Calculate the specular color according to the Blinn-Phong model</span><br><span class="line">    vec4 specular = MaterialSpecular * LightSourceSpecular *</span><br><span class="line">                    pow(max(dot(N,H), 0.0), MaterialShininess);</span><br><span class="line"></span><br><span class="line">    // Calculate the final color</span><br><span class="line">    gl_FragColor = ambient + specular + diffuse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>bump-render=height</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepY = 0.000977;</span><br><span class="line">const float TextureStepX = 0.000977;</span><br><span class="line">const vec3 LightSourceHalfVector = vec3(0.408248, 0.408248, 0.816497);</span><br><span class="line">const vec4 LightSourcePosition = vec4(20.000000, 20.000000, 10.000000, 1.000000);</span><br><span class="line"></span><br><span class="line">uniform sampler2D HeightMap;</span><br><span class="line"></span><br><span class="line">#ifdef GL_FRAGMENT_PRECISION_HIGH</span><br><span class="line">varying highp vec2 TextureCoord;</span><br><span class="line">#else</span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">varying vec3 NormalEye;</span><br><span class="line">varying vec3 TangentEye;</span><br><span class="line">varying vec3 BitangentEye;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    const vec4 LightSourceAmbient = vec4(0.1, 0.1, 0.1, 1.0);</span><br><span class="line">    const vec4 LightSourceDiffuse = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 LightSourceSpecular = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 MaterialAmbient = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const vec4 MaterialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const vec4 MaterialSpecular = vec4(0.2, 0.2, 0.2, 1.0);</span><br><span class="line">    const float MaterialShininess = 100.0;</span><br><span class="line">    const float height_factor = 13.0;</span><br><span class="line"></span><br><span class="line">    // Get the data from the height map</span><br><span class="line">    float height0 = texture2D(HeightMap, TextureCoord).x;</span><br><span class="line">    float heightX = texture2D(HeightMap, TextureCoord + vec2(TextureStepX, 0.0)).x;</span><br><span class="line">    float heightY = texture2D(HeightMap, TextureCoord + vec2(0.0, TextureStepY)).x;</span><br><span class="line">    vec2 dh = vec2(heightX - height0, heightY - height0);</span><br><span class="line"></span><br><span class="line">    // Adjust the normal based on the height map data</span><br><span class="line">    vec3 N = NormalEye - height_factor * dh.x * TangentEye -</span><br><span class="line">                         height_factor * dh.y * BitangentEye;</span><br><span class="line">    N = normalize(N);</span><br><span class="line"></span><br><span class="line">    // In the lighting model we are using here (Blinn-Phong with light at</span><br><span class="line">    // infinity, viewer at infinity), the light position/direction and the</span><br><span class="line">    // half vector is constant for the all the fragments.</span><br><span class="line">    vec3 L = normalize(LightSourcePosition.xyz);</span><br><span class="line">    vec3 H = normalize(LightSourceHalfVector);</span><br><span class="line"></span><br><span class="line">    // Calculate the diffuse color according to Lambertian reflectance</span><br><span class="line">    vec4 diffuse = MaterialDiffuse * LightSourceDiffuse * max(dot(N, L), 0.0);</span><br><span class="line"></span><br><span class="line">    // Calculate the ambient color</span><br><span class="line">    vec4 ambient = MaterialAmbient * LightSourceAmbient;</span><br><span class="line"></span><br><span class="line">    // Calculate the specular color according to the Blinn-Phong model</span><br><span class="line">    vec4 specular = MaterialSpecular * LightSourceSpecular *</span><br><span class="line">                    pow(max(dot(N,H), 0.0), MaterialShininess);</span><br><span class="line"></span><br><span class="line">    // Calculate the final color</span><br><span class="line">    gl_FragColor = ambient + specular + diffuse;</span><br><span class="line"></span><br><span class="line">    //gl_FragColor = vec4(height_diff_raw.xy, 0.0, 1.0);</span><br><span class="line">    //gl_FragColor = vec4(height_diff_scaled.xy, 0.0, 1.0);</span><br><span class="line">    //gl_FragColor = vec4(Tangent, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="effect2d"><a class="markdownIt-Anchor" href="#effect2d"></a> effect2d</h3>
<figure class="highlight plaintext"><figcaption><span>kernel=0,1,0;1,-4,1;0,1,0;</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float Kernel0 = 0.000000;</span><br><span class="line">const float Kernel1 = 0.250000;</span><br><span class="line">const float Kernel2 = 0.000000;</span><br><span class="line">const float Kernel3 = 0.250000;</span><br><span class="line">const float Kernel4 = -1.000000;</span><br><span class="line">const float Kernel5 = 0.250000;</span><br><span class="line">const float Kernel6 = 0.000000;</span><br><span class="line">const float Kernel7 = 0.250000;</span><br><span class="line">const float Kernel8 = 0.000000;</span><br><span class="line">const float TextureStepY = 0.001667;</span><br><span class="line">const float TextureStepX = 0.001250;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, 1.0 * TextureStepY)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, 1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, 1.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, 0.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, 0.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, 0.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, -1.0 * TextureStepY)) * Kernel6 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, -1.0 * TextureStepY)) * Kernel7 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, -1.0 * TextureStepY)) * Kernel8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>kernel=1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float Kernel0 = 0.066667;</span><br><span class="line">const float Kernel1 = 0.066667;</span><br><span class="line">const float Kernel2 = 0.066667;</span><br><span class="line">const float Kernel3 = 0.066667;</span><br><span class="line">const float Kernel4 = 0.066667;</span><br><span class="line">const float Kernel5 = 0.066667;</span><br><span class="line">const float Kernel6 = 0.066667;</span><br><span class="line">const float Kernel7 = 0.066667;</span><br><span class="line">const float Kernel8 = 0.066667;</span><br><span class="line">const float Kernel9 = 0.066667;</span><br><span class="line">const float Kernel10 = 0.066667;</span><br><span class="line">const float Kernel11 = 0.066667;</span><br><span class="line">const float Kernel12 = 0.066667;</span><br><span class="line">const float Kernel13 = 0.066667;</span><br><span class="line">const float Kernel14 = 0.066667;</span><br><span class="line">const float TextureStepY = 0.001667;</span><br><span class="line">const float TextureStepX = 0.001250;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = texture2D(Texture0, TextureCoord + vec2(-2.0 * TextureStepX, 1.0 * TextureStepY)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, 1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, 1.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, 1.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(2.0 * TextureStepX, 1.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-2.0 * TextureStepX, 0.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, 0.0 * TextureStepY)) * Kernel6 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, 0.0 * TextureStepY)) * Kernel7 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, 0.0 * TextureStepY)) * Kernel8 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(2.0 * TextureStepX, 0.0 * TextureStepY)) * Kernel9 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-2.0 * TextureStepX, -1.0 * TextureStepY)) * Kernel10 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, -1.0 * TextureStepY)) * Kernel11 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, -1.0 * TextureStepY)) * Kernel12 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, -1.0 * TextureStepY)) * Kernel13 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(2.0 * TextureStepX, -1.0 * TextureStepY)) * Kernel14;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pulsar"><a class="markdownIt-Anchor" href="#pulsar"></a> pulsar</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">varying vec4 Color;</span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    gl_FragColor = Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="desktop-2"><a class="markdownIt-Anchor" href="#desktop-2"></a> desktop</h3>
<figure class="highlight plaintext"><figcaption><span>blur-radius=5:effect=blur:passes=1:separable=true:windows=4</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepX = 0.001250;</span><br><span class="line">const float Kernel5 = 0.002659;</span><br><span class="line">const float Kernel4 = 0.013437;</span><br><span class="line">const float Kernel3 = 0.047370;</span><br><span class="line">const float Kernel2 = 0.116512;</span><br><span class="line">const float Kernel1 = 0.199935;</span><br><span class="line">const float Kernel0 = 0.239365;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-5.0 * TextureStepX, 0.0)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-4.0 * TextureStepX, 0.0)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-3.0 * TextureStepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-2.0 * TextureStepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, 0.0)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(2.0 * TextureStepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(3.0 * TextureStepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(4.0 * TextureStepX, 0.0)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(5.0 * TextureStepX, 0.0)) * Kernel5 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>blur-radius=5:effect=blur:passes=1:separable=true:windows=4</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepY = 0.001667;</span><br><span class="line">const float Kernel5 = 0.002659;</span><br><span class="line">const float Kernel4 = 0.013437;</span><br><span class="line">const float Kernel3 = 0.047370;</span><br><span class="line">const float Kernel2 = 0.116512;</span><br><span class="line">const float Kernel1 = 0.199935;</span><br><span class="line">const float Kernel0 = 0.239365;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -5.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -4.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -3.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -2.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 0.0 * TextureStepY)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 2.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 3.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 4.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 5.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>blur-radius=5:effect=blur:passes=1:separable=true:windows=4</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepX = 0.001250;</span><br><span class="line">const float Kernel5 = 0.002659;</span><br><span class="line">const float Kernel4 = 0.013437;</span><br><span class="line">const float Kernel3 = 0.047370;</span><br><span class="line">const float Kernel2 = 0.116512;</span><br><span class="line">const float Kernel1 = 0.199935;</span><br><span class="line">const float Kernel0 = 0.239365;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-5.0 * TextureStepX, 0.0)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-4.0 * TextureStepX, 0.0)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-3.0 * TextureStepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-2.0 * TextureStepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, 0.0)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(2.0 * TextureStepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(3.0 * TextureStepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(4.0 * TextureStepX, 0.0)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(5.0 * TextureStepX, 0.0)) * Kernel5 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>blur-radius=5:effect=blur:passes=1:separable=true:windows=4</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepY = 0.001667;</span><br><span class="line">const float Kernel5 = 0.002659;</span><br><span class="line">const float Kernel4 = 0.013437;</span><br><span class="line">const float Kernel3 = 0.047370;</span><br><span class="line">const float Kernel2 = 0.116512;</span><br><span class="line">const float Kernel1 = 0.199935;</span><br><span class="line">const float Kernel0 = 0.239365;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -5.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -4.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -3.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -2.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 0.0 * TextureStepY)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 2.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 3.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 4.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 5.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>blur-radius=5:effect=blur:passes=1:separable=true:windows=4</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepX = 0.001250;</span><br><span class="line">const float Kernel5 = 0.002659;</span><br><span class="line">const float Kernel4 = 0.013437;</span><br><span class="line">const float Kernel3 = 0.047370;</span><br><span class="line">const float Kernel2 = 0.116512;</span><br><span class="line">const float Kernel1 = 0.199935;</span><br><span class="line">const float Kernel0 = 0.239365;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-5.0 * TextureStepX, 0.0)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-4.0 * TextureStepX, 0.0)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-3.0 * TextureStepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-2.0 * TextureStepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, 0.0)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(2.0 * TextureStepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(3.0 * TextureStepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(4.0 * TextureStepX, 0.0)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(5.0 * TextureStepX, 0.0)) * Kernel5 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>blur-radius=5:effect=blur:passes=1:separable=true:windows=4</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepY = 0.001667;</span><br><span class="line">const float Kernel5 = 0.002659;</span><br><span class="line">const float Kernel4 = 0.013437;</span><br><span class="line">const float Kernel3 = 0.047370;</span><br><span class="line">const float Kernel2 = 0.116512;</span><br><span class="line">const float Kernel1 = 0.199935;</span><br><span class="line">const float Kernel0 = 0.239365;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -5.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -4.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -3.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -2.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 0.0 * TextureStepY)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 2.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 3.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 4.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 5.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>blur-radius=5:effect=blur:passes=1:separable=true:windows=4</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepX = 0.001250;</span><br><span class="line">const float Kernel5 = 0.002659;</span><br><span class="line">const float Kernel4 = 0.013437;</span><br><span class="line">const float Kernel3 = 0.047370;</span><br><span class="line">const float Kernel2 = 0.116512;</span><br><span class="line">const float Kernel1 = 0.199935;</span><br><span class="line">const float Kernel0 = 0.239365;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-5.0 * TextureStepX, 0.0)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-4.0 * TextureStepX, 0.0)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-3.0 * TextureStepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-2.0 * TextureStepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * TextureStepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * TextureStepX, 0.0)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * TextureStepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(2.0 * TextureStepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(3.0 * TextureStepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(4.0 * TextureStepX, 0.0)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(5.0 * TextureStepX, 0.0)) * Kernel5 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>blur-radius=5:effect=blur:passes=1:separable=true:windows=4</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepY = 0.001667;</span><br><span class="line">const float Kernel5 = 0.002659;</span><br><span class="line">const float Kernel4 = 0.013437;</span><br><span class="line">const float Kernel3 = 0.047370;</span><br><span class="line">const float Kernel2 = 0.116512;</span><br><span class="line">const float Kernel1 = 0.199935;</span><br><span class="line">const float Kernel0 = 0.239365;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line"></span><br><span class="line">    result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -5.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -4.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -3.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -2.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 0.0 * TextureStepY)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 1.0 * TextureStepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 2.0 * TextureStepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 3.0 * TextureStepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 4.0 * TextureStepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 5.0 * TextureStepY)) * Kernel5 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>effect=shadow:windows=4</span></figcaption><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">uniform sampler2D MaterialTexture0;</span><br><span class="line"></span><br><span class="line">varying vec2 TextureCoord;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 texel = texture2D(MaterialTexture0, TextureCoord);</span><br><span class="line">    gl_FragColor = texel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> buffer</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">varying vec4 dist;</span><br><span class="line"></span><br><span class="line">const vec4 LINE_COLOR = vec4(1.0);</span><br><span class="line">const vec4 TRIANGLE_COLOR = vec4(0.0, 0.5, 0.8, 0.8);</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    // Get the minimum distance of this fragment from a triangle edge.</span><br><span class="line">    // We need to multiply with dist.w to undo the workaround we had</span><br><span class="line">    // to perform to get linear interpolation (instead of perspective correct).</span><br><span class="line">    float d = min(dist.x * dist.w, min(dist.y * dist.w, dist.z * dist.w));</span><br><span class="line"></span><br><span class="line">    // Get the intensity of the wireframe line</span><br><span class="line">    float I = exp2(-2.0 * d * d);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = mix(TRIANGLE_COLOR, LINE_COLOR, I);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ideas"><a class="markdownIt-Anchor" href="#ideas"></a> ideas</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">varying vec4 color;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_FragColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">uniform vec4 light0Position;</span><br><span class="line">varying vec3 vertex_normal;</span><br><span class="line">varying vec4 vertex_position;</span><br><span class="line">varying vec3 eye_direction;</span><br><span class="line"></span><br><span class="line">vec3 unitvec(vec4 v1, vec4 v2)</span><br><span class="line">&#123;</span><br><span class="line">    if (v1.w == 0.0 &amp;&amp; v2.w == 0.0)</span><br><span class="line">        return vec3(v2 - v1);</span><br><span class="line">    if (v1.w == 0.0)</span><br><span class="line">        return vec3(-v1);</span><br><span class="line">    if (v2.w == 0.0)</span><br><span class="line">        return vec3(v2);</span><br><span class="line">    return v2.xyz/v2.w - v1.xyz/v1.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vec4 lightAmbient = vec4(0.0, 0.0, 0.0, 1.0);</span><br><span class="line">    vec4 lightDiffuse = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    vec4 lightSpecular = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    vec4 matAmbient = vec4(0.1, 0.1, 0.1, 1.0);</span><br><span class="line">    vec4 matDiffuse = vec4(0.5, 0.4, 0.7, 1.0);</span><br><span class="line">    vec4 matSpecular = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    float matShininess = 30.0;</span><br><span class="line">    vec3 light_direction = normalize(unitvec(vertex_position, light0Position));</span><br><span class="line">    vec3 normalized_normal = normalize(vertex_normal);</span><br><span class="line">    vec3 reflection = reflect(-light_direction, normalized_normal);</span><br><span class="line">    float specularTerm = pow(max(0.0, dot(reflection, eye_direction)), matShininess);</span><br><span class="line">    float diffuseTerm = max(0.0, dot(normalized_normal, light_direction));</span><br><span class="line">    vec4 specular = (lightSpecular * matSpecular);</span><br><span class="line">    vec4 ambient = (lightAmbient * matAmbient);</span><br><span class="line">    vec4 diffuse = (lightDiffuse * matDiffuse);</span><br><span class="line">    gl_FragColor = (specular * specularTerm) + ambient + (diffuse * diffuseTerm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">uniform sampler2D tex;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vec2 curPos = gl_FragCoord.xy / 32.0;</span><br><span class="line">    vec4 color = texture2D(tex, curPos);</span><br><span class="line">    if (color.w &lt; 0.5)</span><br><span class="line">        discard;</span><br><span class="line">    gl_FragColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">struct LightSourceParameters</span><br><span class="line">&#123;</span><br><span class="line">    vec4 ambient;</span><br><span class="line">    vec4 diffuse;</span><br><span class="line">    vec4 specular;</span><br><span class="line">    vec4 position;</span><br><span class="line">&#125;;</span><br><span class="line">LightSourceParameters lightSource[3];</span><br><span class="line">uniform vec4 light0Position;</span><br><span class="line">uniform vec4 light1Position;</span><br><span class="line">uniform vec4 light2Position;</span><br><span class="line">varying vec3 vertex_normal;</span><br><span class="line">varying vec4 vertex_position;</span><br><span class="line">varying vec3 eye_direction;</span><br><span class="line"></span><br><span class="line">vec3 unitvec(vec4 v1, vec4 v2)</span><br><span class="line">&#123;</span><br><span class="line">    if (v1.w == 0.0 &amp;&amp; v2.w == 0.0)</span><br><span class="line">        return vec3(v2 - v1);</span><br><span class="line">    if (v1.w == 0.0)</span><br><span class="line">        return vec3(-v1);</span><br><span class="line">    if (v2.w == 0.0)</span><br><span class="line">        return vec3(v2);</span><br><span class="line">    return v2.xyz/v2.w - v1.xyz/v1.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    lightSource[0] = LightSourceParameters(</span><br><span class="line">        vec4(0.0, 0.0, 0.0, 1.0),</span><br><span class="line">        vec4(1.0, 1.0, 1.0, 1.0),</span><br><span class="line">        vec4(1.0, 1.0, 1.0, 1.0),</span><br><span class="line">        vec4(0.0, 1.0, 0.0, 0.0)</span><br><span class="line">    );</span><br><span class="line">    lightSource[1] = LightSourceParameters(</span><br><span class="line">        vec4(0.0, 0.0, 0.0, 1.0),</span><br><span class="line">        vec4(0.3, 0.3, 0.5, 1.0),</span><br><span class="line">        vec4(0.3, 0.3, 0.5, 1.0),</span><br><span class="line">        vec4(-1.0, 0.0, 0.0, 0.0)</span><br><span class="line">    );</span><br><span class="line">    lightSource[2] = LightSourceParameters(</span><br><span class="line">        vec4(0.2, 0.2, 0.2, 1.0),</span><br><span class="line">        vec4(0.2, 0.2, 0.2, 1.0),</span><br><span class="line">        vec4(0.2, 0.2, 0.2, 1.0),</span><br><span class="line">        vec4(0.0, -1.0, 0.0, 0.0)</span><br><span class="line">    );</span><br><span class="line">    vec4 matAmbient = vec4(0.0, 0.0, 0.0, 1.0);</span><br><span class="line">    vec4 matDiffuse = vec4(1.0, 0.2, 0.2, 1.0);</span><br><span class="line">    vec4 matSpecular = vec4(0.5, 0.5, 0.5, 1.0);</span><br><span class="line">    float matShininess = 20.0;</span><br><span class="line">    vec4 diffuseSum = vec4(0.0, 0.0, 0.0, 0.0);</span><br><span class="line">    vec4 specularSum = vec4(0.0, 0.0, 0.0, 0.0);</span><br><span class="line">    vec4 ambientSum = vec4(0.0, 0.0, 0.0, 0.0);</span><br><span class="line">    vec3 normalized_normal = normalize(vertex_normal);</span><br><span class="line">    lightSource[0].position = light0Position;</span><br><span class="line">    lightSource[1].position = light1Position;</span><br><span class="line">    lightSource[2].position = light2Position;</span><br><span class="line">    for (int light = 0; light &lt; 3; light++) &#123;</span><br><span class="line">        vec4 light_position = lightSource[light].position;</span><br><span class="line">        vec3 light_direction = normalize(unitvec(vertex_position, light_position));</span><br><span class="line">        vec3 reflection = reflect(-light_direction, normalized_normal);</span><br><span class="line">        specularSum += pow(max(0.0, dot(reflection, eye_direction)), matShininess) * lightSource[light].specular;</span><br><span class="line">        diffuseSum += max(0.0, dot(normalized_normal, light_direction)) * lightSource[light].diffuse;</span><br><span class="line">        ambientSum += lightSource[light].ambient;</span><br><span class="line">    &#125;</span><br><span class="line">    gl_FragColor = (matSpecular * specularSum) + (matAmbient * ambientSum) + (matDiffuse * diffuseSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="terrain"><a class="markdownIt-Anchor" href="#terrain"></a> terrain</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">//</span><br><span class="line">// Description : Array and textureless GLSL 3D simplex noise function.</span><br><span class="line">//      Author : Ian McEwan, Ashima Arts.</span><br><span class="line">//  Maintainer : ijm</span><br><span class="line">//     Lastmod : 20110409 (stegu)</span><br><span class="line">//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.</span><br><span class="line">//               Distributed under the MIT License. See LICENSE file.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#ifdef GL_ES</span><br><span class="line">#define MEDIUMP mediump</span><br><span class="line">#else</span><br><span class="line">#define MEDIUMP</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">uniform float time;</span><br><span class="line">uniform MEDIUMP vec2 uvScale;</span><br><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">#ifdef GL_FRAGMENT_PRECISION_HIGH</span><br><span class="line">// x should be passed as highp since the intermediate multiplications can</span><br><span class="line">// overflow with mediump</span><br><span class="line">vec4 permute(highp vec4 x)</span><br><span class="line">#else</span><br><span class="line">vec4 permute(vec4 x)</span><br><span class="line">#endif</span><br><span class="line">&#123;</span><br><span class="line">    return mod(((x * 34.0) + 1.0) * x, 289.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vec4 taylorInvSqrt(vec4 r)</span><br><span class="line">&#123;</span><br><span class="line">    return 1.79284291400159 - 0.85373472095314 * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float snoise(vec3 v)</span><br><span class="line">&#123;</span><br><span class="line">    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);</span><br><span class="line">    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line">    // First corner</span><br><span class="line">    vec3 i  = floor(v + dot(v, C.yyy));</span><br><span class="line">    vec3 x0 = v - i + dot(i, C.xxx);</span><br><span class="line"></span><br><span class="line">    // Other corners</span><br><span class="line">    vec3 g = step(x0.yzx, x0.xyz);</span><br><span class="line">    vec3 l = 1.0 - g;</span><br><span class="line">    vec3 i1 = min(g.xyz, l.zxy);</span><br><span class="line">    vec3 i2 = max(g.xyz, l.zxy);</span><br><span class="line"></span><br><span class="line">    vec3 x1 = x0 - i1 + 1.0 * C.xxx;</span><br><span class="line">    vec3 x2 = x0 - i2 + 2.0 * C.xxx;</span><br><span class="line">    vec3 x3 = x0 - 1. + 3.0 * C.xxx;</span><br><span class="line"></span><br><span class="line">    // Permutations</span><br><span class="line">    i = mod(i, 289.0);</span><br><span class="line">    vec4 p = permute(permute(permute(</span><br><span class="line">                    i.z + vec4(0.0, i1.z, i2.z, 1.0))</span><br><span class="line">                + i.y + vec4(0.0, i1.y, i2.y, 1.0))</span><br><span class="line">            + i.x + vec4(0.0, i1.x, i2.x, 1.0));</span><br><span class="line"></span><br><span class="line">    // Gradients</span><br><span class="line">    // (N*N points uniformly over a square, mapped onto an octahedron.)</span><br><span class="line"></span><br><span class="line">    float n_ = 1.0 / 7.0; // N=7</span><br><span class="line"></span><br><span class="line">    vec3 ns = n_ * D.wyz - D.xzx;</span><br><span class="line"></span><br><span class="line">    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)</span><br><span class="line"></span><br><span class="line">    vec4 x_ = floor(j * ns.z);</span><br><span class="line">    vec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)</span><br><span class="line"></span><br><span class="line">    vec4 x = x_ *ns.x + ns.yyyy;</span><br><span class="line">    vec4 y = y_ *ns.x + ns.yyyy;</span><br><span class="line">    vec4 h = 1.0 - abs(x) - abs(y);</span><br><span class="line"></span><br><span class="line">    vec4 b0 = vec4(x.xy, y.xy);</span><br><span class="line">    vec4 b1 = vec4(x.zw, y.zw);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vec4 s0 = floor(b0) * 2.0 + 1.0;</span><br><span class="line">    vec4 s1 = floor(b1) * 2.0 + 1.0;</span><br><span class="line">    vec4 sh = -step(h, vec4(0.0));</span><br><span class="line"></span><br><span class="line">    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;</span><br><span class="line">    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;</span><br><span class="line"></span><br><span class="line">    vec3 p0 = vec3(a0.xy, h.x);</span><br><span class="line">    vec3 p1 = vec3(a0.zw, h.y);</span><br><span class="line">    vec3 p2 = vec3(a1.xy, h.z);</span><br><span class="line">    vec3 p3 = vec3(a1.zw, h.w);</span><br><span class="line"></span><br><span class="line">    // Normalise gradients</span><br><span class="line"></span><br><span class="line">    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));</span><br><span class="line">    p0 *= norm.x;</span><br><span class="line">    p1 *= norm.y;</span><br><span class="line">    p2 *= norm.z;</span><br><span class="line">    p3 *= norm.w;</span><br><span class="line"></span><br><span class="line">    // Mix final noise value</span><br><span class="line"></span><br><span class="line">    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);</span><br><span class="line">    m = m * m;</span><br><span class="line">    return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1),</span><br><span class="line">                dot(p2, x2), dot(p3, x3)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float surface3(vec3 coord)</span><br><span class="line">&#123;</span><br><span class="line">    float n = 0.0;</span><br><span class="line"></span><br><span class="line">    n += 1.0 * abs(snoise(coord));</span><br><span class="line">    n += 0.5 * abs(snoise(coord * 2.0));</span><br><span class="line">    n += 0.25 * abs(snoise(coord * 4.0));</span><br><span class="line">    n += 0.125 * abs(snoise(coord * 8.0));</span><br><span class="line"></span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec3 coord = vec3(vUv.x, uvScale.y - vUv.y, -time);</span><br><span class="line">    float n = surface3(coord);</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(vec3(n, n, n), 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">uniform float height;</span><br><span class="line">uniform vec2 resolution;</span><br><span class="line">uniform sampler2D heightMap;</span><br><span class="line"></span><br><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    float val = texture2D( heightMap, vUv ).x;</span><br><span class="line"></span><br><span class="line">    float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;</span><br><span class="line">    float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">uniform sampler2D tDiffuse;</span><br><span class="line"></span><br><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vec4 texel = texture2D( tDiffuse, vUv );</span><br><span class="line"></span><br><span class="line">    vec3 luma = vec3( 0.299, 0.587, 0.114 );</span><br><span class="line"></span><br><span class="line">    float v = dot( texel.xyz, luma );</span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4( v, v, v, texel.w );</span><br><span class="line">&#125;</span><br><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">uniform vec3 uAmbientColor;</span><br><span class="line">uniform vec3 uDiffuseColor;</span><br><span class="line">uniform vec3 uSpecularColor;</span><br><span class="line">uniform float uShininess;</span><br><span class="line">uniform float uOpacity;</span><br><span class="line">uniform sampler2D tDiffuse1;</span><br><span class="line">uniform sampler2D tDiffuse2;</span><br><span class="line">uniform sampler2D tDetail;</span><br><span class="line">uniform sampler2D tNormal;</span><br><span class="line">uniform sampler2D tSpecular;</span><br><span class="line">uniform sampler2D tDisplacement;</span><br><span class="line">uniform float uNormalScale;</span><br><span class="line">uniform vec2 uRepeatOverlay;</span><br><span class="line">uniform vec2 uOffset;</span><br><span class="line">varying vec3 vTangent;</span><br><span class="line">varying vec3 vBinormal;</span><br><span class="line">varying vec3 vNormal;</span><br><span class="line">varying vec2 vUv;</span><br><span class="line">uniform vec3 ambientLightColor;</span><br><span class="line">uniform mat4 viewMatrix;</span><br><span class="line"></span><br><span class="line">#define MAX_POINT_LIGHTS 1</span><br><span class="line">//#define USE_FOG</span><br><span class="line">//#define FOG_EXP2</span><br><span class="line"></span><br><span class="line">#if MAX_POINT_LIGHTS &gt; 0</span><br><span class="line">uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];</span><br><span class="line">uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];</span><br><span class="line">uniform float pointLightDistance[ MAX_POINT_LIGHTS ];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">varying vec3 vViewPosition;</span><br><span class="line"></span><br><span class="line">// CHUNK: fog_pars_fragment</span><br><span class="line">#ifdef USE_FOG</span><br><span class="line">uniform vec3 fogColor;</span><br><span class="line">#ifdef FOG_EXP2</span><br><span class="line">uniform float fogDensity;</span><br><span class="line">#else</span><br><span class="line">uniform float fogNear;</span><br><span class="line">uniform float fogFar;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    gl_FragColor = vec4( vec3( 1.0 ), uOpacity );</span><br><span class="line">    vec3 specularTex = vec3( 1.0 );</span><br><span class="line">    vec2 uvOverlay = uRepeatOverlay * vUv + uOffset;</span><br><span class="line">    vec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;</span><br><span class="line">    normalTex.xy *= uNormalScale;</span><br><span class="line">    normalTex = normalize( normalTex );</span><br><span class="line"></span><br><span class="line">    vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );</span><br><span class="line">    vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );</span><br><span class="line">    gl_FragColor = gl_FragColor * mix ( colDiffuse1, colDiffuse2, 1.0 - texture2D( tDisplacement, vUv) );</span><br><span class="line"></span><br><span class="line">    specularTex = texture2D( tSpecular, uvOverlay ).xyz;</span><br><span class="line"></span><br><span class="line">    mat3 tbn= mat3( vTangent, vBinormal, vNormal );</span><br><span class="line">    vec3 finalNormal = tbn * normalTex;</span><br><span class="line">    vec3 normal = normalize( finalNormal );</span><br><span class="line">    vec3 viewPosition = normalize( vViewPosition );</span><br><span class="line"></span><br><span class="line">    // point lights</span><br><span class="line">#if MAX_POINT_LIGHTS &gt; 0</span><br><span class="line">    vec3 pointDiffuse = vec3( 0.0 );</span><br><span class="line">    vec3 pointSpecular = vec3( 0.0 );</span><br><span class="line">    for ( int i = 0; i &lt; MAX_POINT_LIGHTS; i ++ ) &#123;</span><br><span class="line">        vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );</span><br><span class="line">#ifdef GL_FRAGMENT_PRECISION_HIGH</span><br><span class="line">        // should be highp for correct behaviour if mediump is implemented as fp16</span><br><span class="line">        highp vec3 lVector = lPosition.xyz + vViewPosition.xyz;</span><br><span class="line">#else</span><br><span class="line">        vec3 lVector = lPosition.xyz + vViewPosition.xyz;</span><br><span class="line">#endif</span><br><span class="line">        float lDistance = 1.0;</span><br><span class="line">        if ( pointLightDistance[ i ] &gt; 0.0 )</span><br><span class="line">            lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );</span><br><span class="line">        lVector = normalize( lVector );</span><br><span class="line">        vec3 pointHalfVector = normalize( lVector + viewPosition );</span><br><span class="line">        float pointDistance = lDistance;</span><br><span class="line">        float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );</span><br><span class="line">        float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );</span><br><span class="line">        float pointSpecularWeight = specularTex.r * pow( pointDotNormalHalf, uShininess );</span><br><span class="line">        pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;</span><br><span class="line">        pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // all lights contribution summation</span><br><span class="line">    vec3 totalDiffuse = vec3( 0.0 );</span><br><span class="line">    vec3 totalSpecular = vec3( 0.0 );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if MAX_POINT_LIGHTS &gt; 0</span><br><span class="line">    totalDiffuse += pointDiffuse;</span><br><span class="line">    totalSpecular += pointSpecular;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );</span><br><span class="line"></span><br><span class="line">    //CHUNK: fog_fragment</span><br><span class="line">#ifdef USE_FOG</span><br><span class="line">    float depth = gl_FragCoord.z / gl_FragCoord.w;</span><br><span class="line">#ifdef FOG_EXP2</span><br><span class="line">    const float LOG2 = 1.442695;</span><br><span class="line">    float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );</span><br><span class="line">    fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );</span><br><span class="line">#else</span><br><span class="line">    float fogFactor = smoothstep( fogNear, fogFar, depth );</span><br><span class="line">#endif</span><br><span class="line">    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepX = 0.001250;</span><br><span class="line">const float TiltShift = 0.000000;</span><br><span class="line">const float Kernel2 = 0.187627;</span><br><span class="line">const float Kernel1 = 0.206068;</span><br><span class="line">const float Kernel0 = 0.212609;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line">    vec2 TextureCoord = vUv;</span><br><span class="line"></span><br><span class="line">    float stepX = TextureStepX * abs(TiltShift - TextureCoord.y) / abs(1.0 - TiltShift);</span><br><span class="line">result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-2.0 * stepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * stepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * stepX, 0.0)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * stepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(2.0 * stepX, 0.0)) * Kernel2 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepY = 0.003906;</span><br><span class="line">const float TiltShift = 0.000000;</span><br><span class="line">const float Kernel2 = 0.187627;</span><br><span class="line">const float Kernel1 = 0.206068;</span><br><span class="line">const float Kernel0 = 0.212609;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line">    vec2 TextureCoord = vUv;</span><br><span class="line"></span><br><span class="line">    float stepY = TextureStepY * abs(TiltShift - TextureCoord.y) / abs(1.0 - TiltShift);</span><br><span class="line">result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -2.0 * stepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -1.0 * stepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 0.0 * stepY)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 1.0 * stepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 2.0 * stepY)) * Kernel2 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">uniform float opacity;</span><br><span class="line">uniform sampler2D tDiffuse;</span><br><span class="line"></span><br><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vec4 texel = texture2D(tDiffuse, vUv);</span><br><span class="line">    gl_FragColor = opacity * texel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepX = 0.001250;</span><br><span class="line">const float TiltShift = 0.500000;</span><br><span class="line">const float Kernel4 = 0.054409;</span><br><span class="line">const float Kernel3 = 0.087939;</span><br><span class="line">const float Kernel2 = 0.123913;</span><br><span class="line">const float Kernel1 = 0.152223;</span><br><span class="line">const float Kernel0 = 0.163030;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line">    vec2 TextureCoord = vUv;</span><br><span class="line"></span><br><span class="line">    float stepX = TextureStepX * abs(TiltShift - TextureCoord.y) / abs(1.0 - TiltShift);</span><br><span class="line">result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-4.0 * stepX, 0.0)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-3.0 * stepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-2.0 * stepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(-1.0 * stepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0 * stepX, 0.0)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(1.0 * stepX, 0.0)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(2.0 * stepX, 0.0)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(3.0 * stepX, 0.0)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(4.0 * stepX, 0.0)) * Kernel4 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float TextureStepY = 0.001667;</span><br><span class="line">const float TiltShift = 0.500000;</span><br><span class="line">const float Kernel4 = 0.054409;</span><br><span class="line">const float Kernel3 = 0.087939;</span><br><span class="line">const float Kernel2 = 0.123913;</span><br><span class="line">const float Kernel1 = 0.152223;</span><br><span class="line">const float Kernel0 = 0.163030;</span><br><span class="line">uniform sampler2D Texture0;</span><br><span class="line"></span><br><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 result;</span><br><span class="line">    vec2 TextureCoord = vUv;</span><br><span class="line"></span><br><span class="line">    float stepY = TextureStepY * abs(TiltShift - TextureCoord.y) / abs(1.0 - TiltShift);</span><br><span class="line">result = </span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -4.0 * stepY)) * Kernel4 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -3.0 * stepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -2.0 * stepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, -1.0 * stepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 0.0 * stepY)) * Kernel0 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 1.0 * stepY)) * Kernel1 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 2.0 * stepY)) * Kernel2 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 3.0 * stepY)) * Kernel3 +</span><br><span class="line">texture2D(Texture0, TextureCoord + vec2(0.0, 4.0 * stepY)) * Kernel4 +</span><br><span class="line">0.0 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(result.xyz, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jellyfish"><a class="markdownIt-Anchor" href="#jellyfish"></a> jellyfish</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">#ifdef GL_ES</span><br><span class="line">precision highp float;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">uniform sampler2D uSampler;</span><br><span class="line">uniform sampler2D uSampler1;</span><br><span class="line">uniform float uCurrentTime;</span><br><span class="line"> </span><br><span class="line">varying vec2 vTextureCoord;</span><br><span class="line">varying vec4 vWorld;</span><br><span class="line">varying vec3 vDiffuse;</span><br><span class="line">varying vec3 vAmbient;</span><br><span class="line">varying vec3 vFresnel;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    vec4 caustics = texture2D(uSampler1, vec2(vWorld.x / 24.0 + uCurrentTime / 20.0, (vWorld.z - vWorld.y)/48.0 + uCurrentTime / 40.0));</span><br><span class="line">    vec4 colorMap = texture2D(uSampler, vTextureCoord);</span><br><span class="line">    float transparency = colorMap.a + pow(vFresnel.r, 2.0) - 0.3;</span><br><span class="line">    gl_FragColor = vec4(((vAmbient + vDiffuse + caustics.rgb) * colorMap.rgb), transparency);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> loop</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">varying vec4 dummy;</span><br><span class="line">uniform int FragmentLoops;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef GL_FRAGMENT_PRECISION_HIGH</span><br><span class="line">    // should be declared highp since the multiplication can overflow in</span><br><span class="line">    // mediump, particularly if mediump is implemented as fp16</span><br><span class="line">    highp vec2 FragCoord = gl_FragCoord.xy;</span><br><span class="line">#else</span><br><span class="line">    vec2 FragCoord = gl_FragCoord.xy;</span><br><span class="line">#endif</span><br><span class="line">    float d = fract(FragCoord.x * FragCoord.y * 0.0001);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; FragmentLoops; i++)</span><br><span class="line">        d = fract(3.0 * d);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(d, d, d, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="refract"><a class="markdownIt-Anchor" href="#refract"></a> refract</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">const float RefractiveIndex = 1.200000;</span><br><span class="line">const vec4 LightSourcePosition = vec4(1.000000, 1.000000, 2.000000, 1.000000);</span><br><span class="line">const vec4 LightColor = vec4(0.400000, 0.400000, 0.400000, 1.000000);</span><br><span class="line">uniform sampler2D DistanceMap;</span><br><span class="line">uniform sampler2D NormalMap;</span><br><span class="line">uniform sampler2D ImageMap;</span><br><span class="line"></span><br><span class="line">varying vec3 vertex_normal;</span><br><span class="line">varying vec4 vertex_position;</span><br><span class="line">varying vec4 MapCoord;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    const vec4 lightSpecular = vec4(0.8, 0.8, 0.8, 1.0);</span><br><span class="line">    const vec4 matSpecular = vec4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    const float matShininess = 100.0;</span><br><span class="line">    const vec2 point_five = vec2(0.5);</span><br><span class="line">    // Need the normalized eye direction and surface normal vectors to</span><br><span class="line">    // compute the transmitted vector through the &quot;front&quot; surface of the object.</span><br><span class="line">    vec3 eye_direction = normalize(-vertex_position.xyz);</span><br><span class="line">    vec3 normalized_normal = normalize(vertex_normal);</span><br><span class="line">    vec3 front_refraction = refract(eye_direction, normalized_normal, RefractiveIndex);</span><br><span class="line">    // Find our best distance approximation through the object so we can</span><br><span class="line">    // project the transmitted vector to the back of the object to find</span><br><span class="line">    // the exit point.</span><br><span class="line">    vec3 mc_perspective = (MapCoord.xyz / MapCoord.w) + front_refraction;</span><br><span class="line">    vec2 dcoord = mc_perspective.st * point_five + point_five;</span><br><span class="line">    vec4 distance_value = texture2D(DistanceMap, dcoord);</span><br><span class="line">    vec3 back_position = vertex_position.xyz + front_refraction * distance_value.x;</span><br><span class="line">    // Use the exit point to index the map of back-side normals, and use the</span><br><span class="line">    // back-side position and normal to find the transmitted vector out of the</span><br><span class="line">    // object.</span><br><span class="line">    vec2 normcoord = back_position.st * point_five + point_five;</span><br><span class="line">    vec3 back_normal = texture2D(NormalMap, normcoord).xyz;</span><br><span class="line">    vec3 back_refraction = refract(back_position, back_normal, 1.0/RefractiveIndex);</span><br><span class="line">    // Use the transmitted vector from the exit point to determine where</span><br><span class="line">    // the vector would intersect the environment (in this case a background</span><br><span class="line">    // image.</span><br><span class="line">    vec2 imagecoord = back_refraction.st * point_five + point_five;</span><br><span class="line">    vec4 texel = texture2D(ImageMap, imagecoord);</span><br><span class="line">    // Add in specular reflection, and we have our fragment value.</span><br><span class="line">    vec3 light_direction = normalize(vertex_position.xyz/vertex_position.w -</span><br><span class="line">                                     LightSourcePosition.xyz/LightSourcePosition.w);</span><br><span class="line">    vec3 reflection = reflect(light_direction, normalized_normal);</span><br><span class="line">    float specularTerm = pow(max(0.0, dot(reflection, eye_direction)), matShininess);</span><br><span class="line">    vec4 specular = (lightSpecular * matSpecular);</span><br><span class="line">    gl_FragColor = (specular * specularTerm) + texel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shadow"><a class="markdownIt-Anchor" href="#shadow"></a> shadow</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">uniform sampler2D ShadowMap;</span><br><span class="line"></span><br><span class="line">varying vec4 Color;</span><br><span class="line">varying vec4 ShadowCoord;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vec4 sc_perspective = ShadowCoord / ShadowCoord.w;</span><br><span class="line">    sc_perspective.z += 0.1505;</span><br><span class="line">    vec4 shadow_value = texture2D(ShadowMap, sc_perspective.st);</span><br><span class="line">    float light_distance = shadow_value.x;</span><br><span class="line">    float shadow = 1.0;</span><br><span class="line">    if (ShadowCoord.w &gt; 0.0 &amp;&amp; light_distance &lt; sc_perspective.z) &#123;</span><br><span class="line">        shadow = 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">    gl_FragColor = vec4(shadow * Color.rgb, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="function"><a class="markdownIt-Anchor" href="#function"></a> function</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">varying vec4 dummy;</span><br><span class="line"></span><br><span class="line">float process(float d)</span><br><span class="line">&#123;</span><br><span class="line">    d = fract(3.0 * d);</span><br><span class="line"></span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef GL_FRAGMENT_PRECISION_HIGH</span><br><span class="line">    // should be declared highp since the multiplication can overflow in</span><br><span class="line">    // mediump, particularly if mediump is implemented as fp16</span><br><span class="line">    highp vec2 FragCoord = gl_FragCoord.xy;</span><br><span class="line">#else</span><br><span class="line">    vec2 FragCoord = gl_FragCoord.xy;</span><br><span class="line">#endif</span><br><span class="line">    float d = fract(FragCoord.x * FragCoord.y * 0.0001);</span><br><span class="line"></span><br><span class="line">    d = process(d);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(d, d, d, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="conditionals"><a class="markdownIt-Anchor" href="#conditionals"></a> conditionals</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef GL_ES</span><br><span class="line">precision mediump float;</span><br><span class="line">#endif</span><br><span class="line">varying vec4 dummy;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef GL_FRAGMENT_PRECISION_HIGH</span><br><span class="line">    // should be declared highp since the multiplication can overflow in</span><br><span class="line">    // mediump, particularly if mediump is implemented as fp16</span><br><span class="line">    highp vec2 FragCoord = gl_FragCoord.xy;</span><br><span class="line">#else</span><br><span class="line">    vec2 FragCoord = gl_FragCoord.xy;</span><br><span class="line">#endif</span><br><span class="line">    float d = fract(FragCoord.x * FragCoord.y * 0.0001);</span><br><span class="line"></span><br><span class="line">    if (d &gt;= 0.5)</span><br><span class="line">        d = fract(2.0 * d);</span><br><span class="line">    else</span><br><span class="line">        d = fract(3.0 * d);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gl_FragColor = vec4(d, d, d, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面这些场景的Fragment Shader来看，<strong>desktop</strong>和<strong>clear</strong>这两个场景比较特殊，clear没有shader, 而<strong>desktop</strong>有8个fragment shaders，而且每个fragment shader里都调用了多次<code>texture2D</code>这个纹理查询GLSL内置函数。</p>
<ul>
<li>
<p>为什么有8个fragment shader?</p>
<p>SceneDesktop这个场景除了主窗口外，默认还有4个小窗口，而这4个小窗口有两种特效: <strong>blur</strong>, <strong>shadow</strong>. blur效果是通过卷积实现的模糊效果，而且可以水平和垂直方向分开模糊，由选项<code>separable</code>控制，默认是<code>true</code>(水平和垂直各一个fragment shader).</p>
</li>
<li>
<p>为什么每个fragment shader里有那么多<code>texture2D</code>?</p>
</li>
</ul>
<h2 id="scenedesktop-test"><a class="markdownIt-Anchor" href="#scenedesktop-test"></a> SceneDesktop Test</h2>
<figure class="highlight plaintext"><figcaption><span>glmark2 --list | awk '/[Scene] desktop/, /[Scene] effect2d/ &#123; print &#125;'</span></figcaption><table><tr><td class="code"><pre><span class="line">[Scene] desktop</span><br><span class="line">  [Option] blur-radius</span><br><span class="line">    Description  : the blur effect radius (in pixels)</span><br><span class="line">    Default Value: 5</span><br><span class="line">  [Option] duration</span><br><span class="line">    Description  : The duration of each benchmark in seconds</span><br><span class="line">    Default Value: 10.0</span><br><span class="line">  [Option] effect</span><br><span class="line">    Description  : The effect to use</span><br><span class="line">    Default Value: blur</span><br><span class="line">    Acceptable Values: blur,shadow</span><br><span class="line">  [Option] fps-pos</span><br><span class="line">    Description  : The position on screen where to show FPS</span><br><span class="line">    Default Value: -1.0,-1.0</span><br><span class="line">  [Option] fps-size</span><br><span class="line">    Description  : The width of each glyph for the FPS</span><br><span class="line">    Default Value: 0.03</span><br><span class="line">  [Option] fragment-precision</span><br><span class="line">    Description  : The precision values for the fragment shader (&quot;int,float,sampler2d,samplercube&quot;)</span><br><span class="line">    Default Value: default,default,default,default</span><br><span class="line">  [Option] nframes</span><br><span class="line">    Description  : The number of frames to render</span><br><span class="line">    Default Value: </span><br><span class="line">  [Option] passes</span><br><span class="line">    Description  : the number of effect passes (effect dependent)</span><br><span class="line">    Default Value: 1</span><br><span class="line">  [Option] separable</span><br><span class="line">    Description  : use separable convolution for the blur effect</span><br><span class="line">    Default Value: true</span><br><span class="line">    Acceptable Values: false,true</span><br><span class="line">  [Option] shadow-size</span><br><span class="line">    Description  : the size of the shadow (in pixels)</span><br><span class="line">    Default Value: 20</span><br><span class="line">  [Option] show-fps</span><br><span class="line">    Description  : Show live FPS counter</span><br><span class="line">    Default Value: false</span><br><span class="line">    Acceptable Values: false,true</span><br><span class="line">  [Option] title</span><br><span class="line">    Description  : The scene title to show</span><br><span class="line">    Default Value: </span><br><span class="line">  [Option] title-pos</span><br><span class="line">    Description  : The position on screen where to show the title</span><br><span class="line">    Default Value: -0.7,-1.0</span><br><span class="line">  [Option] title-size</span><br><span class="line">    Description  : The width of each glyph in the title</span><br><span class="line">    Default Value: 0.03</span><br><span class="line">  [Option] vertex-precision</span><br><span class="line">    Description  : The precision values for the vertex shader (&quot;int,float,sampler2d,samplercube&quot;)</span><br><span class="line">    Default Value: default,default,default,default</span><br><span class="line">  [Option] window-size</span><br><span class="line">    Description  : the window size as a percentage of the minimum screen dimension [0.0 - 0.5]</span><br><span class="line">    Default Value: 0.35</span><br><span class="line">  [Option] windows</span><br><span class="line">    Description  : the number of windows</span><br><span class="line">    Default Value: 4</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Shading Languages</title>
    <url>/gfx/glsl/</url>
    <content><![CDATA[<p>GLSL 是一种高级着色语言，语法接近 C 语言。它由 OpenGL ARB 创建，旨在让开发者能够更直接地控制图形管线，而无需使用 ARB 汇编语言或特定硬件语言。</p>
<p>实际上 GLSL 包括大概 6 种着色语言:</p>
<ul>
<li>顶点着色语言 (.vert)</li>
<li>细分控制语言 (.tesc)</li>
<li>细分评估语言 (.tese)</li>
<li>几何着色语言 (.geom)</li>
<li>片段着色语言 (.frag)</li>
<li>计算着色语言 (.comp)</li>
</ul>
<span id="more"></span>
<h1 id="glslangvalidator"><a class="markdownIt-Anchor" href="#glslangvalidator"></a> <a href="https://github.com/KhronosGroup/glslang">glslangValidator</a></h1>
<p>glslangValidator 是一个 GLSL/ESSL 的编译前端，同时也是一个 SPIR-V 的生成器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/glslangValidator \</span><br><span class="line">  -V /home/luc/gh/VulkanExamples/data/shaders/deferredmultisampling/debug.frag \</span><br><span class="line">  -o /home/luc/gh/VulkanExamples/data/shaders/deferredmultisampling/debug.frag.debug.spv</span><br></pre></td></tr></table></figure>
<h1 id="顶点着色语言"><a class="markdownIt-Anchor" href="#顶点着色语言"></a> 顶点着色语言</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout (location = 0) out vec3 outUV;</span><br><span class="line"></span><br><span class="line">outUV = vec3((gl_VertexIndex &lt;&lt; 1) &amp; 2, gl_VertexIndex &amp; 2, 0.0);</span><br><span class="line">gl_Position = vec4(outUV.st * 2.0f - 1.0f, 0.0f, 1.0f);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gl_VertexIndex</code> 和 <code>gl_Position</code> 都是顶点着色语言内置变量(无需用户声明)</li>
<li><code>out vec3 outUV</code> 说明 <code>outUV</code> 会从本阶段输出到下一个着色阶段</li>
<li><code>layout (location = 0)</code> 为这个输出变量指定一个位置(或槽位), 这样即使在与下一阶段着色器的输入变量名字不同，但只要它也声明同样的 location, 那么变量就可以准确传入下一阶段的着色器</li>
</ul>
<p>这段着色器代码巧妙地利用 <code>gl_VertexIndex</code> 生成了顶点的 position 属性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">gl_VertexIndex</th>
<th style="text-align:left">outUV</th>
<th style="text-align:left">gl_Position</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">(0, 0, 0)</td>
<td style="text-align:left">(-1, -1, 0, 1)</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">(2, 0, 0)</td>
<td style="text-align:left">( 3, -1, 0, 1)</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">(0, 2, 0)</td>
<td style="text-align:left">(-1,  3, 0, 1)</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">(2, 2, 0)</td>
<td style="text-align:left">( 3,  3, 0, 1)</td>
</tr>
</tbody>
</table>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<h2 id="texelfetch"><a class="markdownIt-Anchor" href="#texelfetch"></a> texelFetch</h2>
<ul>
<li><code>vec4 texelFetch(sampler2D sampler, ivec2 P, int lod);</code></li>
</ul>
<p>与普通的 <code>texture</code> 函数不同，<code>texelFetch</code> 使用的是未归一化的坐标直接访问纹理中的纹素，有点 <code>gl_FragCoord</code> 的意思</p>
<h2 id="texturesize"><a class="markdownIt-Anchor" href="#texturesize"></a> textureSize</h2>
<ul>
<li><code>ivec2 textureSize(sampler2D sampler, int lod);</code></li>
</ul>
<p>获取纹理的尺寸，常用来将归一化的纹理坐标转换为像素坐标</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>GLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Graphics Overview</title>
    <url>/gfx/hal/</url>
    <content><![CDATA[<p><img src="/images/hal/android-graphics.png" alt="Android Graphics" /></p>
<span id="more"></span>
<h1 id="android-stack"><a class="markdownIt-Anchor" href="#android-stack"></a> <a href="https://source.android.com/docs/core/architecture?hl=zh-cn">Android Stack</a></h1>
<p><img src="/images/hal/android-stack.svg" alt="Android Stack" /></p>
<h1 id="android-graphics-stack"><a class="markdownIt-Anchor" href="#android-graphics-stack"></a> Android Graphics Stack</h1>
<pre><code class="highlight mermaid">block-beta
  columns 3
  block:group1:3
    %% columns auto (default)   
    A[&quot;WindowManager&quot;]
    B[&quot;SurfaceFlinger&quot;]
    C[&quot;...&quot;]
  end
  block:group2:3
    a[&quot;Gralloc&quot;]
    b[&quot;HWComposer&quot;]
    c[&quot;...&quot;]
  end
  block:group3:3
    a1[&quot;GPU&quot;]
    b1[&quot;DC&quot;]
    c1[&quot;...&quot;]
  end
  %% **蓝
  style group1 fill:#55AEF7
  %% **橙
  style group2 fill:#F87529
  %% **绿
  style group3 fill:#25A768</code></pre>
<h1 id="surfaceflinger-flɪngər抛投器"><a class="markdownIt-Anchor" href="#surfaceflinger-flɪngər抛投器"></a> SurfaceFlinger (<code>/f'lɪngər/</code>:抛投器)</h1>
<h1 id="hal"><a class="markdownIt-Anchor" href="#hal"></a> <a href="https://android.googlesource.com/platform/hardware/libhardware/">HAL</a></h1>
<h2 id="gralloc"><a class="markdownIt-Anchor" href="#gralloc"></a> <a href="https://android.googlesource.com/platform/hardware/libhardware/+/refs/heads/main/modules/gralloc/">Gralloc</a></h2>
<h2 id="硬件合成器"><a class="markdownIt-Anchor" href="#硬件合成器"></a> 硬件合成器</h2>
<p><strong>硬件合成器</strong>是 Android 系统中负责屏幕显示的硬件抽象层 (HAL) 组件之一。它负责将图形渲染的内容(比如应用程序界面，视频等)合成到帧缓冲里，以便高效地利用 DPU 硬件加速 <strong>overlay</strong> 合成，减少 GPU 合成的负担，从而整体上提供更流畅的图形渲染显示。</p>
<p>hwcomposer 组件通常是由各个设备厂商根据自己的硬件特性实现的，有开源的，也有闭源的。在 AOSP 中有一个通用的基础的 <strong>hwcomposer</strong> 实现，主要用于那些不需要特别硬件加速或优化的设备，类似 xserver 中的 <strong>modesetting</strong>.</p>
<pre><code class="highlight mermaid">mindmap
  root(HAL hwcomposer)
    libhardware/hwcomposer demo
    drm-hwcomposer
      Arm drm-hwcomposer
    Qualcomm hwcomposer
    Samsung hwcomposer
    Huawei hwcomposer</code></pre>
<h2 id="hwcomposer"><a class="markdownIt-Anchor" href="#hwcomposer"></a> <a href="https://android.googlesource.com/platform/hardware/libhardware/+/refs/heads/main/modules/hwcomposer/">HWComposer</a></h2>
<p>尽量让 GPU 少做合成的工作，让 DPU (Display Processor Unit) 多做合成的工作，因为合成涉及的操作主要有</p>
<ul>
<li>格式转换</li>
<li>旋转缩放</li>
<li>像素拷贝</li>
</ul>
<p>如果这些都占用 GPU 去做，太浪费 GPU 了。</p>
<p><img src="/images/hal/composition-with-hwcomposer.png" alt="composition-with-hwcomposer" /></p>
<h3 id="drm-hwcomposer"><a class="markdownIt-Anchor" href="#drm-hwcomposer"></a> <a href="https://gitlab.freedesktop.org/drm-hwcomposer/drm-hwcomposer">drm-hwcomposer</a></h3>
<p>一个基于 KMS 的 HWComposer 实现。</p>
<h3 id="arm-drm-hwcomposer"><a class="markdownIt-Anchor" href="#arm-drm-hwcomposer"></a> <a href="https://github.com/ARM-software/drm-hwcomposer">ARM drm-hwcomposer</a></h3>
<p>给 Mali DP 量身定制的 drm-hwcomposer.</p>
<h1 id="android-sync-framework"><a class="markdownIt-Anchor" href="#android-sync-framework"></a> Android Sync Framework</h1>
<p>Android Sync Framework 实现的是<strong>显式同步 (Explicit Synchronization)</strong>, 所谓显式同步，指的是用户态可见，与隐式同步 (Implicit Synchronization) 相对，隐式同步用户态应用程序是不感知的。虽然隐式同步完全由<strong>驱动和内核控制</strong>，无需应用程序干预(这对应用开发者来说可能更简单些，但有时简单的方案可能不是最高效的)，但<a href="https://www.collabora.com/news-and-blog/blog/2022/06/09/bridging-the-synchronization-gap-on-linux/">显式同步比隐式同步更能发挥硬件的并行性</a>，这应该也是 Android 实现的是显式同步的主要原因。</p>
<ul>
<li>sync_timeline
<ul>
<li>control ordering</li>
</ul>
</li>
<li>sync_pt (point)
<ul>
<li>represent a fence</li>
</ul>
</li>
<li>sync_fence (like sync file in Linux kernel)
<ul>
<li>for fd passing across userspace processes like <code>SurfaceFlinger</code> and 3D applications</li>
</ul>
</li>
</ul>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://blog.csdn.net/liuning1985622/article/details/138453346?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-138453346-blog-45080305.235%5Ev43%5Epc_blog_bottom_relevance_base6&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=6">Android Graphics</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/261169653">自上而下解读 Android 显示流程</a></li>
<li><a href="https://source.android.com/docs/core/graphics/implement-hwc?hl=zh-cn">Android 文档：实现硬件混合渲染器 HAL</a></li>
<li><a href="https://community.nxp.com/t5/i-MX-Processors-Knowledge-Base/Android-Graphic-UI-with-GPU-Hardware-Acceleration/ta-p/1102023">Android Graphic UI with GPU Hardware Acceleration</a></li>
<li><a href="https://blog.csdn.net/stray2b/article/details/130291840">Android drm-hwcomposer</a></li>
<li><a href="https://android.googlesource.com/device/linaro/dragonboard/+/refs/heads/main/shared/graphics/drm_hwcomposer/device.mk">DragonBoards using drm_hwcomposer</a></li>
<li><a href="https://blog.csdn.net/MoLiYw/article/details/118829051">Fence</a></li>
<li><a href="https://blog.linuxplumbersconf.org/2014/ocw/system/presentations/2355/original/03%20-%20sync%20&amp;%20dma-fence.pdf">Android Sync</a></li>
<li><a href="https://www.collabora.com/news-and-blog/blog/2016/09/13/mainline-explicit-fencing-part-1/">Mainline Explicit Fencing</a></li>
<li><a href="https://zamundaaa.github.io/wayland/2024/04/05/explicit-sync.html">Explicit Sync</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Image Format in OpenGL</title>
    <url>/gfx/image-format/</url>
    <content><![CDATA[<h1 id="color-format"><a class="markdownIt-Anchor" href="#color-format"></a> Color Format</h1>
<span id="more"></span>
<h1 id="depth-format"><a class="markdownIt-Anchor" href="#depth-format"></a> Depth Format</h1>
<h2 id="normalized-integer"><a class="markdownIt-Anchor" href="#normalized-integer"></a> Normalized Integer</h2>
<p>事实上，这里的Normalized Integer是<code>Unsigned Normalized Integer</code>, 意思是对于一个n-bit数，所有位是0表示0.0f, 所有位是1表示1.0f, 将所有整数的二进制表示平均映射到<code>[0, 1]</code>的深度值区间。例如，2-bit的UNORM Integer数有下面的映射关系:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Integer Bits</th>
<th style="text-align:left">Depth Values</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">00</td>
<td style="text-align:left">0.0f</td>
</tr>
<tr>
<td style="text-align:left">01</td>
<td style="text-align:left">1/3</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">2/3</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">1.0f</td>
</tr>
</tbody>
</table>
<ul>
<li><code>GL_DEPTH_COMPONENT16</code></li>
<li><code>GL_DEPTH_COMPONENT24</code></li>
<li><code>GL_DEPTH_COMPONENT32</code></li>
</ul>
<h2 id="floating-point"><a class="markdownIt-Anchor" href="#floating-point"></a> Floating-point</h2>
<ul>
<li><code>GL_DEPTH_COMPONENT32F</code></li>
</ul>
<h1 id="depth-stencil-format"><a class="markdownIt-Anchor" href="#depth-stencil-format"></a> Depth-Stencil Format</h1>
<h1 id="depth-depth-stencil-format-image-与-shadow-samplers"><a class="markdownIt-Anchor" href="#depth-depth-stencil-format-image-与-shadow-samplers"></a> Depth &amp; Depth-Stencil Format Image 与 Shadow Samplers</h1>
<p>Shadow Samplers</p>
<table>
<thead>
<tr>
<th style="text-align:left">GLSL sampler</th>
<th style="text-align:left">OpenGL texture target</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sampler1DShadow</td>
<td style="text-align:left">GL_TEXTURE_1D</td>
</tr>
<tr>
<td style="text-align:left">sampler2DShadow</td>
<td style="text-align:left">GL_TEXTURE_2D</td>
</tr>
<tr>
<td style="text-align:left">samplerCubeShadow</td>
<td style="text-align:left">GL_TEXTURE_CUBE_MAP</td>
</tr>
<tr>
<td style="text-align:left">sampler2DRectShadow</td>
<td style="text-align:left">GL_TEXTURE_RECTANGLE</td>
</tr>
<tr>
<td style="text-align:left">sampler1DArrayShadow</td>
<td style="text-align:left">GL_TEXTURE_1D_ARRAY</td>
</tr>
<tr>
<td style="text-align:left">sampler2DArrayShadow</td>
<td style="text-align:left">GL_TEXTURE_2D_ARRAY</td>
</tr>
<tr>
<td style="text-align:left">samplerCubeArrayShadow</td>
<td style="text-align:left">GL_TEXTURE_CUBE_MAP_ARRAY</td>
</tr>
</tbody>
</table>
<p>当一个纹理格式是Depth或Depth-Stencil格式时，它就不能再使用通常的采样器(Sampler), 而必须使用Shadow Sampler. 这种类型的Sampler Texture Lookup函数被重载成比通常的纹理坐标多一个component. 而且返回值永远是一个float标量值, 而且这个返回值的范围永远在[0, 1]之间，当纹理坐标的最后一个component(比通常多出的那个)与采样值比较通过时，返回值为1，如果比较失败，返回值为0，当有多个采样点时，分别进行比较，结果为比较通过占总采样点个数的比例，例如，如果是4个采样值，只有一个比较通过，则返回值是0.25.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">texture</span><span class="params">(sampler1DShadow sampler, vec3 P[, <span class="type">float</span> bias])</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">texture</span><span class="params">(sampler2DShadow sampler, vec3 P[, <span class="type">float</span> bias])</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">texture</span><span class="params">(samplerCubeShadow sampler, vec4 P[, <span class="type">float</span> bias])</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">texture</span><span class="params">(sampler1DArrayShadow sampler, vec3 P[, <span class="type">float</span> bias])</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">texture</span><span class="params">(sampler2DArrayShadow sampler, vec4 P)</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">texture</span><span class="params">(sampler2DRectShadow sampler, vec3 P)</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">texture</span><span class="params">(samplerCubeArrayShadow sampler, vec4 P, <span class="type">float</span> compare)</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>sampler1DShadow的纹理坐标的第2个component不使用, 第3个component作为reference value</li>
<li>samplerCubeArray的Texture Lookup函数的纹理坐标本身就是一个4维的，所以samplerCubeArrayShadow的重载新加了一个单独的float类型参数<code>compare</code>作为reference value，避免使用5维向量。</li>
<li>所有的shadow sampler类型都只有一种float类型，没有i(integer), u(unsigned integer)类型，因为shadow sampler总是返回单个的float值。</li>
</ol>
<p>具体如何比较由Texture Parameter <code>GL_TEXTURE_COMPARE_FUNC</code>决定：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Texture Comparison Function</th>
<th style="text-align:left">Result 1.0</th>
<th style="text-align:left">Result 0.0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_LEQUAL</td>
<td style="text-align:left">r &lt;= Dt</td>
<td style="text-align:left">r &gt; Dt</td>
</tr>
<tr>
<td style="text-align:left">GL_GEQUAL</td>
<td style="text-align:left">r &gt;= Dt</td>
<td style="text-align:left">r &lt; Dt</td>
</tr>
<tr>
<td style="text-align:left">GL_LESS</td>
<td style="text-align:left">r &lt;  Dt</td>
<td style="text-align:left">r &gt;= Dt</td>
</tr>
<tr>
<td style="text-align:left">GL_GREATER</td>
<td style="text-align:left">r &gt;  Dt</td>
<td style="text-align:left">r &lt;= Dt</td>
</tr>
<tr>
<td style="text-align:left">GL_EQUAL</td>
<td style="text-align:left">r == Dt</td>
<td style="text-align:left">r != Dt</td>
</tr>
<tr>
<td style="text-align:left">GL_NOTEQUAL</td>
<td style="text-align:left">r != Dt</td>
<td style="text-align:left">r == Dt</td>
</tr>
<tr>
<td style="text-align:left">GL_ALWAYS</td>
<td style="text-align:left">Always</td>
<td style="text-align:left">Never</td>
</tr>
<tr>
<td style="text-align:left">GL_NEVER</td>
<td style="text-align:left">Never</td>
<td style="text-align:left">Always</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Knowledge from &quot;[RFC] Plane color pipeline KMS uAPI&quot;</title>
    <url>/gfx/kms/</url>
    <content><![CDATA[<h1 id="gamma-lut-property"><a class="markdownIt-Anchor" href="#gamma-lut-property"></a> Gamma LUT property</h1>
<p>Gamma LUT (Look-Up Table) is a property that is used to correct the color and brightness of an image or video. Gamma LUT is basically a table of values that is used to map input values to output values, for example, it may map low input values to higher output values to brighten the image.</p>
<p>Gamma LUT is used to adjust the gamma curve of an image or video, which means it can be used to correct the brightness and contrast of an image. This property is commonly used in image and video processing applications, such as photo editing software, video editing software, and color grading tools.</p>
<p>Gamma LUT can also be used to correct color shifts caused by different lighting conditions or camera settings. By adjusting the gamma curve of an image or video, it is possible to create a more natural and accurate representation of the original scene.</p>
<span id="more"></span>
<h1 id="csc-property"><a class="markdownIt-Anchor" href="#csc-property"></a> CSC property</h1>
<p>CSC is an acronym for <strong>Color Space Conversion</strong>, which is a property used in digital image and video processing. CSC is used to convert the color space of an image or video from one format to another.</p>
<p>Color spaces are a way to represent colors using numerical values. Different devices and software applications use different color spaces, which can cause issues when trying to display or process images or videos across different platforms. For example, an image captured by a camera may use one color space, while a monitor may use another color space.</p>
<p>CSC property can be used to convert the color space of an image or video from one format to another. This can be useful for ensuring that images or videos are displayed correctly on different devices or platforms. For example, a video may need to be converted from the color space used by a camera to the color space used by a television or monitor.</p>
<p>CSC can also be used for color correction, where the colors of an image or video are adjusted to make them more accurate or aesthetically pleasing. Overall, the CSC property is an important tool in digital image and video processing, allowing for the correct and accurate representation of colors across different platforms.</p>
<h1 id="scrgb"><a class="markdownIt-Anchor" href="#scrgb"></a> scRGB</h1>
<p>scRGB (standardized RGB) is a color space that defines an alternative method for representing colors in digital images or videos. It is a wide-gamut (广色域) color space that can represent a larger range of colors than the traditional sRGB color space used in most computer displays.</p>
<p>scRGB was developed by Microsoft and is defined by the International Electrotechnical Commission (IEC) standard IEC 61966-2-2. It is designed to be a device-independent color space, meaning that it can be used to represent colors accurately on a wide range of devices, including computer monitors, printers, and projectors.</p>
<p>The scRGB color space is based on a linear color system, which means that the difference between two colors is proportional to the difference in their numerical values. This makes it easier to perform accurate color calculations and color corrections in digital image and video processing.</p>
<p>scRGB is commonly used in professional video and film production, as well as in high-end graphics applications. It is also used as a reference color space for other color spaces, such as Adobe RGB and DCI-P3.</p>
<h2 id="whats-the-difference-between-srgb-and-scrgb"><a class="markdownIt-Anchor" href="#whats-the-difference-between-srgb-and-scrgb"></a> what’s the difference between sRGB and scRGB</h2>
<p>The main difference between scRGB and sRGB is the range of colors that they can represent. scRGB is a wide-gamut color space that can represent a larger range of colors than sRGB. sRGB is a standard color space that is commonly used in computer displays, but it has a smaller gamut than scRGB.</p>
<p>sRGB defines a color space that can represent approximately 16.8 million colors, while scRGB can represent over a billion colors. This means that scRGB can represent a wider range of colors than sRGB, including more vibrant and saturated colors. However, not all devices or applications can display or process scRGB colors correctly, so it is not always practical to use scRGB in all situations.</p>
<p>Another difference between scRGB and sRGB is their color encoding. scRGB uses a linear color encoding, which means that the difference between two colors is proportional to the difference in their numerical values. sRGB, on the other hand, uses a non-linear encoding, which means that the difference between two colors is not proportional to their numerical values. This makes it easier to display sRGB colors on typical computer monitors and other devices.</p>
<p>Overall, scRGB is a more advanced and flexible color space than sRGB, but it requires more processing power and is not as widely supported. sRGB, on the other hand, is a standard color space that is widely supported by most devices and applications.</p>
<h1 id="degamma"><a class="markdownIt-Anchor" href="#degamma"></a> Degamma</h1>
<p>Degamma is a process used in digital image and video processing to reverse the gamma correction that is applied to images or videos during encoding. Gamma correction is a non-linear operation that is used to compensate for the non-linear response of human vision to changes in brightness.</p>
<p>Degamma is the process of undoing this non-linear operation to restore the original linear image or video data. This is done to enable further processing or analysis of the image or video data in a linear color space.</p>
<p>During encoding, gamma correction is applied to the image or video data in order to make it easier to display on devices with non-linear displays, such as computer monitors, televisions, and projectors. However, this gamma correction can make it more difficult to perform accurate color grading or other image processing tasks.</p>
<p>Degamma is typically performed by applying an inverse gamma curve to the encoded image or video data. This inverse curve is used to undo the effects of the gamma correction and restore the original linear data. Once the data has been degammaed, it can be processed or analyzed in a linear color space, enabling more accurate color grading and other image processing operations.</p>
<h1 id="pq"><a class="markdownIt-Anchor" href="#pq"></a> PQ</h1>
<p>PQ stands for Perceptual Quantizer (感知量化), which is a type of electro-optical transfer function (电光转换函数) used in high dynamic range (HDR) displays. HDR displays are capable of displaying a wider range of brightness and color than standard dynamic range (SDR) displays, and the PQ transfer function is designed to enable this increased range.</p>
<p>The PQ transfer function is based on human perception of brightness, and it is designed to be more perceptually uniform than traditional gamma curves used in SDR displays. This means that the PQ curve better matches the way that humans perceive changes in brightness, making it easier to display HDR content that looks natural and realistic.</p>
<p>The PQ curve is defined by the International Electrotechnical Commission (IEC) standard IEC 2100-1, and it is used in several HDR standards, including Dolby Vision and HDR10+. The PQ curve maps a range of input values to a range of output values, allowing HDR displays to accurately represent a wide range of brightness and color.</p>
<p>Overall, the PQ transfer function enables HDR displays to deliver a more immersive and realistic viewing experience, with brighter highlights, deeper shadows, and more vibrant colors than SDR displays.</p>
<h1 id="android-hwc"><a class="markdownIt-Anchor" href="#android-hwc"></a> Android HWC</h1>
<p>HWC stands for Hardware Composer. It is a component of the Android operating system that manages the rendering of graphical elements on the screen. It is responsible for taking the output of the various graphical layers in the system, such as the user interface, apps, and games, and compositing them into a single image to be displayed on the screen. The HWC works in conjunction with the graphics hardware on the device to ensure efficient and seamless rendering of the graphical elements. It plays a crucial role in providing a smooth and responsive user experience on Android devices.</p>
<h2 id="why-does-hwc-represent-hardware-composer-rather-than-hardware-compositor"><a class="markdownIt-Anchor" href="#why-does-hwc-represent-hardware-composer-rather-than-hardware-compositor"></a> Why does HWC represent hardware composer rather than hardware compositor</h2>
<p>The term “composer” is used in reference to HWC because it is responsible for composing, or combining, the various graphical layers into a single image that can be displayed on the screen. The term “compositor” could also be used to describe this function, but “composer” is the term that has been traditionally used in the field of computer graphics to describe this type of operation. Additionally, the term “composer” may be seen as more descriptive of the creative process of combining visual elements, while “compositor” may be seen as more technical in nature. Ultimately, the choice of terminology is a matter of convention and personal preference.</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Light Display Manager</title>
    <url>/gfx/lightdm/</url>
    <content><![CDATA[<p><a href="https://wiki.archlinux.org/title/LightDM">Light Display Manager</a> 是一个轻量级的跨桌面环境的 Display Manager, 可以支持多种显示技术，如 X11, Mir, Wayland.</p>
<h1 id="build"><a class="markdownIt-Anchor" href="#build"></a> Build</h1>
<h3 id="dependencies"><a class="markdownIt-Anchor" href="#dependencies"></a> Dependencies</h3>
<ul>
<li>
<p>开发包依赖</p>
<ul>
<li>libpam0g-dev</li>
<li>libgcrypt20-dev</li>
<li>libglib2.0-dev</li>
<li>libxklavier-dev</li>
</ul>
</li>
<li>
<p>构建工具依赖</p>
<ul>
<li>intltool</li>
<li>yelp-tools</li>
<li>gtk-doc-tools</li>
</ul>
</li>
<li>
<p>安装</p>
</li>
</ul>
<p>Lightdm 可执行程序路径 <code>/usr/sbin/lightdm</code>, 日志默认路径 <code>/var/log/lightdm/lightdm.log</code>. 所以构建时可以使用</p>
<ul>
<li><code>--prefix</code> 指定安装路径 (默认 /usr/local)</li>
<li><code>--localstatedir</code> 指定日志路径 (默认 $prefix/var/log/lightdm)</li>
<li><code>--sysconfdir</code> 指定 <code>lightdm.conf</code> 路径 （默认 $prefix/etc/lightdm)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./autogen.sh --prefix=/usr --localstatedir=/var --sysconfdir=/etc --disable-tests</span><br><span class="line">make -j $JOBS</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h1 id="graphics-boot-up"><a class="markdownIt-Anchor" href="#graphics-boot-up"></a> Graphics Boot-up</h1>
<pre><code class="highlight mermaid">flowchart TD
    A[&quot;systemd&quot;]
    B[&quot;/usr/sbin/lightdm&quot;]
    C[&quot;`[Seat:*]
        # Dump core
        xserver-command=X -core`&quot;]
    D[&quot;`X
        Symbolic link to Xorg`&quot;]

    A -- lightdm.service --&gt; B -- /usr/share/lightdm/lightdm.conf.d/50-xserver-command.conf --&gt; C --&gt; D</code></pre>
<p>P.S. <code>lightdm --show-config</code> 可以显示与 lightdm 相关的配置</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>渲染和送显</title>
    <url>/gfx/mesa-dri3/</url>
    <content><![CDATA[<p><img src="/images/mesa-dri3/backbuffer3.png" alt="render &amp; present" /></p>
<span id="more"></span>
<h1 id="渲染"><a class="markdownIt-Anchor" href="#渲染"></a> 渲染</h1>
<p>渲染由显卡(或 SoC)上的 GPU 完成，简单来说就是往后缓冲 (Back Buffer) 里哐哐哐干<strong>像素</strong>，一般要比后面的显示快得多(所以有些像素会被覆盖掉，我们看到的就是撕裂 <strong>Tearing</strong>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> loader_dri3_buffer *</span><br><span class="line"><span class="title function_">dri3_alloc_render_buffer</span><span class="params">(<span class="keyword">struct</span> loader_dri3_drawable *draw,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">int</span> fourcc,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> depth)</span>;</span><br></pre></td></tr></table></figure>
<p><code>dri3_alloc_render_buffer()</code> 的任务是创建渲染 buffer (包括 front 或 back), 并向 X11 导出它们的 fd。驱动当然不是一下子把 <code>buffers[]</code> 数组填满， 它是&quot;按需创建&quot;， <code>buffers[]</code> 像是提供这么多 buffer slot, 当 slot 后面是一个空闲的 buffer, 那就将它返回，否则才真正创建。</p>
<h2 id="drawable-和-buffer"><a class="markdownIt-Anchor" href="#drawable-和-buffer"></a> Drawable 和 Buffer</h2>
<p><code>struct loader_dri3_drawable</code> 和 <code>struct loader_dri3_buffer</code> 这两个结构体，一个作为 <code>dri3_alloc_render_buffer()</code> 的主要参数，一个作为它的返回值类型，可谓是了解 DRI3 扩展下的数据流的关键。</p>
<pre><code class="highlight mermaid">classDiagram
    direction RL
    m_loader_dri3_buffer o-- loader_dri3_buffer : LOADER_DRI3_NUM_BUFFERS
    class loader_dri3_drawable &#123;
        +xcb_connection_t * conn
        +xcb_screen_t * screen
        +__DRIdrawable *dri_drawable
        +xcb_drawable_t drawable
        +xcb_window_t window
        +int width
        +int height
        +int depth
        +uint8_t have_back
        +uint8_t have_fake_front
        +uint64_t send_sbc
        +uint64_t recv_sbc
        +uint64_t ust
        +uint64_t msc
        +uint64_t notify_ust
        +uint64_t notify_msc
        +int cur_back
        +int cur_num_back
        +int max_num_back
        +int cur_blit_source
        +uint32_t *stamp
    &#125;
    class m_loader_dri3_buffer &#123;
        +loader_dri3_buffer *buffers[5]
    &#125;
    class loader_dri3_buffer&#123;
        +__DRIimage * image
        +uint32_t pixmap
        +__DRIimage * linear_buffer
        +uint32_t fence
        +xshmfence * shm_fence
        +bool busy
        +bool own_pixmap
        +bool reallocate
        +uint32_t num_planes
        +uint32_t size
        +int strides[4]
        +int offsets[4]
        +uint64_t modifier
        +uint32_t cpp
        +uint32_t flags
        +uint32_t width
        +uint32_t height
        +uint64_t last_swap
    &#125;</code></pre>
<h2 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h2>
<ul>
<li>当我们谈论 X client 和 server 之间的 Buffer 同步时是在说什么？</li>
</ul>
<p>在DRI3扩展下, render buffer (BO作为GPU 的render target) 是一开始由X client (例如一个 3D App)创建的(可能不止一个), render buffer 创建好后随即会通过 __DRIimageExtension 的 <code>queryImage()</code> 查询到该buffer 的 FD (drmPrimeHandleToFD, 后面会将该 FD 传送给 X server), 而在 X 的 compositor, 拿到 GPU 的渲染结果实际上就是通过该 FD (drmPrimeFDToHandle) 将 render buffer <code>gbm_bo_import()</code> 到 X server 进程, 并创建X 的 Pixmap (Pixmap 的Backing BO就是当初App进程创建的)后读取渲染结果进行合成。</p>
<p>该过程通过 X client 和 server 进程间的 buffer 共享实现了 render buffer 的零拷贝。<br />
而同步问题也在这个过程中产生，当 render buffer 被 server 进程导入后用于合成时，渲染结果什么时候被读取完毕(render buffer IDLE 状态)，需要告知client 进程(client不能在上一帧数据未读取完毕前同时再渲染到同一个render buffer)。同样client 也须在 server 读取当前帧之前告知server 渲染是否已经完成。</p>
<p>这样 X client 和 server 之间的buffer 同步问题就产生了。</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/lib/libxshmfence">xshmfence mapping to X SyncFence</a>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/lib/libxshmfence/-/blob/master/src/xshmfence_alloc.c?ref_type=heads#L69"><code>xshmfence_alloc_shm()</code></a> 通过<code>memfd_create()/shm_open()/open()</code> 之一系统调用返回一个共享内存文件描述符(fence_fd)</li>
<li><a href="https://gitlab.freedesktop.org/xorg/lib/libxshmfence/-/blob/master/src/xshmfence_alloc.c?ref_type=heads#L128"><code>xshmfence_map_shm(fence_fd)</code></a> 通过 <code>mmap()</code> fence_fd 返回一个指向 struct xshmfence 的地址</li>
<li><a href="https://gist.github.com/lucmann/2a6e24338cdae55ac359af3d25ddf2da#file-dri3-c-L377"><code>xcb_dri3_fence_from_fd()</code></a> 将这个 xshmfence 的 fence_fd 发送给 X server, 让其知道这个xshmfence 的存在</li>
</ul>
</li>
</ul>
<p>以上3步实际上是利用4个字节(<code>sizeof(struct xshmfence)</code>)大小的共享内存在X server 和 client 进程间通过原子操作和 futex 系统调用达到两个进程对 render buffer 的同步访问。</p>
<p>(以上4个字节共享内存的结论是基于futex和原子操作实现的 xshmfence 的版本)</p>
<p>由于client 创建的render buffer 是与 X server 共享的，所以这个 render buffer 被两个进程读写时须要同步，Mesa3D 中是使用 xshmfence 来完成这个需求的。xshmfence 顾名思义它是基于共享内存的，采用它实现进程间对 render buffer 操作的同步，好处就是只需要将 xshmfence 映射到一个 X server SyncFence, 通过一个简单的函数调用(<a href="https://gitlab.freedesktop.org/xorg/lib/libxshmfence/-/blob/master/src/xshmfence_futex.c?ref_type=heads#L60">xshmfence_await(struct xshmfence *f)</a>)就可将调用进程(client process)阻塞直到 X server 完成对 render buffer的操作再被操作系统唤醒，而无需通过接收网络事件(socket event)来确定X server 是否已经完成对 render buffer 的使用。</p>
<h2 id="导入导出"><a class="markdownIt-Anchor" href="#导入导出"></a> 导入/导出</h2>
<p>render buffer 的导入/导出操作是Linux 下<a href="https://www.kernel.org/doc/html/latest/driver-api/dma-buf.html">Buffer 共享和同步</a>的一个标准流程，不仅仅是在 DRM 子系统使用，在Linux的其它子系统也广泛使用，如Video4Linux, Networking。这里仅仅将 mesa 中的实现与DMABUF 机制中的角色对应一下，作为一个DMABUF的应用案例分析。</p>
<ul>
<li>
<p>导出(exporter·mesa)</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L1602"><code>image-&gt;queryImage(image, __DRI_IMAGE_ATTRIB_FD, &amp;buffer_fds[i])</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gallium/frontends/dri/dri2.c#L1476"><code>dri2_query_image(image, attrib, *value)</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gallium/frontends/dri/dri2.c#L1350"><code>dri2_query_image_by_resource_handle(image, attrib, *value)</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gallium/drivers/r600/r600_texture.c#L556"><code>pipe_screen-&gt;resource_get_handle(pscreen, NULL, image-&gt;texture, &amp;whandle, usage)</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gallium/winsys/radeon/drm/radeon_drm_bo.c#L1331"><code>radeon_winsys_bo_get_handle(rws, buffer, *whandle)</code></a>
<ul>
<li>drmPrimeHandleToFD()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>(以上调到pipe_screen后以AMD Radeon驱动为例)</p>
</li>
<li>
<p>传送(FD transfer·xcb)</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">xcb_protocol_request_t</span> xcb_req = &#123;</span><br><span class="line">    .count = <span class="number">2</span>,</span><br><span class="line">    .ext = &amp;xcb_dri3_id,</span><br><span class="line">    .opcode = XCB_DRI3_PIXMAP_FROM_BUFFERS,</span><br><span class="line">    .isvoid = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://gist.github.com/lucmann/2a6e24338cdae55ac359af3d25ddf2da#file-dri3-c-L676"><code>xcb_dri3_pixmap_from_buffers()</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/lib/libxcb/-/blob/master/src/xcb_out.c#L225"><code>xcb_send_request_with_fds()</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/lib/libxcb/-/blob/master/src/xcb_out.c#L190"><code>send_fds(xcb_connection_t *, fds, num_fds)</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>导入(importer·xserver)</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/dri3/dri3_request.c#L490"><code>proc_dri3_pixmap_from_buffers(ClientPtr client)</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/dri3/dri3_screen.c#L63"><code>dri3_pixmap_from_fds()</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/glamor/glamor_egl.c#L612"><code>glamor_pixmap_from_fds()</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gbm/main/gbm.c#L583"><code>gbm_bo_import(gbm_device *, GBM_BO_IMPORT_FD_MODIFIER, &amp;import_data, 0)</code> (libgbm.so)</a>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gbm/backends/dri/gbm_dri.c#L801"><code>image-&gt;createImageFromDmaBufs()</code> (libgbm.so)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>(不难看出如果驱动支持DRI3, 则有以下依赖关系 <strong>Xserver-&gt;Glamor-&gt;GBM</strong>)</p>
</li>
<li>
<p>mesa dri3 render buffer (DMABUF) Sharing</p>
</li>
</ul>
<pre><code class="highlight mermaid">sequenceDiagram
    autonumber
    participant App
    participant Mesa
    participant X11

    App--&gt;&gt;Mesa: eglMakeCurrent()
    Mesa-&gt;&gt;Mesa: dri_st_framebuffer_validate()
    Mesa-&gt;&gt;Mesa: dri2_allocate_textures()
    Mesa-&gt;&gt;Mesa: loader_dri3_get_buffers()
    note left of Mesa: Return all necessary buffers and allocating as needed
    Mesa-&gt;&gt;Mesa: dri3_get_buffer()
    rect rgb(191, 223, 255)
    Mesa-&gt;&gt;Mesa: dri3_alloc_render_buffer()
    Mesa--&gt;&gt;X11: xcb_dri3_get_supported_modifiers()
    X11--&gt;&gt;Mesa: xcb_dri3_get_supported_modifiers_reply()
    Mesa-&gt;&gt;Mesa: loader_dri_create_image()
    Mesa-&gt;&gt;Mesa: dri2_create_image()
    Mesa-&gt;&gt;Mesa: xxx_resource_create()
    rect rgb(200, 150, 255)
    Mesa-&gt;&gt;Mesa: dri2_query_image_by_resource_handle(__DRIimage)
    Mesa-&gt;&gt;Mesa: xxx_resource_get_handle()
    Mesa-&gt;&gt;Mesa: xxx_bo_export()
    note right of Mesa: Mesa 导出 FD
    opt xcb_dri3_pixmap_from_buffers(buffer_fds)
        Mesa--&gt;&gt;X11: xcb_send_requests_with_fds(buffer_fds)
    end
    end
    rect rgb(200, 150, 255)
    note left of X11: X11 导入 Buffer
    X11-&gt;&gt;X11: proc_dri3_pixmap_from_buffers()
    X11-&gt;&gt;X11: dri3_pixmap_from_fds()
    X11-&gt;&gt;X11: glamor_pixmap_from_fds()
    alt GBM_BO_WITH_MODIFIERS
        X11-&gt;&gt;X11: gbm_bo_import(type=GBM_BO_IMPORT_FD_MODIFIER)
    else
        X11-&gt;&gt;X11: gbm_bo_import(type=GBM_BO_IMPORT_FD)
    end
    end
    end</code></pre>
<h2 id="所有情况都是-mesa-dri-client-创建导出-renderbufferx11-导入吗"><a class="markdownIt-Anchor" href="#所有情况都是-mesa-dri-client-创建导出-renderbufferx11-导入吗"></a> 所有情况都是 <strong>Mesa (DRI client) 创建导出 RenderBuffer，X11 导入</strong>吗?</h2>
<ul>
<li><code>eglCreatePbufferSurface()</code></li>
</ul>
<p>实际上 PBuffer 是离屏渲染使用的，它是由 X11 创建 buffer, X11 导出 FD, Mesa (应用进程) 导入作为伪前缓冲 (fake front buffer) 使用。</p>
<p>通常 <code>eglCreate***Surface()</code> 需要 App 先调用 <code>XCreateWindow()</code> 让 X11 创建 Pixmap, 但是 <code>eglCreatePbufferSurface()</code> 不用，它由 Mesa 调用 <code>xcb_create_pixmap()</code> 让 X11 创建 Pixmap, 之后 Mesa 再调用 <code>xcb_dri3_buffers_from_pixmap()</code> 让 X11 导出 Pixmap(gbm_bo) 关联的 FD, 由 Mesa 导入。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    autonumber
    participant App
    participant Mesa
    participant X11

    App--&gt;&gt;Mesa: eglCreatePbufferSurface()
    rect rgb(191, 223, 255)
    Mesa-&gt;&gt;Mesa: dri3_create_surface(type=EGL_PBUFFER_BIT)
    Mesa--&gt;&gt;X11: xcb_generate_id()
    X11--&gt;&gt;Mesa: drawable ID (uint32_t)
    Mesa--&gt;&gt;X11: xcb_create_pixmap()
    App--&gt;&gt;Mesa: eglBindTexImage()
    Mesa-&gt;&gt;Mesa: dri_st_framebuffer_validate()
    Mesa-&gt;&gt;Mesa: dri2_allocate_textures()
    Mesa-&gt;&gt;Mesa: loader_dri3_get_buffers()
    Mesa-&gt;&gt;Mesa: dri3_get_pixmap_buffer()
    rect rgb(200, 150, 255)
    note left of X11: X11 导出 FD(调用 gbm_bo_get_fd(gbm_bo*))
    Mesa--&gt;&gt;X11: xcb_dri3_buffers_from_pixmap()
    X11--&gt;&gt;Mesa: xcb_dri3_buffers_from_pixmap_reply()
    Mesa--&gt;&gt;X11: loader_dri3_create_image_from_buffers()
    X11--&gt;&gt;Mesa: xcb_dri3_buffers_from_pixmap_reply_fds()
    end
    rect rgb(200, 150, 255)
    note left of Mesa: Mesa 导入 Buffer
    Mesa-&gt;&gt;Mesa: dri2_from_dma_bufs2()
    Mesa-&gt;&gt;Mesa: dri2_create_image_from_fd()
    Mesa-&gt;&gt;Mesa: dri2_create_image_from_winsys()
    Mesa-&gt;&gt;Mesa: xxx_resource_from_handle()
    Mesa-&gt;&gt;Mesa: xxx_bo_import()
    end
    end</code></pre>
<ul>
<li>DRI2</li>
</ul>
<p>DRI3 与 DRI2 的一个主要区别就是在 DRI3, RenderBuffer 是由 DRI client (Mesa) 创建后通过 bo_export() 导出其 DMA-BUF fd，由 X server 通过 <code>proc_dri3_pixmap_from_buffers()</code> 导入的。 而且 DRI2 不仅导入导出方面是反着的，而且 DRI client 导入的是 <a href="https://www.kernel.org/doc/html/v5.1/gpu/drm-mm.html#gem-objects-naming">GEM name</a>(不是 DMA-BUF fd), 据说 GEM name 这玩意虽然也可以在进程间传递，但相比 DMA-BUF fd 很不安全，所以新驱动都用 DMA-BUF fd 在进程间传递 Buffer, 只有旧驱动可能还有 GEM name。</p>
<p><em>实现上没太明白 GEM name 为什么不安全，大家都是 32-bit 整数，GEM name 能被猜，文件描述符 fd 也能被猜啊</em></p>
<p>找到解释了，<a href="https://www.kernel.org/doc/html/next/gpu/drm-mm.html#overview-and-lifetime-rules">PRIME Buffer Sharing - Overview and Lifetime Rules</a>, 文件描述符 (file descriptor) 必须通过 <strong>UNIX domain sockets</strong> 在应用之间 send，不可能像全局唯一的 GEM names 一样被猜。 <strong>send over UNIX domain sockets</strong> 应该就是 XCB 库实现的这个函数 <code>xcb_send_requests_with_fds()</code>。</p>
<h2 id="dri3_find_back"><a class="markdownIt-Anchor" href="#dri3_find_back"></a> dri3_find_back</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find an idle back buffer. If there isn&#x27;t one, then</span></span><br><span class="line"><span class="comment"> * wait for a present IdleNotify event from the X server</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dri3_find_back</span><span class="params">(<span class="keyword">struct</span> loader_dri3_drawable *draw,</span></span><br><span class="line"><span class="params">               <span class="type">bool</span> prefer_a_different)</span>;</span><br></pre></td></tr></table></figure>
<p><code>dri3_find_back()</code> 的任务是查找 <code>buffers[]</code> 中空闲 buffer 的 slot (array index), 如果存在，返回其 index, 否则等待 (<code>dri3_wait_for_event_locked()</code>)</p>
<p>如何知道 buffer 是否空闲呢？ <code>buffer-&gt;busy</code>, 这个标志在 SwapBuffers 时会置为 true, mesa 收到 IdleNotify 事件后置为 false</p>
<pre><code class="highlight mermaid">sequenceDiagram
    autonumber
    participant Mesa
    participant X11

    Mesa-&gt;&gt;Mesa: dri3_find_back
    note right of Mesa: 选取一个合适的空闲 slot id, buffers[id]有可能是空, 这时需要创建 buffer: dri3_alloc_render_buffer()
    rect rgb(200, 150, 255)
    note right of Mesa: mtx_lock()
    alt pefer_a_different==false
        Mesa--&gt;&gt;X11: dri3_flush_present_events()
        loop xcb_poll_for_special_event
            X11--&gt;&gt;Mesa: xcb_present_generic_event_t
        end
        Mesa-&gt;&gt;Mesa: dri3_handle_present_event()
    else perfer_a_different==true
        Mesa--&gt;&gt;X11: xcb_flush()
        loop dri3_wait_for_event_locked()
            X11--&gt;&gt;Mesa: xcb_present_generic_event_t
        end
        Mesa-&gt;&gt;Mesa: dri3_handle_present_event()
    end
    note right of Mesa: mtx_unlock()
    end</code></pre>
<h2 id="loader_dri3_swap_buffers_msc"><a class="markdownIt-Anchor" href="#loader_dri3_swap_buffers_msc"></a> loader_dri3_swap_buffers_msc</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make the current back buffer visible using the present extension</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int64_t</span></span><br><span class="line"><span class="title function_">loader_dri3_swap_buffers_msc</span><span class="params">(<span class="keyword">struct</span> loader_dri3_drawable *draw,</span></span><br><span class="line"><span class="params">                             <span class="type">int64_t</span> target_msc, <span class="type">int64_t</span> divisor, <span class="type">int64_t</span> remainder,</span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> flush_flags,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">int</span> *rects, <span class="type">int</span> n_rects,</span></span><br><span class="line"><span class="params">                             <span class="type">bool</span> force_copy)</span>;</span><br></pre></td></tr></table></figure>
<pre><code class="highlight mermaid">flowchart TB
  subgraph Render [&quot;渲染到 back buffer&quot;]
    direction TB
    subgraph RenderBufferAlloc [&quot;Allocate/Pick a back buffer&quot;]
      direction TB
      a1[&quot;dri_make_current()&quot;]
      a2[&quot;st_api_make_current()&quot;]
      a3[&quot;st_framebuffer_validate()&quot;]
      a4[&quot;dri_st_framebuffer_validate()&quot;]
      a5[&quot;dri2_allocate_textures()&quot;]
      a6[&quot;dri_image_drawable_get_buffers()&quot;]
      a7[&quot;loader_dri3_get_buffers()&quot;]
      a8[[&quot;dri3_alloc_render_buffer()&quot;]]
    end
    b[&quot;glDraw*()&quot;]
  end
  A[&quot;eglSwapBuffers()&quot;]
  B[&quot;dri3_swap_buffers()&quot;]
  C[&quot;dri3_swap_buffers_with_damage()&quot;]
  D[&quot;glXSwapBuffers()&quot;]
  E[&quot;dri3_swap_buffers()&quot;]
  subgraph Swap [&quot;loader_dri3_swap_buffers_msc()&quot;]
    direction TB
    G[&quot;loader_dri3_vtable-&gt;flush_drawable()&quot;]
    H[&quot;dri3_find_back_alloc()&quot;]
    I[&quot;dri3_flush_present_events()&quot;]
    J[&quot;xcb_xfixes_create_region()&quot;]
    K[&quot;xcb_xfixes_set_region()&quot;]
    L[&quot;xcb_present_pixmap()&quot;]
    M[&quot;dri_invalidate_drawable()&quot;]
  end
  subgraph Note1 [&quot;返回要送显的 back buffer&quot;]
    dummy1[&quot;这里通过 dri3_find_back()&lt;br&gt;确保这里返回的是当前已经渲染好的(flushed) back buffer&quot;]
  end
  subgraph Note2 [&quot;选取或申请 back buffer&quot;]
    dummy2[&quot;loader_dri3_drawable-&gt;buffers[]有5个&lt;br&gt;loader_dri3_buffer 的槽位&lt;br&gt;第1帧渲染时需要调用&lt;br&gt;dri3_alloc_render_buffer()&lt;br&gt;来申请新的back buffer&quot;]
  end

  a1 --&gt; a2 --&gt; a3 --&gt; a4 --&gt; a5 --&gt; a6 --&gt; a7 --&gt; a8 --&gt; b
  b --&gt; A
  b --&gt; D
  A --&gt; B
  B --&gt; C
  D --&gt; E
  C --&gt; G
  E ---&gt; G
  G --&gt; H --&gt; I --&gt; J --&gt; K --&gt; L --&gt; M
  Note1 -.-&gt; H
  Note2 -.-&gt; a8</code></pre>
<h2 id="dri2-throttle"><a class="markdownIt-Anchor" href="#dri2-throttle"></a> DRI2 Throttle</h2>
<p>这个扩展原来好像是控制 DRI client 能同时并发地渲染多少个 RenderBuffer (或者说多少帧)的，因为原来 mesa 里有一个 <code>PIPE_CAP_MAX_FRAMES_IN_FLIGHT</code>, 因为这个值后来要么是 1， 要么是 0，就被改成 <a href="https://docs.mesa3d.org/gallium/screen.html?highlight=pipe_cap_throttle"><code>PIPE_CAP_THROTTLE</code></a> 了, 默认是 throttle 的, 按目前的实现，如果节流了，就是说当驱动提交了第 2 帧的渲染命令后，要等第 1 帧渲染完成 (pipe_fence_handle 是 drm_syncobj 的封装)，才能继续准备第 3 帧的渲染命令。</p>
<pre><code class="highlight mermaid">flowchart LR
    subgraph &quot;Frame 0&quot;
        F1[&quot;CPU Submit 1&quot;]
    end
    subgraph &quot;Frame 1&quot;
        F2[&quot;CPU Submit 2&quot;]
        R1[&quot;GPU Render Done 1 fa:fa-spinner&quot;]
    end
    subgraph &quot;Frame 2&quot;
        F3[&quot;CPU Submit 3&quot;]
        R2[&quot;GPU Render Done 2 fa:fa-spinner&quot;]
    end
    subgraph &quot;Frame 3&quot;
        F4[&quot;CPU Submit 4&quot;]
        R3[&quot;GPU Render Done 3 fa:fa-spinner&quot;]
    end

    F1 --&gt; F2
    F2 --Block until--&gt; R1 --&gt; F3
    F3 --Block until--&gt; R2 --&gt; F4
    F4 --Block until--&gt; R3</code></pre>
<p>Throttle 的效果是 CPU 在提交后一帧的渲染命令后，要等(所谓“等”就是主线程调用 <code>drmSyncobjWait()</code> 阻塞)前一帧渲染完成后才唤醒继续准备下一帧数据，整个过程实际上是节流 CPU, 是让生产者-消费者中的<strong>生产者(CPU)</strong> 慢一点。所以 DRI2 Throttle 的本意就是在 GPU 渲染任务比较重(延迟大)的时候，CPU 这边没必要“玩命”准备数据，否则反而会导致比如过多消耗显存等其它问题。</p>
<p>Mesa 中对 Throttle 的实现很有技巧性。因为这里“等”的是上一帧数据提交给内核后，drm_gpu_scheduler 为这个 job 创建的一个 <code>dma_fence</code>, 在提交时，userspace 会给 kernel 一个 syncobj (当一个 fence 容器用，意思是 gpu scheduler 创建好 fence 后 attach 到这个 syncobj, userspace 就可以通过 <code>drmSyncobjWait()</code> 阻塞式地等 syncobj 包含的 fence 是否被 signaled)。 因为 fence 是在渲染命令 push 到 drm_gpu_scheduler 后内核才创建的, 所以提交时带下去的 syncobj 用来装当前产生的 fence，如果你需要在下一帧数据提交后等上一帧的 fence, 你需要在当前帧提交后，创建一个新的 syncobj 来存当前帧的 fence，这样就可以在下一帧提交后， 用这个新的 syncobj 来等上一帧的 fence 了。 <strong>相当于同一个 fence 放在两个不同的容器里用</strong>。</p>
<h1 id="送显"><a class="markdownIt-Anchor" href="#送显"></a> 送显</h1>
<p>如果平台的窗口系统(Winsys)是X11, 则送显主要是通过 Present 扩展完成的。Client (代码主要在 UMD) 与 X Server 的交互主要通过 <a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/present/present_priv.h#L226">present_event</a> 完成的， <code>present_event</code> 主要有以下 3 个:</p>
<ul>
<li>XCB_PRESENT_EVENT_CONFIGURE_NOTIFY</li>
<li>XCB_PRESENT_EVENT_COMPLETE_NOTIFY
<ul>
<li>这个事件传达的主要信息是 <strong>X Server 是以哪种模式上屏刚才送显的 Back Buffer 的</strong>(注意是<strong>过去完成时</strong>), 主要有 4 种模式
<ul>
<li>XCB_PRESENT_COMPLETE_MODE_COPY
<ul>
<li>几乎所有的 3D 应用(除了像 KWin 这样的 compositor)在绝大多数情况下送显的 Back Buffer 都是以这种模式上屏的。因为一般的应用不是全屏，不可能直接<strong>FLIP (改一下 DC Framebuffer base register)</strong></li>
</ul>
</li>
<li>XCB_PRESENT_COMPLETE_MODE_FLIP
<ul>
<li>像 KWin 合成器合成的<strong>全屏</strong> screen image 上屏一般是这种模式，这种方式显然要比 COPY 快很多</li>
</ul>
</li>
<li>XCB_PRESENT_COMPLETE_MODE_SKIP
<ul>
<li>如果 PresentCompleteNotify 传回的是这个模式，不好意思，X Server 并没有把刚才送显的 Back Buffer 上屏，这意味着<strong>丢帧</strong></li>
</ul>
</li>
<li>XCB_PRESENT_COMPLETE_MODE_SUBOPTIMAL_COPY
<ul>
<li>如果 PresentCompleteNotify 传回的是这个模式，表明如果下次用不同的 <strong>format/modifier</strong> 重新申请一个 Back buffer，X Server 很可能就可以以 <strong>FLIP</strong> 模式上屏 Back buffer</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>XCB_PRESENT_EVENT_IDLE_NOTIFY</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">present_event</span> &#123;</span></span><br><span class="line">    present_event_ptr next;</span><br><span class="line">    ClientPtr client;</span><br><span class="line">    WindowPtr window;</span><br><span class="line">    XID id;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">&#125; present_event_rec;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>注册事件</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L1709"><code>dri3_setup_present_event(struct loader_dri3_drawable *draw)</code></a>
<ul>
<li><a href="https://gist.github.com/lucmann/2a6e24338cdae55ac359af3d25ddf2da#file-present-c-L398"><code>xcb_present_select_input()</code></a>: 告诉Xserver，client 正在监听哪些事件。(注册时实际上是使用对应事件的 MASK 注册的，因为在向 Xserver 发送的注册消息中，注册的所有消息的MASK ORing 在一个 uint32_t <a href="https://gist.github.com/lucmann/2a6e24338cdae55ac359af3d25ddf2da#file-present-c-L416"><code>event_mask</code></a>发送过去的)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>接收事件</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L1699"><code>dri3_setup_present_event(struct loader_dri3_drawable *draw)</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L1779"><code>xcb_register_for_special_xge()</code></a>: 创建一个接收Present XGE 事件的队列，实质上是初始化了一个 pthread_cond_t。（这里 special 就special在它是一个带了条件变量的 generic events 的队列)  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xcb_special_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xcb_special_event</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span>     extension;</span><br><span class="line">    <span class="type">uint32_t</span>    eid;</span><br><span class="line">    <span class="type">uint32_t</span>    *stamp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_list</span> *<span class="title">events</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_list</span> **<span class="title">events_tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_cond_t</span> special_event_cond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>(XGE指 <a href="https://www.x.org/wiki/Development/Documentation/XGE/">X Generic Event extension</a>)</p>
</li>
<li>
<p>处理事件</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L987"><code>dri3_flush_present_events(struct loader_dri3_drawable *draw)</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/lib/libxcb/-/blob/master/src/xcb_in.c#L787"><code>xcb_poll_for_special_event()</code></a></li>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L483"><code>dri3_handle_present_event(draw, ge)</code></a>: 处理一个 X generic event</li>
</ul>
</li>
</ul>
</li>
<li>
<p>等待事件 (阻塞式)</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L611"><code>loader_dri3_wait_for_msc()</code></a>: (阻塞)等待X Server 管理的 MSC 大于等于当前应用的 MSC (target_msc)
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L572"><code>dri3_wait_for_event_locked(draw, &amp;full_sequence)</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/lib/libxcb/-/blob/master/src/xcb_in.c#L806"><code>xcb_wait_for_special_event(draw-&gt;conn, draw-&gt;special_event)</code></a></li>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L483"><code>dri3_handle_present_event(draw, ge)</code></a>: 处理一个 X generic event</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L649"><code>loader_dri3_wait_for_sbc()</code></a>: (阻塞)等待SBC 大于等于当前应用的 SBC (target_sbc)
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L572"><code>dri3_wait_for_event_locked(draw, NULL)</code></a>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/lib/libxcb/-/blob/master/src/xcb_in.c#L806"><code>xcb_wait_for_special_event(draw-&gt;conn, draw-&gt;special_event)</code></a></li>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/loader_dri3/loader_dri3_helper.c#L483"><code>dri3_handle_present_event(draw, ge)</code></a>: 处理一个 X generic event</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以上无论是 <code>loader_dri3_wait_for_msc()</code> 还是 <code>loader_dri3_wait_for_sbc()</code>, 当所等待的条件满足后，都会更新(<code>dri3_handle_present_event()</code>)当前client 的状态(UST, MSC, SBC), 整个过程是一种同步，也是一种协商。</p>
<h2 id="vertical-refresh-vs-swap-interval"><a class="markdownIt-Anchor" href="#vertical-refresh-vs-swap-interval"></a> Vertical Refresh vs Swap Interval</h2>
<p>这两个概念在<strong>渲染</strong>和<strong>送显</strong>这整个过程里很重要。它们俩是两个层次的东西，简单说，前者是硬件层面的，后者是软件层面的。</p>
<p>Vertical Refresh (又叫 Vertical Refresh Rate, Vsync Rate), 指显示器一秒钟能刷新多少次画面。给定一款显示器，它支持的 Vertical Refresh Rate 就那么几种，比如设置成 60 Hz, 表示每 <strong>16.67ms</strong> 刷新一次。</p>
<p>Swap Interval 是图形 API (EGL/GLX) 提供的一个功能 (<a href="https://registry.khronos.org/OpenGL/extensions/SGI/GLX_SGI_swap_control.txt">GLX_SGI_swap_control</a>, <a href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_swap_control.txt">GLX_EXT_swap_control</a>, <a href="https://registry.khronos.org/OpenGL/extensions/MESA/GLX_MESA_swap_control.txt">GLX_MESA_swap_control</a>)，就是允许应用程序渲染时自己选择<strong>跟不跟显示器这个刷新节奏</strong>，通常 Swap Interval 是一个整数值</p>
<table>
<thead>
<tr>
<th style="text-align:left">Swap Interval</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">最大 FPS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">不跟 Vsync, 尽可能提交，但可能撕裂</td>
<td style="text-align:left">取决于 GPU 性能</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">每 Vsync 提交一次</td>
<td style="text-align:left">等于 vsync rate</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">每两次 Vsync 提交一次</td>
<td style="text-align:left">vsync rate 的一半</td>
</tr>
</tbody>
</table>
<p>NOTE: EGL 是通过 <code>eglSwapInterval()</code> 设置 Swap Interval 的， Vulkan 不直接设置 interval 值，而是通过 <code>VkPresentModeKHR</code></p>
<h1 id="drm-modifiers"><a class="markdownIt-Anchor" href="#drm-modifiers"></a> DRM Modifiers</h1>
<p>向 X server 查询并获取显示/渲染设备所支持的 modifiers 是执行 <a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gallium/include/mesa_interface.h#L1570"><code>__DRIimageExtension::createImage()</code></a> 的一个准备工作。但 <code>createImage()</code> 允许modifiers 为空，此情况下让驱动来选一个合适的纹理图像内存布局。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__DRIimage *</span><br><span class="line">(*createImage)(__DRIscreen *screen,</span><br><span class="line">               <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> format,</span><br><span class="line">               <span class="type">const</span> <span class="type">uint64_t</span> *modifiers, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> modifier_count,</span><br><span class="line">               <span class="type">unsigned</span> <span class="type">int</span> use,</span><br><span class="line">               <span class="type">void</span> *loaderPrivate);</span><br></pre></td></tr></table></figure>
<p>与 X server 交互的过程包括 3 步:</p>
<ul>
<li><a href="https://gist.github.com/lucmann/2a6e24338cdae55ac359af3d25ddf2da#file-dri3-c-L496"><code>xcb_dri3_get_supported_modifiers(draw-&gt;conn, draw-&gt;window, depth, buffer-&gt;cpp*8)</code></a>: 返回一个 cookie</li>
<li><a href="https://gist.github.com/lucmann/2a6e24338cdae55ac359af3d25ddf2da#file-dri3-c-L604"><code>xcb_dri3_get_supported_modifiers_reply(draw-&gt;conn, mod_cookie, &amp;error)</code></a>: 返回一个 reply 包含实际的modifiers内容
<ul>
<li><code>xcb_dri3_get_supported_modifiers_reply_t</code></li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xcb_dri3_get_supported_modifiers_reply_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> response_type;</span><br><span class="line">    <span class="type">uint8_t</span> pad0;</span><br><span class="line">    <span class="type">uint16_t</span> sequence;</span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="type">uint32_t</span> num_window_modifiers;</span><br><span class="line">    <span class="type">uint32_t</span> num_screen_modifiers;</span><br><span class="line">    <span class="type">uint8_t</span> pad1[<span class="number">16</span>];</span><br><span class="line">&#125; <span class="type">xcb_dri3_get_supported_modifiers_reply_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/dri3/dri3_request.c#L394"><code>proc_dri3_get_supported_modifiers(ClientPtr client)</code></a>
<ul>
<li>
<p><a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/dri3/dri3_screen.c#L236"><code>dri3_get_supported_modifiers()</code></a>: 通过 <code>drm_format_for_depth(depth, bpp)</code> 获得一个 <code>DRM_FORMAT_*</code>, 实际上<a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/dri3/dri3.c#L117"><code>drm_format_for_depth()</code></a> 返回的 <code>format</code> 也只会是以下4种之一:</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DRM_FORMAT_RGB565       <span class="comment">// bpp = 16</span></span><br><span class="line">DRM_FORMAT_XRGB8888     <span class="comment">// bpp = 24</span></span><br><span class="line">DRM_FORMAT_XRGB2101010  <span class="comment">// bpp = 30</span></span><br><span class="line">DRM_FORMAT_ARGB8888     <span class="comment">// bpp = 32</span></span><br></pre></td></tr></table></figure>
<p>无论是获取 screen_modifiers 还是 window_modifiers, 实际上都依据 format 获取相应的 modifiers.</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/glamor/glamor.c#L1003"><code>glamor_get_drawable_modifiers(DrawablePtr draw, uint32_t format, uint32_t *num_modifiers, uint64_t **modifiers)</code></a>: 回调由具体的DDX(如modesetting)提供的 <code>get_drawable_modifiers()</code> 函数
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/hw/xfree86/drivers/modesetting/drmmode_display.c#L230"><code>get_drawable_modifiers(DrawablePtr draw, uint32_t format, uint32_t *num_modifiers, uint64_t **modifiers)</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://gist.github.com/lucmann/2a6e24338cdae55ac359af3d25ddf2da#file-dri3-c-L558"><code>xcb_dri3_get_supported_modifiers_window_modifiers(mod_reply)</code></a>
<ul>
<li><a href="https://gist.github.com/lucmann/2a6e24338cdae55ac359af3d25ddf2da#file-dri3-c-L580"><code>xcb_dri3_get_supported_modifiers_screen_modifiers(mod_reply)</code></a>: 如果获取window_modifiers 失败则fallback 到screen_modifiers</li>
</ul>
</li>
</ul>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li>MSC: Graphics Media Stream Counter, 实际上就是CRTC 的Vblank中断次数 <a href="https://registry.khronos.org/OpenGL/extensions/OML/GLX_OML_sync_control.txt">(GLX_OML_sync_control)</a></li>
<li>SBC: Swap Buffer Counter, 就是Swapbuffer 的次数 <a href="https://registry.khronos.org/OpenGL/extensions/EXT/EXT_swap_control.txt">(GLX_EXT_swap_control)</a></li>
<li><a href="https://www.kernel.org/doc/html/v5.1/gpu/drm-mm.html#gem-objects-naming">GEM Objects Naming</a></li>
<li><a href="https://lists.freedesktop.org/archives/mesa-dev/2011-October/013221.html">Implement a throttle dri extension v2</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>Mesa Gallium 驱动框架</title>
    <url>/gfx/mesa-gallium/</url>
    <content><![CDATA[<h1 id="gallium-framework"><a class="markdownIt-Anchor" href="#gallium-framework"></a> Gallium Framework</h1>
<p>引用<a href="https://docs.mesa3d.org/gallium/intro.html#what-is-gallium"> Mesa3D 官方文档</a>的话，Gallium 本质上是一种应用程序接口，用于编写与设备基本无关的图形驱动程序。它提供了多个对象，以简单明了的方式封装了图形硬件的核心服务。据说，Gallium 的设计是借鉴了 DirectX。</p>
<span id="more"></span>
<p>它提供的比较核心的对象，我觉得有</p>
<ul>
<li><code>pipe_screen</code></li>
<li><code>pipe_context</code></li>
<li><code>pipe_resource</code></li>
<li><code>pipe_surface</code></li>
<li><code>pipe_framebuffer_state</code></li>
</ul>
<p>一开始看 Gallium 时，疑问为什么没有 <em>pipe_device</em>, 其实很简单，Gallium 这一套 API 之所以可以用来编写<strong>与设备基本无关</strong>的图形驱动程序，可能就是因为它没有抽象 device 这个数据结构。</p>
<p>Gallium 确实是一组 API, 因为 <code>pipe_screen</code> 里是一大堆函数, <code>pipe_context</code> 里也是一大堆函数。虽然 Gallium 没有定义 pipe_device, 但几乎与硬件设备相关的一切都包含在了 <code>pipe_screen</code>,  一个 <code>pipe_screen</code> 同时可以追踪多个 <code>pipe_context</code>, 每个 <code>pipe_context</code> 里都有一个指向它所在的 <code>pipe_screen</code> 的指针 (handle)。</p>
<p>当一个 Gallium 驱动初始化时，第一个调用的函数就是 <code>driCreateNewScreen3()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the first entrypoint in the driver called by the DRI driver loader</span></span><br><span class="line"><span class="comment"> * after dlopen()ing it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It&#x27;s used to create global state for the driver across contexts on the same</span></span><br><span class="line"><span class="comment"> * Display.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__DRIscreen *</span><br><span class="line"><span class="title function_">driCreateNewScreen3</span><span class="params">(<span class="type">int</span> scrn, <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> __DRIextension **loader_extensions,</span></span><br><span class="line"><span class="params">                    <span class="keyword">enum</span> dri_screen_type type,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> __DRIconfig ***driver_configs, <span class="type">bool</span> driver_name_is_inferred,</span></span><br><span class="line"><span class="params">                    <span class="type">bool</span> has_multibuffer, <span class="type">void</span> *data)</span></span><br></pre></td></tr></table></figure>
<pre><code class="highlight mermaid">flowchart TD
    A[&quot;__glXInitialize()&quot;]
    B[&quot;AllocAndFetchScreenConfigs()&quot;]
    C[&quot;dri3_create_screen()&quot;]
    D[&quot;`**driCreateNewScreen3()**`&quot;]
    E[&quot;dri2_init_screen()&quot;]
    F[&quot;pipe_loader_create_screen()&quot;]
    G[&quot;pipe_loader_create_screen_vk()&quot;]
    H[&quot;pipe_loader_drm_create_screen()&quot;]
    I[&quot;pipe_xxx_create_screen()&quot;]
    J[&quot;`**xxx_create_screen()**`&quot;]

    A --&gt; B --&gt; C --&gt; D --&gt; E --&gt; F --&gt; G --&gt; H --&gt; I --&gt; J</code></pre>
<h1 id="state-tracker"><a class="markdownIt-Anchor" href="#state-tracker"></a> State Tracker</h1>
<pre><code class="highlight mermaid">flowchart TD
    A[&quot;vbo_exec_FlushVertices_internal()&quot;]
    B[&quot;vbo_exec_vtx_flush()&quot;]
    C[&quot;vbo_exec_copy_vertices()&quot;]
    D[&quot;st_prepare_draw()&quot;]
    E[&quot;st_validate_st()&quot;]
    F[&quot;st_update_framebuffer_state()&quot;]
    G[&quot;st_manager_validate_framebuffers()&quot;]
    H[&quot;st_framebuffer_validate()&quot;]

    A --&gt; B --&gt; C --&gt; D --&gt; E -- ST_NEW_FB_STATE --&gt; F --&gt; G --&gt; H</code></pre>
<p><code>st_validate_st()</code> 可能会更新很多状态，像 <code>ST_NEW_FB_STATE</code> 如果 dirty, 那么就会调用 <code>st_update_framebuffer_state()</code> 函数。</p>
<ul>
<li><code>grep -Po 'ST_STATE\(ST_.*?\)' src/mesa/state_tracker/st_atom_list.h | awk -F&quot;[(,)]&quot; '&#123;printf &quot;| %-26s | %-32s |\n&quot;, $2, $3&#125;'</code></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">STATE</th>
<th style="text-align:left">HOOK</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ST_NEW_DSA</td>
<td style="text-align:left">st_update_depth_stencil_alpha</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_CLIP_STATE</td>
<td style="text-align:left">st_update_clip</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_FS_STATE</td>
<td style="text-align:left">st_update_fp</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_GS_STATE</td>
<td style="text-align:left">st_update_gp</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TES_STATE</td>
<td style="text-align:left">st_update_tep</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TCS_STATE</td>
<td style="text-align:left">st_update_tcp</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VS_STATE</td>
<td style="text-align:left">st_update_vp</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_POLY_STIPPLE</td>
<td style="text-align:left">st_update_polygon_stipple</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_WINDOW_RECTANGLES</td>
<td style="text-align:left">st_update_window_rectangles</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_BLEND_COLOR</td>
<td style="text-align:left">st_update_blend_color</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VS_SAMPLER_VIEWS</td>
<td style="text-align:left">st_update_vertex_textures</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_FS_SAMPLER_VIEWS</td>
<td style="text-align:left">st_update_fragment_textures</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_GS_SAMPLER_VIEWS</td>
<td style="text-align:left">st_update_geometry_textures</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TCS_SAMPLER_VIEWS</td>
<td style="text-align:left">st_update_tessctrl_textures</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TES_SAMPLER_VIEWS</td>
<td style="text-align:left">st_update_tesseval_textures</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VS_SAMPLERS</td>
<td style="text-align:left">st_update_vertex_samplers</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TCS_SAMPLERS</td>
<td style="text-align:left">st_update_tessctrl_samplers</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TES_SAMPLERS</td>
<td style="text-align:left">st_update_tesseval_samplers</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_GS_SAMPLERS</td>
<td style="text-align:left">st_update_geometry_samplers</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_FS_SAMPLERS</td>
<td style="text-align:left">st_update_fragment_samplers</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VS_IMAGES</td>
<td style="text-align:left">st_bind_vs_images</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TCS_IMAGES</td>
<td style="text-align:left">st_bind_tcs_images</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TES_IMAGES</td>
<td style="text-align:left">st_bind_tes_images</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_GS_IMAGES</td>
<td style="text-align:left">st_bind_gs_images</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_FS_IMAGES</td>
<td style="text-align:left">st_bind_fs_images</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_FB_STATE</td>
<td style="text-align:left">st_update_framebuffer_state</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_BLEND</td>
<td style="text-align:left">st_update_blend</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_RASTERIZER</td>
<td style="text-align:left">st_update_rasterizer</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_SAMPLE_STATE</td>
<td style="text-align:left">st_update_sample_state</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_SAMPLE_SHADING</td>
<td style="text-align:left">st_update_sample_shading</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_SCISSOR</td>
<td style="text-align:left">st_update_scissor</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VIEWPORT</td>
<td style="text-align:left">st_update_viewport</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VS_CONSTANTS</td>
<td style="text-align:left">st_update_vs_constants</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TCS_CONSTANTS</td>
<td style="text-align:left">st_update_tcs_constants</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TES_CONSTANTS</td>
<td style="text-align:left">st_update_tes_constants</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_GS_CONSTANTS</td>
<td style="text-align:left">st_update_gs_constants</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_FS_CONSTANTS</td>
<td style="text-align:left">st_update_fs_constants</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VS_UBOS</td>
<td style="text-align:left">st_bind_vs_ubos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TCS_UBOS</td>
<td style="text-align:left">st_bind_tcs_ubos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TES_UBOS</td>
<td style="text-align:left">st_bind_tes_ubos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_FS_UBOS</td>
<td style="text-align:left">st_bind_fs_ubos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_GS_UBOS</td>
<td style="text-align:left">st_bind_gs_ubos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VS_ATOMICS</td>
<td style="text-align:left">st_bind_vs_atomics</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TCS_ATOMICS</td>
<td style="text-align:left">st_bind_tcs_atomics</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TES_ATOMICS</td>
<td style="text-align:left">st_bind_tes_atomics</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_FS_ATOMICS</td>
<td style="text-align:left">st_bind_fs_atomics</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_GS_ATOMICS</td>
<td style="text-align:left">st_bind_gs_atomics</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VS_SSBOS</td>
<td style="text-align:left">st_bind_vs_ssbos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TCS_SSBOS</td>
<td style="text-align:left">st_bind_tcs_ssbos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TES_SSBOS</td>
<td style="text-align:left">st_bind_tes_ssbos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_FS_SSBOS</td>
<td style="text-align:left">st_bind_fs_ssbos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_GS_SSBOS</td>
<td style="text-align:left">st_bind_gs_ssbos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_PIXEL_TRANSFER</td>
<td style="text-align:left">st_update_pixel_transfer</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_TESS_STATE</td>
<td style="text-align:left">st_update_tess</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_HW_ATOMICS</td>
<td style="text-align:left">st_bind_hw_atomic_buffers</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_VERTEX_ARRAYS</td>
<td style="text-align:left">st_update_array</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_CS_STATE</td>
<td style="text-align:left">st_update_cp</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_CS_SAMPLER_VIEWS</td>
<td style="text-align:left">st_update_compute_textures</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_CS_SAMPLERS</td>
<td style="text-align:left">st_update_compute_samplers</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_CS_CONSTANTS</td>
<td style="text-align:left">st_update_cs_constants</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_CS_UBOS</td>
<td style="text-align:left">st_bind_cs_ubos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_CS_ATOMICS</td>
<td style="text-align:left">st_bind_cs_atomics</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_CS_SSBOS</td>
<td style="text-align:left">st_bind_cs_ssbos</td>
</tr>
<tr>
<td style="text-align:left">ST_NEW_CS_IMAGES</td>
<td style="text-align:left">st_bind_cs_images</td>
</tr>
</tbody>
</table>
<h1 id="gallium-api"><a class="markdownIt-Anchor" href="#gallium-api"></a> Gallium API</h1>
<h2 id="resource_copy_region"><a class="markdownIt-Anchor" href="#resource_copy_region"></a> resource_copy_region</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy a block of pixels from one resource to another.</span></span><br><span class="line"><span class="comment"> * The resource must be of the same format.</span></span><br><span class="line"><span class="comment"> * Resources with nr_samples &gt; 1 are not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*resource_copy_region)(<span class="keyword">struct</span> pipe_context *pipe,</span><br><span class="line">                             <span class="keyword">struct</span> pipe_resource *dst,</span><br><span class="line">                             <span class="type">unsigned</span> dst_level,</span><br><span class="line">                             <span class="type">unsigned</span> dstx, <span class="type">unsigned</span> dsty, <span class="type">unsigned</span> dstz,</span><br><span class="line">                             <span class="keyword">struct</span> pipe_resource *src,</span><br><span class="line">                             <span class="type">unsigned</span> src_level,</span><br><span class="line">                             <span class="type">const</span> <span class="keyword">struct</span> pipe_box *src_box);</span><br></pre></td></tr></table></figure>
<p>resource_copy_region 只能在 buffer 与 buffer 之间或 texture 与 texture 之间 memcpy, 而且源与目标的 format 必须相同。之所以不能做 buffers 与 textures 之间的 memcpy, 至少是因为缺少 stride 参数。一些硬件(如 nvidia) 可以通过专门的 copy engine 完成这些拷贝，但对于其它硬件可能需要一个 compute shader 去做这些拷贝。另一方面，那些专门的 copy engine 通常是比较慢的，所以只在那些带宽非常有限的 PCIe 传输场景下才有用。如果想利用全部的<br />
VRAM 带宽(甚至 infinity cache bandwidth), 你很可能必须使用 compute shaders.</p>
<h1 id="gallium-hud"><a class="markdownIt-Anchor" href="#gallium-hud"></a> Gallium HUD</h1>
<p>HUD (Head-up Display) 是 Gallium 一个用于观测图形应用的 fps, cpu 利用率等性能数据的内置功能，它有点像精简版的 <a href="https://github.com/flightlessmango/MangoHud">MangoHud</a>, 但它的方便在于集成在驱动内部，不管是普通的 Gallium 驱动，还是 Zink，它都可以使用。它的 mannual 可以通过环境变量 <code>GALLIUM_HUD=help</code> 看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Syntax: GALLIUM_HUD=name1[+name2][...][:value1][,nameI...][;nameJ...]</span><br><span class="line"></span><br><span class="line">  Names are identifiers of data sources which will be drawn as graphs</span><br><span class="line">  in panes. Multiple graphs can be drawn in the same pane.</span><br><span class="line">  There can be multiple panes placed in rows and columns.</span><br><span class="line"></span><br><span class="line">  &#x27;+&#x27; separates names which will share a pane.</span><br><span class="line">  &#x27;:[value]&#x27; specifies the initial maximum value of the Y axis</span><br><span class="line">             for the given pane.</span><br><span class="line">  &#x27;,&#x27; creates a new pane below the last one.</span><br><span class="line">  &#x27;;&#x27; creates a new pane at the top of the next column.</span><br><span class="line">  &#x27;=&#x27; followed by a string, changes the name of the last data source</span><br><span class="line">      to that string</span><br><span class="line"></span><br><span class="line">  Example: GALLIUM_HUD=&quot;cpu,fps;primitives-generated&quot;</span><br><span class="line"></span><br><span class="line">  Additionally, by prepending &#x27;.[identifier][value]&#x27; modifiers to</span><br><span class="line">  a name, it is possible to explicitly set the location and size</span><br><span class="line">  of a pane, along with limiting overall maximum value of the</span><br><span class="line">  Y axis and activating dynamic readjustment of the Y axis.</span><br><span class="line">  Several modifiers may be applied to the same pane simultaneously.</span><br><span class="line"></span><br><span class="line">  &#x27;x[value]&#x27; sets the location of the pane on the x axis relative</span><br><span class="line">             to the upper-left corner of the viewport, in pixels.</span><br><span class="line">  &#x27;y[value]&#x27; sets the location of the pane on the y axis relative</span><br><span class="line">             to the upper-left corner of the viewport, in pixels.</span><br><span class="line">  &#x27;w[value]&#x27; sets width of the graph pixels.</span><br><span class="line">  &#x27;h[value]&#x27; sets height of the graph in pixels.</span><br><span class="line">  &#x27;c[value]&#x27; sets the ceiling of the value of the Y axis.</span><br><span class="line">             If the graph needs to draw values higher than</span><br><span class="line">             the ceiling allows, the value is clamped.</span><br><span class="line">  &#x27;d&#x27; activates dynamic Y axis readjustment to set the value of</span><br><span class="line">      the Y axis to match the highest value still visible in the graph.</span><br><span class="line">  &#x27;r&#x27; resets the color counter (the next color will be green)</span><br><span class="line">  &#x27;s&#x27; sort items below graphs in descending order</span><br><span class="line"></span><br><span class="line">  If &#x27;c&#x27; and &#x27;d&#x27; modifiers are used simultaneously, both are in effect:</span><br><span class="line">  the Y axis does not go above the restriction imposed by &#x27;c&#x27; while</span><br><span class="line">  still adjusting the value of the Y axis down when appropriate.</span><br><span class="line"></span><br><span class="line">  You can change behavior of the whole HUD by adding these options at</span><br><span class="line">  the beginning of the environment variable:</span><br><span class="line">  &#x27;simple,&#x27; disables all the fancy stuff and only draws text.</span><br><span class="line"></span><br><span class="line">  Example: GALLIUM_HUD=&quot;.w256.h64.x1600.y520.d.c1000fps+cpu,.datom-count&quot;</span><br><span class="line"></span><br><span class="line">  Available names:</span><br><span class="line">    stdout (prints the counters value to stdout)</span><br><span class="line">    csv (prints the counter values to stdout as CSV, use + to separate names)</span><br><span class="line">    fps</span><br><span class="line">    frametime</span><br><span class="line">    cpu</span><br><span class="line">    cpu0</span><br><span class="line">    cpu1</span><br><span class="line">    cpu2</span><br><span class="line">    cpu3</span><br><span class="line">    cpu4</span><br><span class="line">    cpu5</span><br><span class="line">    cpu6</span><br><span class="line">    cpu7</span><br><span class="line">    cpu8</span><br><span class="line">    cpu9</span><br><span class="line">    cpu10</span><br><span class="line">    cpu11</span><br><span class="line">    samples-passed</span><br><span class="line">    primitives-generated</span><br><span class="line">    render-passes</span><br></pre></td></tr></table></figure>
<p><img src="/images/mesa-gallium/sb7-asteroids.png" alt=" 的效果" /></p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>Mesa GLX 实现</title>
    <url>/gfx/mesa-glx/</url>
    <content><![CDATA[<h1 id="glx"><a class="markdownIt-Anchor" href="#glx"></a> GLX</h1>
<p>GLX 是 Mesa 中实现的三大支持平台(EGL, GLX, GBM)之一, 原来 GLX 在 Mesa 中有 <em>xlib</em>, <em>gallium-xlib</em> 和 <em>dri</em> 三种实现，自从 <a href="https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/10153">Delete Mesa Classic</a> 后就只剩下 <em>xlib</em>，<em>dri</em> 两种实现，其中 <em>dri</em> 使用得比较多一些。</p>
<span id="more"></span>
<pre><code class="highlight mermaid">flowchart TD
    A[xlib or gallium-xlib]
    A --&gt; x11
    A --&gt; xext
    A --&gt; xcb
    B[dri]
    B --&gt; x11
    B --&gt; xext
    B --&gt; xfixes
    B --&gt; xcb-glx
    B --&gt; xcb-shm</code></pre>
<p>如果是xlib, 它的源码位于</p>
<ul>
<li>mesa/drivers/x11</li>
</ul>
<p>如果是gallium-xlib, 它的源码位于</p>
<ul>
<li>gallium/winsys/sw/xlib</li>
<li>gallium/frontends/glx/xlib</li>
<li>gallium/targets/libgl-xlib</li>
</ul>
<h1 id="xlib"><a class="markdownIt-Anchor" href="#xlib"></a> xlib</h1>
<h1 id="dri"><a class="markdownIt-Anchor" href="#dri"></a> dri</h1>
<h2 id="glxmakecurrent"><a class="markdownIt-Anchor" href="#glxmakecurrent"></a> glXMakeCurrent()</h2>
<pre><code class="highlight mermaid">sequenceDiagram
    autonumber
    participant GLX
    participant Gallium

    GLX     -&gt;&gt; GLX     : MakeContextCurrent()
    GLX     -&gt;&gt; Gallium : driUnbindContext()
    Gallium -&gt;&gt; Gallium : st_api_make_current()
    Gallium -&gt;&gt; Gallium : st_glFlush()
    opt not the first time MakeCurrent()
        GLX     -&gt;&gt; Gallium : driBindContext()
        Gallium -&gt;&gt; Gallium : st_api_make_current()
        Gallium -&gt;&gt; Gallium : st_glFlush()
        GLX     -&gt;&gt; Gallium : driDestroyContext()
        Gallium -&gt;&gt; Gallium : st_glFlush()
        Gallium -&gt;&gt; Gallium : st_context_destroy()
    end</code></pre>
<h2 id="glxswapbuffers"><a class="markdownIt-Anchor" href="#glxswapbuffers"></a> glXSwapBuffers()</h2>
<pre><code class="highlight mermaid">flowchart TD
    A[&quot;glXSwapBuffers()&quot;]
    B[&quot;driswSwapBuffers()&quot;]
    C[&quot;drisw_swap_buffers_with_damage()&quot;]
    D[&quot;drisw_copy_to_front()&quot;]
    E[&quot;drisw_present_texture()&quot;]
    F[&quot;llvmpipe_flush_frontbuffer()&quot;]
    G[&quot;dri_sw_displaytarget_display()&quot;]
    H[&quot;drisw_put_image_shm()&quot;]
    I[&quot;drisw_put_image()&quot;]

    B2[&quot;dri3_swap_buffers()&quot;]
    C2[&quot;loader_dri3_swap_buffer_msc()&quot;]
    D2[&quot;glx_dri3_flush_drawable()&quot;]
    E2[&quot;dri3_flush_present_events()&quot;]
    F2[&quot;xcb_present_pixmap()&quot;]
    G2[&quot;xcb_flush()&quot;]
    H2[&quot;dri2_invalidate_drawable()&quot;]

    A --&gt; B --&gt; C --&gt; D --&gt; E --&gt; F --&gt; G --is_shm--&gt; H
    G --&gt; I
    A --&gt; B2 --&gt; C2 --&gt; D2 --&gt; E2 --&gt; F2 --&gt; G2 --&gt; H2</code></pre>
<h1 id="glvndvendor-neutral-gl-dispatch-library"><a class="markdownIt-Anchor" href="#glvndvendor-neutral-gl-dispatch-library"></a> GLVND(Vendor Neutral GL dispatch library)</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Source Directory</th>
<th style="text-align:left">Shared libraray</th>
<th style="text-align:left">APT Package</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GLDispatch</td>
<td style="text-align:left">libGLdispatch.so.0.0.0</td>
<td style="text-align:left">libglvnd0_1.3.2-1~kylin0.20.04.2_arm64</td>
</tr>
<tr>
<td style="text-align:left">GLX</td>
<td style="text-align:left">libGLX.so.0.0.0</td>
<td style="text-align:left">libglx0_1.3.2-1~kylin0.20.04.2_arm64</td>
</tr>
<tr>
<td style="text-align:left">EGL</td>
<td style="text-align:left">libEGL.so.1.1.0</td>
<td style="text-align:left">libegl1_1.3.2-1~kylin0.20.04.2_arm64</td>
</tr>
<tr>
<td style="text-align:left">OpenGL</td>
<td style="text-align:left">libOpenGL.so.0.0.0</td>
<td style="text-align:left">libopengl0_1.3.2-1~kylin0.20.04.2_arm64</td>
</tr>
<tr>
<td style="text-align:left">GLESv1</td>
<td style="text-align:left">libGLESv1_CM.so.1.2.0</td>
<td style="text-align:left">libgles1_1.3.2-1~kylin0.20.04.2_arm64</td>
</tr>
<tr>
<td style="text-align:left">GLESv2</td>
<td style="text-align:left">libGLESv2.so.2.1.0</td>
<td style="text-align:left">libgles2_1.3.2-1~kylin0.20.04.2_arm64</td>
</tr>
<tr>
<td style="text-align:left">GL</td>
<td style="text-align:left">libGL.so.1.7.0</td>
<td style="text-align:left">libgl1_1.3.2-1~kylin0.20.04.2_arm64</td>
</tr>
</tbody>
</table>
<p>上面这些包和动态库文件都来自同一个源码库 <a href="https://gitlab.freedesktop.org/glvnd/libglvnd">glvnd/libglvnd</a>, 但它们并不是真正的 OpenGL 实现 (驱动)， 它们只是一个 <strong>Dispatch Layer</strong>, 利用 <a href="https://docs.oracle.com/cd/E19683-01/817-3677/6mj8mbtbr/index.html#chapter4-31738">Dynamic Tag <code>DT_FILTER</code></a> 实现多个 Vendor 的 OpenGL 驱动能在同一个系统上共存。 libglvnd 向用户提供环境变量</p>
<p><code>__GLX_VENDOR_LIBRARY_NAME</code></p>
<p>或</p>
<ul>
<li><code>__EGL_VENDOR_LIBRARY_FILENAMES</code></li>
<li><code>__EGL_VENDOR_LIBRARY_DIRS</code></li>
</ul>
<p>来指定运行时到底是哪个 vendor 的驱动被调用。</p>
<h1 id="mesa-的包与库"><a class="markdownIt-Anchor" href="#mesa-的包与库"></a> Mesa 的包与库</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /usr -path /usr/share -prune -o -name <span class="string">&#x27;libGL*&#x27;</span> -<span class="built_in">type</span> f -<span class="built_in">exec</span> dpkg -S &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">libglew2.2:amd64: /usr/lib/x86_64-linux-gnu/libGLEW.so.2.2.0</span><br><span class="line">libglvnd0:amd64: /usr/lib/x86_64-linux-gnu/libGLdispatch.so.0.0.0</span><br><span class="line">libglew-dev:amd64: /usr/lib/x86_64-linux-gnu/libGLEW.a</span><br><span class="line">arise-linux-graphics-driver-dri:amd64: /usr/lib/x86_64-linux-gnu/libGLX_arise.so.0.0.0</span><br><span class="line">libglx-mesa0:amd64: /usr/lib/x86_64-linux-gnu/libGLX_mesa.so.0.0.0</span><br><span class="line">libglx0:amd64: /usr/lib/x86_64-linux-gnu/libGLX.so.0.0.0</span><br><span class="line">libgles2:amd64: /usr/lib/x86_64-linux-gnu/libGLESv2.so.2.1.0</span><br><span class="line">libgles1:amd64: /usr/lib/x86_64-linux-gnu/libGLESv1_CM.so.1.2.0</span><br><span class="line">libgl1:amd64: /usr/lib/x86_64-linux-gnu/libGL.so.1.7.0</span><br><span class="line">libglu1-mesa:amd64: /usr/lib/x86_64-linux-gnu/libGLU.so.1.3.1</span><br><span class="line">libglu1-mesa-dev:amd64: /usr/lib/x86_64-linux-gnu/libGLU.a</span><br></pre></td></tr></table></figure>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://docs.oracle.com/cd/E19683-01/817-3677/chapter6-42444/index.html">Dynamic Linking/Dynamic Section</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>Mesa 对 LLVM 的依赖</title>
    <url>/gfx/mesa-llvm/</url>
    <content><![CDATA[<h1 id="llvm-和-mesa-简介"><a class="markdownIt-Anchor" href="#llvm-和-mesa-简介"></a> LLVM 和 Mesa 简介</h1>
<h2 id="llvm-low-level-virtual-machine"><a class="markdownIt-Anchor" href="#llvm-low-level-virtual-machine"></a> LLVM (Low-Level Virtual Machine)</h2>
<span id="more"></span>
<h2 id="mesa"><a class="markdownIt-Anchor" href="#mesa"></a> Mesa</h2>
<p>Mesa 是 GPU 驱动的 UMD 部分（开源，遵循 MIT 开源协议). 它支持的 API 有 OpenGL, OpenCL, Vulkan, VAAPI, VDPAU 等</p>
<h1 id="mesa-中的驱动对-llvm-的依赖"><a class="markdownIt-Anchor" href="#mesa-中的驱动对-llvm-的依赖"></a> Mesa 中的驱动对 LLVM 的依赖</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Mesa driver</th>
<th style="text-align:center">dependent LLVM version</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>vulkan-drivers=amd</code></td>
<td style="text-align:center">15.0.0+</td>
</tr>
<tr>
<td style="text-align:left"><code>gallium-drivers=radeonsi</code></td>
<td style="text-align:center">15.0.0+</td>
</tr>
<tr>
<td style="text-align:left"><code>intel-clc=enabled</code></td>
<td style="text-align:center">13.0.0+</td>
</tr>
<tr>
<td style="text-align:left"><code>gallium-opencl=icd</code></td>
<td style="text-align:center">11.0.0+</td>
</tr>
<tr>
<td style="text-align:left"><code>microsoft-clc=enabled</code></td>
<td style="text-align:center">10.0.0+</td>
</tr>
<tr>
<td style="text-align:left"><code>gallium-drivers=swrast</code> and <code>llvm=enabled</code></td>
<td style="text-align:center">5.0.0+</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Mesa</title>
    <url>/gfx/mesa/</url>
    <content><![CDATA[<h1 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h1>
<p>Mesa 包含了各种 GPU/CPU 的 OpenGL, OpenCL, Vulkan 实现(Usermode Driver), 也包括 GLX, EGL, GBM 等协议的实现。</p>
<ul>
<li>Vulkan 驱动</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">codename</th>
<th style="text-align:left">directories</th>
<th style="text-align:left">platforms</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">anv</td>
<td style="text-align:left">src/intel/vulkan, src/intel/vulkan_hasvk</td>
<td style="text-align:left">Alder Lake-P</td>
</tr>
<tr>
<td style="text-align:left">asahi</td>
<td style="text-align:left">src/asahi/vulkan</td>
<td style="text-align:left">Apple M1, M2</td>
</tr>
<tr>
<td style="text-align:left">lpv</td>
<td style="text-align:left">src/gallium/drivers/llvmpipe</td>
<td style="text-align:left">CPU</td>
</tr>
<tr>
<td style="text-align:left">panvk</td>
<td style="text-align:left">src/panfrost/vulkan</td>
<td style="text-align:left">RK3399</td>
</tr>
<tr>
<td style="text-align:left">v3dv</td>
<td style="text-align:left">src/broadcom/vulkan</td>
<td style="text-align:left">Raspberry Pi</td>
</tr>
</tbody>
</table>
<h1 id="build"><a class="markdownIt-Anchor" href="#build"></a> Build</h1>
<h2 id="build-dependencies-since-mesa-2500"><a class="markdownIt-Anchor" href="#build-dependencies-since-mesa-2500"></a> Build Dependencies (since mesa-25.0.0)</h2>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">dep</th>
<th style="text-align:left">apt-get</th>
<th style="text-align:left">version required</th>
<th style="text-align:left">yet another install</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">/usr/bin/glslangValidator</td>
<td style="text-align:left">glslang-tools</td>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://github.com/KhronosGroup/glslang">https://github.com/KhronosGroup/glslang</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">/usr/bin/rustc</td>
<td style="text-align:left">rustc</td>
<td style="text-align:left">1.78.0 or newer</td>
<td style="text-align:left">`curl --proto ‘=https’ --tlsv1.2 -sSf <a href="https://sh.rustup.rs">https://sh.rustup.rs</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">bindgen (rust package)</td>
<td style="text-align:left">cargo</td>
<td style="text-align:left">0.65 or newer</td>
<td style="text-align:left"><code>cargo install bindgen-cli</code></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">libclc-dev</td>
<td style="text-align:left">libclc-17-dev</td>
<td style="text-align:left"></td>
<td style="text-align:left">not required if -Dmesa-clc=auto</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">libdrm</td>
<td style="text-align:left">libdrm-dev</td>
<td style="text-align:left">2.4.121(120 ok2.0)</td>
<td style="text-align:left"><a href="https://gitlab.freedesktop.org/mesa/drm">https://gitlab.freedesktop.org/mesa/drm</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">llvm</td>
<td style="text-align:left">llvm-17-dev</td>
<td style="text-align:left">(17.0.6 ok2.0)</td>
<td style="text-align:left"><a href="https://github.com/llvm/llvm-project">https://github.com/llvm/llvm-project</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">libLLVMSPIRVLib.so.17</td>
<td style="text-align:left">llvm-spirv-17</td>
<td style="text-align:left">(17.0.0 ok2.0)</td>
<td style="text-align:left"><a href="https://github.com/KhronosGroup/SPIRV-LLVM-Translator">https://github.com/KhronosGroup/SPIRV-LLVM-Translator</a></td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">LLVMSPIRVLib.h</td>
<td style="text-align:left">llvmspirvlib-17-dev</td>
<td style="text-align:left">(absent ok2.0)</td>
<td style="text-align:left"><a href="https://github.com/KhronosGroup/SPIRV-LLVM-Translator">https://github.com/KhronosGroup/SPIRV-LLVM-Translator</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">clang-cpp</td>
<td style="text-align:left">libclang-cpp17-dev</td>
<td style="text-align:left">(17.0.6 ok2.0)</td>
<td style="text-align:left">not required if -Dmesa-clc=auto</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">clang-dev</td>
<td style="text-align:left">libclang-17-dev</td>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://gitlab.freedesktop.org/mesa/mesa/-/issues/10485">Debian package issue</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">xshmfence</td>
<td style="text-align:left">libxshmfence-dev</td>
<td style="text-align:left">(1.3    ok2.0)</td>
<td style="text-align:left">required if -Dplatforms=x11</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">xxf86vm</td>
<td style="text-align:left">libxxf86vm-dev</td>
<td style="text-align:left">(1.1.4  ok2.0)</td>
<td style="text-align:left">required since -Dglx-direct=true by default</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">xrandr</td>
<td style="text-align:left">libxrandr-dev</td>
<td style="text-align:left">(1.5.2  ok2.0)</td>
<td style="text-align:left">required since -Dxlib-lease=true</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">cbindgen (rust package)</td>
<td style="text-align:left">cargo</td>
<td style="text-align:left">0.28.0</td>
<td style="text-align:left"><code>cargo install cbindgen</code>; required if -Dgallium-drivers=nouveau</td>
</tr>
</tbody>
</table>
<p>NOTE:</p>
<ul>
<li>
<p>(*) 表示本来不需要的依赖</p>
</li>
<li>
<p>(+) 在 OpenKylin 2.0 的源里没有，需要源码构建</p>
</li>
<li>
<p>Ubuntu 22.04</p>
</li>
</ul>
<p><strong>书到用时方恨少，包要装时不好找</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y cmake ninja-build bison flex g++ git pkg-config python3-setuptools python3-lz4 \</span><br><span class="line">    python3-jinja2 libssl-dev libelf-dev libboost-dev libglm-dev libtinyobjloader-dev libstb-dev \</span><br><span class="line">    libpng-dev wayland-protocols libwayland-dev libdecor-0-dev freeglut3-dev libglfw3-dev libexpat1-dev libglvnd-dev \</span><br><span class="line">    libx11-dev libxext-dev libxshmfence-dev libxrandr-dev libxxf86vm-dev libxfixes-dev libx11-xcb-dev \</span><br><span class="line">    libxcb1-dev libxcb-randr0-dev libxcb-glx0-dev libxcb-shm0-dev libxcb-dri3-dev libxcb-dri2-0-dev libxcb-present-dev \</span><br><span class="line">    libselinux1-dev libvulkan-dev vulkan-tools mesa-utils</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meson build -Dprefix=/usr/local -Dlibdir=lib/x86_64-linux-gnu -Dplatforms=x11 -Dgallium-drivers=nouveau</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-Dprefix=/usr/local</code> 避免覆盖系统原来的 <code>libGL*</code></li>
<li><code>-Dlibdir=lib/x86_64-linux-gnu</code> 设置库的安装路径为 <code>/etc/ld.so.conf.d/x86_64-linux-gnu.conf</code> 中搜索<strong>第一顺位</strong>的路径</li>
<li>其他默认就好， 出现的依赖在 OpenKylin 2.0 上 apt-get 基本都能解决</li>
</ul>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Build targets in project: 437</span><br><span class="line">WARNING: Project specifies a minimum meson_version &#x27;&gt;= 1.1.0&#x27; but uses features which were added in newer versions:</span><br><span class="line"> * 1.3.0: &#123;&#x27;rust.proc_macro&#x27;, &#x27;rust_abi arg in static_library&#x27;&#125;</span><br><span class="line"></span><br><span class="line">mesa 25.0.0-devel</span><br><span class="line"></span><br><span class="line">  Directories</span><br><span class="line">    prefix                       : /usr/local</span><br><span class="line">    libdir                       : lib/x86_64-linux-gnu</span><br><span class="line">    includedir                   : include</span><br><span class="line"></span><br><span class="line">  Common C and C++ arguments</span><br><span class="line">    c_cpp_args                   : -mtls-dialect=gnu2</span><br><span class="line"></span><br><span class="line">  OpenGL</span><br><span class="line">    OpenGL                       : YES</span><br><span class="line">    ES1                          : YES</span><br><span class="line">    ES2                          : YES</span><br><span class="line">    Shared glapi                 : YES</span><br><span class="line">    GLVND                        : YES</span><br><span class="line"></span><br><span class="line">  DRI</span><br><span class="line">    Platform                     : drm</span><br><span class="line">    Driver dir                   : /usr/local/lib/x86_64-linux-gnu/dri</span><br><span class="line"></span><br><span class="line">  GLX</span><br><span class="line">    Enabled                      : YES</span><br><span class="line">    Provider                     : dri</span><br><span class="line"></span><br><span class="line">  EGL</span><br><span class="line">    Enabled                      : YES</span><br><span class="line">    Drivers                      : builtin:egl_dri2 builtin:egl_dri3</span><br><span class="line">    Platforms                    : x11 surfaceless drm xcb</span><br><span class="line"></span><br><span class="line">  GBM</span><br><span class="line">    Enabled                      : YES</span><br><span class="line">    Backends path                : /usr/local/lib/x86_64-linux-gnu/gbm</span><br><span class="line"></span><br><span class="line">  Vulkan</span><br><span class="line">    Drivers                      : amd intel intel_hasvk nouveau swrast</span><br><span class="line">    Platforms                    : x11 surfaceless drm xcb</span><br><span class="line">    ICD dir                      : share/vulkan/icd.d</span><br><span class="line">    Intel Ray tracing            : YES</span><br><span class="line"></span><br><span class="line">  Video</span><br><span class="line">    Codecs                       : av1dec av1enc vp9dec</span><br><span class="line">    APIs                         : vulkan xa</span><br><span class="line"></span><br><span class="line">  LLVM</span><br><span class="line">    Enabled                      : YES</span><br><span class="line">    Version                      : 17.0.6</span><br><span class="line"></span><br><span class="line">  Gallium</span><br><span class="line">    Enabled                      : YES</span><br><span class="line">    Drivers                      : nouveau</span><br><span class="line">    Platforms                    : x11 surfaceless drm xcb</span><br><span class="line">    Frontends                    : mesa xa</span><br><span class="line">    Off-screen rendering (OSMesa): NO</span><br><span class="line">    HUD lm-sensors               : NO</span><br><span class="line"></span><br><span class="line">  Perfetto</span><br><span class="line">    Enabled                      : NO</span><br><span class="line"></span><br><span class="line">  Teflon (TensorFlow Lite delegate)</span><br><span class="line">    Enabled                      : NO</span><br><span class="line"></span><br><span class="line">  Subprojects</span><br><span class="line">    paste                        : YES</span><br><span class="line">    proc-macro2                  : YES (from syn =&gt; quote)</span><br><span class="line">    quote                        : YES (from syn)</span><br><span class="line">    syn                          : YES</span><br><span class="line">    unicode-ident                : YES (from syn)</span><br><span class="line"></span><br><span class="line">  User defined options</span><br><span class="line">    libdir                       : lib/x86_64-linux-gnu</span><br><span class="line">    prefix                       : /usr/local</span><br><span class="line">    gallium-drivers              : nouveau</span><br><span class="line">    platforms                    : x11</span><br><span class="line"></span><br><span class="line">Found ninja-1.11.1 at /usr/bin/ninja</span><br><span class="line">WARNING: Running the setup command as `meson [options]` instead of `meson setup [options]` is ambiguous and deprecated.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>After compilation and installed as follow:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /usr/local/lib/x86_64-linux-gnu</span><br><span class="line">total 159360</span><br><span class="line">lrwxrwxrwx 1 root root        10 Feb  7 17:13 libGL.so -&gt; libGL.so.1</span><br><span class="line">lrwxrwxrwx 1 root root        14 Feb  7 17:13 libGL.so.1 -&gt; libGL.so.1.5.0</span><br><span class="line">-rwxr-xr-x 1 root root 111044912 Feb  7 17:13 libGL.so.1.5.0</span><br><span class="line">lrwxrwxrwx 1 root root        14 Feb  7 17:13 libOSMesa.so -&gt; libOSMesa.so.8</span><br><span class="line">lrwxrwxrwx 1 root root        18 Feb  7 17:13 libOSMesa.so.8 -&gt; libOSMesa.so.8.0.0</span><br><span class="line">-rwxr-xr-x 1 root root  51541176 Feb  7 17:13 libOSMesa.so.8.0.0</span><br><span class="line">lrwxrwxrwx 1 root root        13 Feb  7 17:13 libglapi.so -&gt; libglapi.so.0</span><br><span class="line">lrwxrwxrwx 1 root root        17 Feb  7 17:13 libglapi.so.0 -&gt; libglapi.so.0.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    337264 Feb  7 17:07 libglapi.so.0.0.0</span><br><span class="line">drwxr-xr-x 1 root root       512 Feb  7 17:13 pkgconfig</span><br></pre></td></tr></table></figure>
<p>NOTE:</p>
<ul>
<li>Mesa is installed in <code>/usr/local/lib/$(uname -p)-linux-gnu</code> by default. So you have to <code>ldconfig</code> so that your linker can find them.</li>
<li>libsoftpipe.a will be built but not installed.</li>
<li>meson build system will enable compiler’s <code>-g</code> flag by default unless you are building on the release branch.</li>
<li>if you have remodified the <strong>meson_options.txt</strong> and built once and now are about to reconfigure and rebuild, you need to run:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meson setup --wipe build</span><br></pre></td></tr></table></figure>
<h1 id="与-mesa-相关的一些常用软件包"><a class="markdownIt-Anchor" href="#与-mesa-相关的一些常用软件包"></a> 与 mesa 相关的一些常用软件包</h1>
<h2 id="mesa-utils"><a class="markdownIt-Anchor" href="#mesa-utils"></a> mesa-utils</h2>
<p>包含以下 glx demo 或 test program</p>
<ul>
<li>glxdemo</li>
<li>glxgears</li>
<li>glxheads</li>
<li>glxinfo</li>
</ul>
<h2 id="mesa-utils-extra"><a class="markdownIt-Anchor" href="#mesa-utils-extra"></a> mesa-utils-extra</h2>
<p>包含以下 egl demo 或 test program</p>
<ul>
<li>eglinfo</li>
<li>es2_info</li>
<li>es2gears_wayland</li>
<li>es2gears_x11</li>
<li>es2tri</li>
</ul>
<h1 id="off-screen-demos"><a class="markdownIt-Anchor" href="#off-screen-demos"></a> Off-screen Demos</h1>
<p>Now that mesa have been built and installed we can give a try to run an OGL application. Similarly without window system supportd on the WSL, <a href="https://mesa3d.org/osmesa.html">off-screen rendering</a> is my choice. We can clone the mesa <a href="https://gitlab.freedesktop.org/mesa/demos">demos</a> which includes a lot of demos besides off-screen demos.</p>
<h2 id="requisite"><a class="markdownIt-Anchor" href="#requisite"></a> Requisite</h2>
<p>We need some more libraries besides libOSMesa and libGL before you can get these off-screen demos worked. They are:</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/mesa/glu">GLU</a></li>
<li>libm</li>
</ul>
<p>To build these demos:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc osdemo.c -o osdemo -g -I/home/luc/github/demos/src/util -lGL -lGLU -lOSMesa -lm</span><br></pre></td></tr></table></figure>
<p>The executable osdemo saves the rendered pixels as the portable pixmap format. You need to covert it to image format e.g. jpg. You may do this with <code>pnmtojpeg output.ppm &gt; output.jpg</code>.</p>
<div align=center><img src="/gfx/mesa/osdemo.jpg" class="" title="osdemo"></div>
<h2 id="osmesa-call-graphs"><a class="markdownIt-Anchor" href="#osmesa-call-graphs"></a> OSMesa Call Graphs</h2>
<p>Mesa supports many features from software pipelines to hardware drivers. For example <a href="https://www.freedesktop.org/wiki/Software/gallium/">Gallium</a>, it features with several software or hardware implementations which include the two software pipelines, softpipe and <a href="https://www.mesa3d.org/llvmpipe.html">llvmpipe</a>. With the different pipes enabled will the calls walk in the different paths.</p>
<h2 id="three-different-build-configuration-reference-to-meson_optionstxt"><a class="markdownIt-Anchor" href="#three-different-build-configuration-reference-to-meson_optionstxt"></a> Three Different Build Configuration (reference to <strong>meson_options.txt</strong>)</h2>
<table>
<thead>
<tr>
<th>Option</th>
<th><em>platform</em></th>
<th><em>glx</em></th>
<th><em>dri-drivers</em></th>
<th><em>gallium-drivers</em></th>
<th><em>llvm</em></th>
<th><em>osmesa</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>llvmpipe</strong></td>
<td>x11</td>
<td>gallium-xlib</td>
<td></td>
<td>swrast</td>
<td>true</td>
<td>gallium</td>
</tr>
<tr>
<td><strong>softpipe</strong></td>
<td>x11</td>
<td>gallium-xlib</td>
<td></td>
<td>swrast</td>
<td>false</td>
<td>gallium</td>
</tr>
<tr>
<td><strong>tnl</strong></td>
<td>x11</td>
<td>gallium-xlib</td>
<td></td>
<td>swrast</td>
<td>true</td>
<td>classic</td>
</tr>
</tbody>
</table>
<h2 id="three-different-call-paths"><a class="markdownIt-Anchor" href="#three-different-call-paths"></a> Three Different Call Paths</h2>
<h3 id="context"><a class="markdownIt-Anchor" href="#context"></a> Context</h3>
<div align=center><img src="/gfx/mesa/OSMesaCreateContextExt.png" class="" title="context initialization"></div>
<p>NOTE: As for softpipe and llvmpipe <code>gl_api</code> and <code>gl_context</code> are created respectively while both of them are created in one path for the classic osmesa.</p>
<h3 id="draw"><a class="markdownIt-Anchor" href="#draw"></a> Draw</h3>
<div align=center><img src="/gfx/mesa/PopMatrix.png" class="" title="draw command"></div>
<h1 id="gallium-based-glx-demos"><a class="markdownIt-Anchor" href="#gallium-based-glx-demos"></a> Gallium-Based GLX Demos</h1>
<p>If you want to know the full graphic stack of an OpenGL demo, you can not get rid of the window system. That is why I will try some GLX demos. Evidently GLX demos must depend on X11. You can cope with this problem by installing <a href="https://sourceforge.net/projects/vcxsrv/">vcXsrv</a> on the Windows 10 which hosts your WSL.</p>
<div align=center><img src="/gfx/mesa/glxgears.png" class="" title="glx demo"></div>
<p>This time I still choose the gallium-xlib with softpipe. The following call graph shows the path that GLX context is created.</p>
<div align=center><img src="/gfx/mesa/glXCreateContext.png" class="" title="glx context creation"></div>
<p>As we know, Mesa is quite modularized and flexible. How does it take the path that <code>softpipe_create_context</code> rather than other pipe contexts? The <a href="https://gitlab.freedesktop.org/mesa/mesa/blob/master/src/gallium/include/state_tracker/st_api.h">st_manager</a> is a key structure.</p>
<p><code>struct pipe_screen</code> has a callback function that will be set to <code>softpipe_create_context</code>. The following calls will create <code>struct pipe_screen</code> that will be set to the <code>st_manager</code>.</p>
<div align=center><img src="/gfx/mesa/glXChooseVisual.png" class="" title="pipe_screen creation"></div>
<p>To bind the intended gallium driver backend to Mesa there must be something done before <code>glXChooseVisual</code> is called. It’s started by the library <code>init()</code> and prepare the global variables.</p>
<p><a href="https://gitlab.freedesktop.org/mesa/mesa/blob/master/src/gallium/state_trackers/glx/xlib/xm_public.h">xm_public.h</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is the driver interface required by the glx/xlib state tracker. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xm_driver</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pipe_screen</span> *(*<span class="title">create_pipe_screen</span>)( <span class="title">Display</span> *<span class="title">display</span> );</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">st_api</span> *(*<span class="title">create_st_api</span>)( <span class="title">void</span> );</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">xmesa_set_driver</span><span class="params">( <span class="type">const</span> <span class="keyword">struct</span> xm_driver *driver )</span>;</span><br></pre></td></tr></table></figure>
<h1 id="dri-based-glx-demos"><a class="markdownIt-Anchor" href="#dri-based-glx-demos"></a> DRI-Based GLX Demos</h1>
<h2 id="loading"><a class="markdownIt-Anchor" href="#loading"></a> Loading</h2>
<ul>
<li><code>__glXInitialize</code></li>
<li><code>driOpenDriver</code></li>
</ul>
<p>This process of loading drivers works similarly with that of gallium-based glx. Compilation macros and environment variables make a difference. There are several approaches to load the specific drivers:</p>
<ul>
<li><code>dri3_create_display</code></li>
<li><code>dri2CreateDisplay</code></li>
<li><code>driCreateDisplay</code></li>
<li><code>driswCreateDisplay</code></li>
<li><code>applegl_create_display</code></li>
<li><code>driwindowsCreateDisplay</code></li>
</ul>
<p>Let’s look into <code>driCreateDisplay</code>. Once it manages to attach to <code>driCreateScreen</code> which searches and matches the appropriate gallium driver the function <code>driOpenDriver</code> will open the <strong>found</strong> driver by its name like “i965”, “radeon”, “nouveau”, etc. These drivers are supposed to be installed at <strong><code>LIBGL_DRIVERS_PATH</code></strong> or <code>LIBGL_DRIVERS_DIR</code>(deprecated) and named as <code>*_dri.so</code> by default.</p>
<p>Like Gallium-based GLX’s <code>_init</code> routine with GCC <strong><code>constructor</code></strong> attribute, DRI-based GLX also defines a routine <code>megadriver_stub_init</code> with <code>constructor</code> attribute which allows to load the specific driver in a way of <strong><code>__DRIextension</code></strong>.</p>
<div align=center><img src="/gfx/mesa/gdb.svg" class="" title="osdemo"></div>
<h2 id="contexts"><a class="markdownIt-Anchor" href="#contexts"></a> Contexts</h2>
<p>There are a variety of <strong>contexts</strong> in Mesa. They are designed as a framework of layers.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__________________</span><br><span class="line">|                |</span><br><span class="line">|   gl_contex    | --------------&gt; standard &amp; general</span><br><span class="line">|________________|</span><br><span class="line"></span><br><span class="line">__________________</span><br><span class="line">|                |</span><br><span class="line">|   st_contex    | --------------&gt; adapter</span><br><span class="line">|________________|</span><br><span class="line"></span><br><span class="line">__________________</span><br><span class="line">|                |</span><br><span class="line">|  draw_contex   | --------------&gt; driver-specific</span><br><span class="line">|________________|</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="gl_context"><a class="markdownIt-Anchor" href="#gl_context"></a> gl_context</h3>
<blockquote><p>This is the central context data structure for Mesa. Almost all OpenGL state is contained in this structure. Think of this as a base class from which device drivers will derive sub classes.</p>
</blockquote>
<p>Apart from OpenGL state it contains several other contexts</p>
<ul>
<li><code>swrast_context</code></li>
<li><code>swsetup_context</code></li>
<li><code>swtnl_context</code></li>
<li><code>vbo_context</code></li>
<li><code>st_context</code></li>
</ul>
<h3 id="st_context"><a class="markdownIt-Anchor" href="#st_context"></a> st_context</h3>
<h3 id="draw_context"><a class="markdownIt-Anchor" href="#draw_context"></a> draw_context</h3>
<h3 id="vbo_context"><a class="markdownIt-Anchor" href="#vbo_context"></a> vbo_context</h3>
<p>VBO is short for vertex buffer object. This context derives two kinds of vbo contexts, <code>vbo_exec_context</code> and <code>vbo_save_context</code> which <code>vbo_exec_context</code> is generic for core and compatible ogl and the other is specific for compatible ogl.</p>
<h4 id="vbo_exec_vtx_init"><a class="markdownIt-Anchor" href="#vbo_exec_vtx_init"></a> vbo_exec_vtx_init</h4>
<ul>
<li>Allocate a <code>gl_buffer_object</code> which just is referenced.</li>
<li>Initialize vbo attributes including size, type and active size.</li>
</ul>
<h4 id="vbo-vs-vao"><a class="markdownIt-Anchor" href="#vbo-vs-vao"></a> vbo vs. vao</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gl_buffer_object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   GLint RefCount;</span><br><span class="line">   GLuint Name;</span><br><span class="line">   GLchar *Label;       </span><br><span class="line">   GLenum16 Usage;      </span><br><span class="line">   GLbitfield StorageFlags; </span><br><span class="line">   GLsizeiptrARB Size;  </span><br><span class="line">   GLubyte *Data;       </span><br><span class="line">   GLboolean DeletePending;   </span><br><span class="line">   GLboolean Written;   </span><br><span class="line">   GLboolean Purgeable; </span><br><span class="line">   GLboolean Immutable; </span><br><span class="line">   gl_buffer_usage UsageHistory; </span><br><span class="line">   GLuint NumSubDataCalls;</span><br><span class="line">   GLuint NumMapBufferWriteCalls;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">gl_buffer_mapping</span> <span class="title">Mappings</span>[<span class="title">MAP_COUNT</span>];</span></span><br><span class="line">   <span class="type">simple_mtx_t</span> MinMaxCacheMutex;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> *<span class="title">MinMaxCache</span>;</span></span><br><span class="line">   <span class="type">unsigned</span> MinMaxCacheHitIndices;</span><br><span class="line">   <span class="type">unsigned</span> MinMaxCacheMissIndices;</span><br><span class="line">   <span class="type">bool</span> MinMaxCacheDirty;</span><br><span class="line">   <span class="type">bool</span> HandleAllocated; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gl_vertex_array_object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   GLuint Name;</span><br><span class="line">   GLint RefCount;</span><br><span class="line">   GLchar *Label;       </span><br><span class="line">   GLboolean EverBound;</span><br><span class="line">   <span class="type">bool</span> SharedAndImmutable;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">gl_array_attributes</span> <span class="title">VertexAttrib</span>[<span class="title">VERT_ATTRIB_MAX</span>];</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">gl_vertex_buffer_binding</span> <span class="title">BufferBinding</span>[<span class="title">VERT_ATTRIB_MAX</span>];</span></span><br><span class="line">   GLbitfield VertexAttribBufferMask;</span><br><span class="line">   GLbitfield Enabled;</span><br><span class="line">   GLbitfield _EffEnabledVBO;</span><br><span class="line">   gl_attribute_map_mode _AttributeMapMode;</span><br><span class="line">   GLbitfield NewArrays;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">gl_buffer_object</span> *<span class="title">IndexBufferObj</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="dispatchers"><a class="markdownIt-Anchor" href="#dispatchers"></a> Dispatchers</h2>
<ul>
<li><em><code>Exec</code></em>: The current dispatch table for non-displaylist-saving execution, either BeginEnd or OutsideBeginEnd</li>
<li><em><code>OutsideBeginEnd</code></em>: The normal dispatch table for non-displaylist-saving, non-begin/end</li>
<li><em><code>Save</code></em>: The dispatch table used between glNewList() and glEndList()</li>
<li><em><code>BeginEnd</code></em>: The dispatch table used between glBegin() and glEnd() (outside of a display list). Only valid functions between those two are set, which is mostly just the set in a GLvertexformat struct.</li>
<li><em><code>ContextLost</code></em>: Dispatch table for when a graphics reset has happened.</li>
<li><em><code>MarshalExec</code></em>: Dispatch table used to marshal API calls from the client program to a separate server thread. NULL if API calls are not being marshalled to another thread.</li>
<li><em><code>CurrentClientDispatch</code></em>: Dispatch table currently in use for fielding API calls from the client program. If API calls are being marshalled to another thread, this refers to <em><code>MarshalExec</code></em>. Otherwise it refers to <em><code>CurrentServerDispatch</code></em>.</li>
<li><em><code>CurrentServerDispatch</code></em>: Dispatch table currently in use for performing API calls. It refers to <em><code>Save</code></em> or <em><code>Exec</code></em>.</li>
</ul>
<h2 id="modules"><a class="markdownIt-Anchor" href="#modules"></a> Modules</h2>
<ul>
<li>draw module</li>
<li>CSO module</li>
<li>translate module</li>
<li>VBO module</li>
<li>TNL module(Transform &amp; Light)</li>
</ul>
<h2 id="draw_xxx_stage"><a class="markdownIt-Anchor" href="#draw_xxx_stage"></a> draw_xxx_stage</h2>
<ul>
<li><strong><code>extern struct draw_stage *draw_unfilled_stage( struct draw_context *context );</code></strong></li>
<li><strong><code>extern struct draw_stage *draw_twoside_stage( struct draw_context *context );</code></strong></li>
<li><strong><code>extern struct draw_stage *draw_offset_stage( struct draw_context *context );</code></strong></li>
<li><strong><code>extern struct draw_stage *draw_clip_stage( struct draw_context *context );</code></strong></li>
<li><strong><code>extern struct draw_stage *draw_flatshade_stage( struct draw_context *context );</code></strong></li>
<li><strong><code>extern struct draw_stage *draw_cull_stage( struct draw_context *context );</code></strong></li>
<li><strong><code>extern struct draw_stage *draw_stipple_stage( struct draw_context *context );</code></strong></li>
<li><strong><code>extern struct draw_stage *draw_wide_line_stage( struct draw_context *context );</code></strong></li>
<li><strong><code>extern struct draw_stage *draw_wide_point_stage( struct draw_context *context );</code></strong></li>
<li><strong><code>extern struct draw_stage *draw_validate_stage( struct draw_context *context );</code></strong></li>
</ul>
<h2 id="auxiliary"><a class="markdownIt-Anchor" href="#auxiliary"></a> Auxiliary</h2>
<ul>
<li>
<p>cso_cache<br />
The CSO cache is used to accelerate preparation of state by saving driver-specific state structure for later use.</p>
</li>
<li>
<p>draw<br />
Draw is a software TCL pipeline for hardware that lacks vertex shaders or other essential parts of pre-rasterization vertex preparation.</p>
</li>
<li>
<p>driver_ddebug</p>
</li>
<li>
<p>driver_noop</p>
</li>
<li>
<p>driver_rbug</p>
</li>
<li>
<p>driver_trace</p>
</li>
<li>
<p>gallivm</p>
</li>
<li>
<p>hud</p>
</li>
<li>
<p>indices<br />
Indices provides tools for translating or generating element indices for use with element-based rendering.</p>
</li>
<li>
<p>nir</p>
</li>
<li>
<p>os</p>
<ul>
<li>memory allocation</li>
<li>simple message logging</li>
<li>obtaining run-time configuration option</li>
<li>threading primitives<br />
The OS module contains the abstraction for basic operating system services above. This is the bare minimum required to port Gallium to a new platform. It already provides the implementations of these abstractions for the most common platforms. When targeting an embedded platform no implementation will be provided - these must be provided separately.</li>
</ul>
</li>
<li>
<p>pipe-loader</p>
</li>
<li>
<p>pipebuffer</p>
</li>
<li>
<p>postprocess</p>
</li>
<li>
<p>rbug</p>
</li>
<li>
<p>renderonly</p>
</li>
<li>
<p>rtasm</p>
</li>
<li>
<p>target-helpers</p>
</li>
<li>
<p>tgsi</p>
</li>
<li>
<p>translate</p>
</li>
<li>
<p>util</p>
</li>
<li>
<p>vl</p>
</li>
</ul>
<h1 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h1>
<ul>
<li>When xlib creates pipe screen, <em>only</em> software rasterizers or pipes’screen are created. And llvmpipe, softpipe, virgl, swr, unexceptionally, are software rasterizers or virtual GPU. <a href="https://www.collabora.com/news-and-blog/blog/2018/10/31/introducing-zink-opengl-implementation-vulkan/">Zink</a> is, in brief, a translator from OpenGL to Vulkan and implemented as Gallium driver. So why only software pipes?</li>
</ul>
<p>The answer is <strong><code>sw_winsys</code></strong>. All of target helpers’s parameter is a <code>sw_winsys</code>. Check mesa source directory: <a href="https://gitlab.freedesktop.org/mesa/mesa/tree/master/src/gallium/winsys">mesa/src/gallium/winsys</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">amdgpu</span><br><span class="line">etnaviv</span><br><span class="line">freedreno</span><br><span class="line">i915</span><br><span class="line">iris</span><br><span class="line">kmsro</span><br><span class="line">lima</span><br><span class="line">nouveau</span><br><span class="line">panfrost</span><br><span class="line">radeon</span><br><span class="line">svga</span><br><span class="line">sw</span><br><span class="line">tegra</span><br><span class="line">v3d</span><br><span class="line">vc4</span><br><span class="line">virgl</span><br></pre></td></tr></table></figure>
<p>To put it simply, specific driver corresponds to specific winsys. The <code>sw</code> is for software rasterizers. If you expect to create pipe screen for some driver else, you need to add another target helper with its winsys as parameter like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline struct pipe_screen *</span><br><span class="line">i915_screen_create_named(struct i915_drm_winsys *winsys, const char *driver)</span><br></pre></td></tr></table></figure>
<p>That means you have to declare a bunch of new interfaces from the top. So you’d better wrap the function to create specific driver’s winsys so that it can take a sw_winsys as its parameter like:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if defined(GALLIUM_VIRGL)</span><br><span class="line">   if (screen == NULL &amp;&amp; strcmp(driver, &quot;virpipe&quot;) == 0) &#123;</span><br><span class="line">      struct virgl_winsys *vws;</span><br><span class="line">      vws = virgl_vtest_winsys_wrap(winsys);</span><br><span class="line">      screen = virgl_create_screen(vws, NULL);</span><br><span class="line">   &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://libGL.so">libGL.so</a> is not built until glx option is enabled in <strong>meson_options.txt</strong>.</li>
</ul>
<p>Only with essential build-time dependencies for X11 installed and glx option configured is <a href="http://libGL.so">libGL.so</a> built.</p>
<ul>
<li>What role do DRM, DRI and Gallium play in Mesa?</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_libdrm_checks = [</span><br><span class="line">  [&#x27;intel&#x27;, with_dri_i915 or with_gallium_i915],</span><br><span class="line">  [&#x27;amdgpu&#x27;, with_amd_vk or with_gallium_radeonsi],</span><br><span class="line">  [&#x27;radeon&#x27;, (with_gallium_radeonsi or with_dri_r100 or with_dri_r200 or</span><br><span class="line">              with_gallium_r300 or with_gallium_r600)],</span><br><span class="line">  [&#x27;nouveau&#x27;, (with_gallium_nouveau or with_dri_nouveau)],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>DRI and Gallium seem to be respectively different underlying implementation in Mesa. Moreover in term of swrast and i915, you have to choose either of both as you can read the following code snippet in meson.build. In fact DRI is more complicated and staler but Gallium is more smaller and simpler.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if with_dri_swrast and (with_gallium_softpipe or with_gallium_swr)</span><br><span class="line">  error(&#x27;Only one swrast provider can be built&#x27;)</span><br><span class="line">endif</span><br><span class="line">if with_dri_i915 and with_gallium_i915</span><br><span class="line">  error(&#x27;Only one i915 provider can be built&#x27;)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>What problems are encountered when you build mesa on the WSL?</p>
</li>
<li>
<p>dri based GLX requires shared-glapi</p>
</li>
<li>
<p>Gallium-xlib based GLX requires softpipe or llvmpipe</p>
<ul>
<li>means that <code>gallium-xlib</code> is supposed to only support software rasterizers(llvmpipe, softpipe) and virtual GPU(virgl, swr).</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option(</span><br><span class="line">  &#x27;glx&#x27;,</span><br><span class="line">  type : &#x27;combo&#x27;,</span><br><span class="line">  value : &#x27;xlib&#x27;,</span><br><span class="line">  choices : [&#x27;auto&#x27;, &#x27;disabled&#x27;, &#x27;dri&#x27;, &#x27;xlib&#x27;, &#x27;gallium-xlib&#x27;],</span><br><span class="line">  description : &#x27;Build support for GLX platform&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>In Mesa, glx is implemented in three ways:</p>
<table>
<thead>
<tr>
<th>*-based</th>
<th>backend</th>
<th>window system</th>
</tr>
</thead>
<tbody>
<tr>
<td>dri-based</td>
<td>non-sw-pipes</td>
<td>*_drm_winsys</td>
</tr>
<tr>
<td>xlib</td>
<td>tnl</td>
<td>sw_winsys</td>
</tr>
<tr>
<td>gallium-based</td>
<td>softpipe/llvmpipe</td>
<td>sw_winsys</td>
</tr>
</tbody>
</table>
<ul>
<li>OSMesa gallium requires gallium softpipe or llvmpipe
<ul>
<li>means if <code>osmesa</code> is configured as <code>gallium</code>, <code>gallium-drivers</code> must include <code>swrast</code> but the <code>classic</code> osmesa uses the fixed-functioned TNL by default.</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option(</span><br><span class="line">  &#x27;osmesa&#x27;,</span><br><span class="line">  type : &#x27;combo&#x27;,</span><br><span class="line">  value : &#x27;gallium&#x27;,</span><br><span class="line">  choices : [&#x27;none&#x27;, &#x27;classic&#x27;, &#x27;gallium&#x27;],</span><br><span class="line">  description : &#x27;Build OSmesa.&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Cannot build GLX support without X11 platform support and at least one OpenGL API</p>
<ul>
<li>GLX, As the name suggests, is dedicated to X11 winsys.</li>
</ul>
</li>
<li>
<p>When <code>__glXInitialize</code> creates the <code>Display</code>, <strong>only</strong> <code>driswCreateDisplay</code> returns successfully. Both of <code>dri2CreateDisplay</code> and <code>driCreateDisplay</code> failed.</p>
</li>
<li>
<p>env: WSL on Windows 10 and with vcXsrv installed on the host as X server</p>
</li>
</ul>
<p>The cause of failure is that vcXsrv has no extensions with DRI or DRI2. This lack of X server extension fails <code>DRI2QueryExtension</code> and <code>XF86DRIQueryExtension</code> so that the loading of gallium driver is not invoked.</p>
<h1 id="debug"><a class="markdownIt-Anchor" href="#debug"></a> Debug</h1>
<h2 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h2>
<ul>
<li>MESA_VERBOSE=comma-separated-list
<ul>
<li>MESA_VERBOSE=api</li>
</ul>
</li>
<li>MESA_GLSL=comma-separated-list
<ul>
<li><code>MESA_GLSL=log</code> 把所有 GLSL shader 保存到文件里， shader_X.vert 或 shader_X.frag</li>
</ul>
</li>
</ul>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://docs.mesa3d.org/shading.html#environment-variables">mdoc: Shading Languages Environment Variables</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Extensions和Version</title>
    <url>/gfx/ogl-extension/</url>
    <content><![CDATA[<h1 id="talk-about"><a class="markdownIt-Anchor" href="#talk-about"></a> Talk About</h1>
<ul>
<li>OpenGL Extensions有哪些分类？</li>
<li>Conformant OpenGL implementation是什么?</li>
<li>OpenGL Extensions和OpenGL Versions有什么关系？</li>
<li>OpenGL Extensions和conformant OpenGL implementation有什么关系？</li>
</ul>
<span id="more"></span>
<h2 id="opengl-extensions-category"><a class="markdownIt-Anchor" href="#opengl-extensions-category"></a> OpenGL Extensions Category</h2>
<p>严格来说，OpenGL Extensions可以分为三类，但也可以分为两类。</p>
<h3 id="如果按照khronos的extensions-name-convention可以分为以下三类"><a class="markdownIt-Anchor" href="#如果按照khronos的extensions-name-convention可以分为以下三类"></a> 如果按照Khronos的<a href="https://www.khronos.org/registry/OpenGL/docs/rules.html#spec_naming">Extensions Name Convention</a>可以分为以下三类：</h3>
<ul>
<li>vendor-specific (“NV”, “ATI”, etc)</li>
<li>multivendor (EXT)</li>
<li>Khronos-approved (“ARB”, “OES”, “OML”)</li>
</ul>
<p>具体说， Khronos的Extension命名规则是<code>api_category_name</code>, 对于<strong>OpenGL</strong> API来说<code>api</code>就是<code>GL</code>, <code>category</code>就是上面的三类，对于第三类<strong>Khronos-approved</strong> Extensions, <code>category</code>还会细分</p>
<ul>
<li>&quot;ARB&quot;或&quot;KHR&quot;专门指<strong>OpenGL</strong> Extensions</li>
<li>&quot;OES&quot;专门指<strong>OpenGL ES</strong> Extensions</li>
<li>&quot;OML&quot;专门指<strong>OpenML</strong> Extensions</li>
</ul>
<h3 id="如果按照khronos的opengl-registry-extension-specifications可以分为以下两类"><a class="markdownIt-Anchor" href="#如果按照khronos的opengl-registry-extension-specifications可以分为以下两类"></a> 如果按照Khronos的<a href="https://www.khronos.org/registry/OpenGL/index_gl.php">OpenGL Registry Extension Specifications</a>可以分为以下两类:</h3>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL/index_gl.php#arbextspecs">OpenGL ARB Extensions Specifications</a></li>
<li><a href="https://www.khronos.org/registry/OpenGL/index_gl.php#arbextspecs">OpenGL Vendor and EXT Extension Specifications</a></li>
</ul>
<h3 id="khronos-approved-extensions"><a class="markdownIt-Anchor" href="#khronos-approved-extensions"></a> Khronos-approved Extensions</h3>
<p>这里重点理一下<strong>Khronos-approved</strong> Extensions(或者**“GL_ARB_<em>&quot;<strong>和</strong>&quot;GL_KHR_</em>”**), 因为Khronos-approved Extensions与下面两个问题密切相关：</p>
<ul>
<li>OpenGL Extensions和OpenGL Versions有什么关系？</li>
<li>OpenGL Extensions和conformant OpenGL implementation有什么关系？</li>
</ul>
<p>先看一下<a href="https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf">OpenGL 4.6 Core Profile Specification</a></p>
<h4 id="k3-arb-and-khronos-extensions"><a class="markdownIt-Anchor" href="#k3-arb-and-khronos-extensions"></a> K.3 ARB and Khronos Extensions</h4>
<blockquote><p>OpenGL extensions that have been approved by the Khronos OpenGL Architectural Review Board Working Group(ARB), or jointly approved by the ARB and the Khronos OpenGL ES Working Group(KHR), are summarized in this section. ARB and KHR extensions are NOT required to be supported by a CONFORMANT OpenGL implementation, but are expected to be widely available; they define functionality that is likely to move into the REQUIRED feature set in a future revision of the specification.</p>
</blockquote>
<p>所有被ARB批准的，或者被ARB和KHR联合批准的OpenGL Extensions被罗列在本章节。这些Extensions不是一个<strong>Conformant</strong> OpenGL实现所必须支持的，但它们应该被大多数OpenGL实现都支持；它们所定义的功能很有可能在未来的OpenGL Specification里加到<strong>必须支持的特性集</strong>中。</p>
<h4 id="k31-naming-conventions"><a class="markdownIt-Anchor" href="#k31-naming-conventions"></a> K.3.1 Naming Conventions</h4>
<p>为了区分<strong>ARB</strong>和<strong>KHR</strong> extensions和core OpenGL extensions(required core features), 以及vendor-specific extensions, 有以下extension命名规范：</p>
<ul>
<li>每个Khronos-approved extension都有一个唯一的名字字符串&quot;GL_ARB_name&quot;或&quot;GL_KHR_name&quot;, 如果某个OpenGL实现支持某个extension,那么这个extension的名字字符串就要出现在调用<code>glGetStringi(EXTENSIONS);</code>的返回值里。</li>
<li>所有在这个extension里定义的函数，函数名都以<code>FunctionARB</code>或<code>FunctionKHR</code>命名。</li>
<li>所有在这个extension里定义的枚举，枚举名都以<code>NAME_ARB</code>或<code>NAME_KHR</code>命名。</li>
</ul>
<h4 id="k32-promoting-extensions-to-core-features"><a class="markdownIt-Anchor" href="#k32-promoting-extensions-to-core-features"></a> K.3.2 Promoting Extensions to Core Features</h4>
<p>Khronos-approved, multivendor, 以及vendor-specific extensions都可以被_晋升_(<em>promoted</em>)加入到OpenGL核心特性集(required core features). 一旦被加入，相应的extension specification将被合入到core specification. 在这个extension里定义的函数和枚举也将_删除_它们的<strong>ARB</strong>, <strong>KHR</strong>, <strong>EXT</strong>, 或者<strong>vendor后缀</strong>。而且支持这些被_晋升_的extension的OpenGL实现应该继续支持带后缀的函数名和枚举名。</p>
<h2 id="what-is-the-relationship-between-opengl-extensions-and-opengl-versions"><a class="markdownIt-Anchor" href="#what-is-the-relationship-between-opengl-extensions-and-opengl-versions"></a> What Is The Relationship Between OpenGL Extensions And OpenGL Versions?</h2>
<p>下面这张图展示各种OpenGL extensions集合的关系。只有那些<strong>Required Core Features(Extensions)<strong>才会被纳入到各个</strong>OpenGL Core Profile Specification</strong>， 也即OpenGL versions是通过不断加入新的Required Core Features来升级的。</p>
<div align=center><img src="/gfx/ogl-extension/extensions.png" class="" title="venn diagram of extensions"></div>
<h1 id="opengl-es-and-glsl-es-version"><a class="markdownIt-Anchor" href="#opengl-es-and-glsl-es-version"></a> OpenGL (ES) and GLSL (ES) Version</h1>
<h2 id="khronos发布opengles及glsles的时间"><a class="markdownIt-Anchor" href="#khronos发布opengles及glsles的时间"></a> Khronos发布OpenGL(ES)及GLSL(ES)的时间</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Standard</th>
<th style="text-align:center">Birth</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">OpenGL</td>
<td style="text-align:center">1992</td>
</tr>
<tr>
<td style="text-align:left">OpenGL ES</td>
<td style="text-align:center">2003</td>
</tr>
<tr>
<td style="text-align:left">GLSL</td>
<td style="text-align:center">2004</td>
</tr>
<tr>
<td style="text-align:left">GLSL ES</td>
<td style="text-align:center">2007</td>
</tr>
</tbody>
</table>
<h2 id="opengl-version"><a class="markdownIt-Anchor" href="#opengl-version"></a> OpenGL Version</h2>
<table>
<thead>
<tr>
<th style="text-align:center">GL Version</th>
<th style="text-align:center">Release</th>
<th style="text-align:center">GLSL Version</th>
<th style="text-align:left">Preprocessor</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.0</td>
<td style="text-align:center">1992</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1.1</td>
<td style="text-align:center">1997</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1.2</td>
<td style="text-align:center">1998</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1.3</td>
<td style="text-align:center">2001</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1.4</td>
<td style="text-align:center">2002</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1.5</td>
<td style="text-align:center">2003</td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">2.0</td>
<td style="text-align:center">2004</td>
<td style="text-align:center">1.10</td>
<td style="text-align:left">#version 110</td>
</tr>
<tr>
<td style="text-align:center">2.1</td>
<td style="text-align:center">2006</td>
<td style="text-align:center">1.20</td>
<td style="text-align:left">#version 120</td>
</tr>
<tr>
<td style="text-align:center">3.0</td>
<td style="text-align:center">2008</td>
<td style="text-align:center">1.30</td>
<td style="text-align:left">#version 130</td>
</tr>
<tr>
<td style="text-align:center">3.1</td>
<td style="text-align:center">2009</td>
<td style="text-align:center">1.40</td>
<td style="text-align:left">#version 140</td>
</tr>
<tr>
<td style="text-align:center">3.2</td>
<td style="text-align:center">2009</td>
<td style="text-align:center">1.50</td>
<td style="text-align:left">#version 150</td>
</tr>
<tr>
<td style="text-align:center">3.3</td>
<td style="text-align:center">2010</td>
<td style="text-align:center">3.30</td>
<td style="text-align:left">#version 330</td>
</tr>
<tr>
<td style="text-align:center">4.0</td>
<td style="text-align:center">2010</td>
<td style="text-align:center">4.00</td>
<td style="text-align:left">#version 400</td>
</tr>
<tr>
<td style="text-align:center">4.1</td>
<td style="text-align:center">2010</td>
<td style="text-align:center">4.10</td>
<td style="text-align:left">#version 410</td>
</tr>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2011</td>
<td style="text-align:center">4.20</td>
<td style="text-align:left">#version 420</td>
</tr>
<tr>
<td style="text-align:center">4.3</td>
<td style="text-align:center">2012</td>
<td style="text-align:center">4.30</td>
<td style="text-align:left">#version 430</td>
</tr>
<tr>
<td style="text-align:center">4.4</td>
<td style="text-align:center">2013</td>
<td style="text-align:center">4.40</td>
<td style="text-align:left">#version 440</td>
</tr>
<tr>
<td style="text-align:center">4.5</td>
<td style="text-align:center">2014</td>
<td style="text-align:center">4.50</td>
<td style="text-align:left">#version 450</td>
</tr>
<tr>
<td style="text-align:center">4.6</td>
<td style="text-align:center">2017</td>
<td style="text-align:center">4.60</td>
<td style="text-align:left">#version 460</td>
</tr>
</tbody>
</table>
<h2 id="opengl-shading-language-es-version"><a class="markdownIt-Anchor" href="#opengl-shading-language-es-version"></a> OpenGL (Shading Language) ES Version</h2>
<table>
<thead>
<tr>
<th style="text-align:center">OpenGL ES</th>
<th style="text-align:center">Release</th>
<th style="text-align:center">GLSL ES (ESSL)</th>
<th style="text-align:left">Directive</th>
<th style="text-align:center">GLSL based</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.0</td>
<td style="text-align:center">2003</td>
<td style="text-align:center">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td style="text-align:center">1.1</td>
<td style="text-align:center">2004</td>
<td style="text-align:center">N/A</td>
<td style="text-align:left">N/A</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td style="text-align:center">2.0</td>
<td style="text-align:center">2007</td>
<td style="text-align:center">1.00</td>
<td style="text-align:left"><code>#version 100</code></td>
<td style="text-align:center">1.20</td>
</tr>
<tr>
<td style="text-align:center">3.0</td>
<td style="text-align:center">2012</td>
<td style="text-align:center">3.00</td>
<td style="text-align:left"><code>#version 300 es</code></td>
<td style="text-align:center">3.30</td>
</tr>
<tr>
<td style="text-align:center">3.1</td>
<td style="text-align:center">2014</td>
<td style="text-align:center">3.10</td>
<td style="text-align:left"><code>#version 310 es</code></td>
<td style="text-align:center">3.30</td>
</tr>
<tr>
<td style="text-align:center">3.2</td>
<td style="text-align:center">2015</td>
<td style="text-align:center">3.20</td>
<td style="text-align:left"><code>#version 320 es</code></td>
<td style="text-align:center">3.30</td>
</tr>
</tbody>
</table>
<h1 id="pipe_cap_-vs-extensions-in-mesa"><a class="markdownIt-Anchor" href="#pipe_cap_-vs-extensions-in-mesa"></a> <code>PIPE_CAP_*</code> vs Extensions in Mesa</h1>
<p><img src="/images/extension2version.png" alt="determination of gl version" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use pipe_screen::get_param() to query PIPE_CAP_ values to determine</span></span><br><span class="line"><span class="comment"> * which GL extensions are supported.</span></span><br><span class="line"><span class="comment"> * Quite a few extensions are always supported because they are standard</span></span><br><span class="line"><span class="comment"> * features or can be built on top of other gallium features.</span></span><br><span class="line"><span class="comment"> * Some fine tuning may still be needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_init_extensions</span><span class="params">(<span class="keyword">struct</span> pipe_screen *screen,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> gl_constants *consts,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> gl_extensions *extensions,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> st_config_options *options,</span></span><br><span class="line"><span class="params">                        gl_api api)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Examine enabled GL extensions to determine GL version.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> GLuint</span><br><span class="line"><span class="title function_">compute_version</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> gl_extensions *extensions,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> gl_constants *consts, gl_api api)</span></span><br></pre></td></tr></table></figure>
<h1 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h1>
<ol>
<li>为什么GLSL ES 1.00后面是3.00版本？</li>
</ol>
<p>在GLSL ES 3.00 Spec里有这样一段说明：</p>
<blockquote><p>This version of the language is based on version 3.30 of the desktop GLSL. However it includes a number of features that are in version 4.20 but not 3.30. The previous version of GLSL ES was version 1.00 so this version could be called version 2.00.</p>
<p>RESOLUTION: Follow the desktop GLSL convention so that the language version matches the API version. Hence this version will be called 3.00</p>
</blockquote>
<p>GLSL ES 3.10 &amp; 3.20里同样有这段说明，所以，3.00主要是为了对应OpenGL ES API的版本号，3.10, 3.20同样是。</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Pipeline</title>
    <url>/gfx/ogl-pipeline/</url>
    <content><![CDATA[<h1 id="opengl-pipeline"><a class="markdownIt-Anchor" href="#opengl-pipeline"></a> OpenGL Pipeline</h1>
<p><img src="/images/../ogl-pipeline/ogl-pipeline.png" alt="" /></p>
<h1 id="opengl-pipeline-stage-flowchart"><a class="markdownIt-Anchor" href="#opengl-pipeline-stage-flowchart"></a> OpenGL Pipeline Stage Flowchart</h1>
<p><img src="/images/../ogl-pipeline/RenderingPipeline.png" alt="" /></p>
<p>说明:</p>
<ol>
<li>蓝色框表示是Programmable Shader Stages</li>
<li>虚线框表示是Optional Shader Stages</li>
</ol>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Objects</title>
    <url>/gfx/opengl-objects/</url>
    <content><![CDATA[<h1 id="objects"><a class="markdownIt-Anchor" href="#objects"></a> Objects</h1>
<span id="more"></span>
<table>
<thead>
<tr>
<th style="text-align:left">Object</th>
<th style="text-align:left">Shareability</th>
<th style="text-align:left">Containability</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Buffer</td>
<td style="text-align:left">shared</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">Shader</td>
<td style="text-align:left">shared</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">Program</td>
<td style="text-align:left">shared</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">Program Pipeline</td>
<td style="text-align:left">non-shared</td>
<td style="text-align:left">Program Objects</td>
</tr>
<tr>
<td style="text-align:left">Texture</td>
<td style="text-align:left">shared</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">Sampler</td>
<td style="text-align:left">shared</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">Renderbuffer</td>
<td style="text-align:left">shared</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">Framebuffer</td>
<td style="text-align:left">non-shared</td>
<td style="text-align:left">Renderbuffer and/or Texture</td>
</tr>
<tr>
<td style="text-align:left">Vertex Array</td>
<td style="text-align:left">non-shared</td>
<td style="text-align:left">Buffer Objects</td>
</tr>
<tr>
<td style="text-align:left">Transform Feedback</td>
<td style="text-align:left">non-shared</td>
<td style="text-align:left">Buffer Objects</td>
</tr>
<tr>
<td style="text-align:left">Query</td>
<td style="text-align:left">non-shared</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">Sync</td>
<td style="text-align:left">shared</td>
<td style="text-align:left">No</td>
</tr>
</tbody>
</table>
<p>NOTE:</p>
<ul>
<li>对于一类Objects是否可以共享是指是否可以在多个<strong>OpenGL contexts</strong>之间共享</li>
</ul>
<h1 id="buffer-object"><a class="markdownIt-Anchor" href="#buffer-object"></a> Buffer Object</h1>
<h2 id="indexed-buffer-target"><a class="markdownIt-Anchor" href="#indexed-buffer-target"></a> Indexed Buffer Target</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Target</th>
<th style="text-align:left">Limit</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_ATOMIC_COUNTER_BUFFER</td>
<td style="text-align:left">GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS</td>
<td>4.2</td>
</tr>
<tr>
<td style="text-align:left">GL_TRANSFORM_FEEDBACK_BUFFER</td>
<td style="text-align:left">GL_MAX_TRANSFORM_FEEDBACK_BUFFERS</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">GL_UNIFORM_BUFFER</td>
<td style="text-align:left">GL_MAX_UNIFORM_BUFFER_BINDINGS</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">GL_SHADER_STORAGE_BUFFER</td>
<td style="text-align:left">GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS</td>
<td>4.3</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Piglit</title>
    <url>/gfx/piglit/</url>
    <content><![CDATA[<pre><code class="highlight mermaid">flowchart TB
  subgraph p [Main Thread]
    subgraph p0 [&quot;piglit_drm_create_dma_buf()&quot;]
      p.a[&quot;drv-&gt;create(w, h, fourcc, src_data, drm_buf)&quot;]
      p.b[&quot;drv-&gt;export(drm_buf)&quot;]
      subgraph p1 [&quot;create_and_destroy_texture()&quot;]
        p.c[&quot;egl_image_for_dma_buf_fd&lt;br&gt;(buf, fd, fourcc, img)&quot;]
        p.d[&quot;texture_for_egl_image(img, texture)&quot;]
        p.e[&quot;eglDestroyImageKHR(display, img)&quot;]
        p.f[&quot;glDeleteTextures(1, &amp;texture)&quot;]
        p.g[&quot;glFinish()&quot;]
      end
    end
  end
  subgraph t1 [Thread 1]
    subgraph lo11 [Loop 1]
      t1.a[&quot;eglCreateContext()&quot;]
      t1.b[&quot;eglMakeCurrent()&quot;]
      subgraph lo111 [&quot;create_and_destroy_texture()&quot;]
        t1.c[&quot;egl_image_for_dma_buf_fd&lt;br&gt;(buf, fd, fourcc, img)&quot;]
        t1.d[&quot;texture_for_egl_image(img, texture)&quot;]
        t1.e[&quot;eglDestroyImageKHR(display, img)&quot;]
        t1.f[&quot;glDeleteTextures(1, &amp;texture)&quot;]
        t1.g[&quot;glFinish()&quot;]
      end
    end
  end

  subgraph t2 [Thread 2]
    subgraph lo21 [Loop 1]
      t2.a[&quot;eglCreateContext()&quot;]
      t2.b[&quot;eglMakeCurrent()&quot;]
      subgraph lo211 [&quot;create_and_destroy_texture()&quot;]
        t2.c[&quot;egl_image_for_dma_buf_fd&lt;br&gt;(buf, fd, fourcc, img)&quot;]
        t2.d[&quot;texture_for_egl_image(img, texture)&quot;]
        t2.e[&quot;eglDestroyImageKHR(display, img)&quot;]
        t2.f[&quot;glDeleteTextures(1, &amp;texture)&quot;]
        t2.g[&quot;glFinish()&quot;]
      end
    end
  end

  p.a --&gt; p.b --&gt; p.c --&gt; p.d --&gt; p.e --&gt; p.f --&gt; p.g

  t1.a --&gt; t1.b --&gt; t1.c --&gt; t1.d --&gt; t1.e --&gt; t1.f --&gt; t1.g
  t2.a --&gt; t2.b --&gt; t2.c --&gt; t2.d --&gt; t2.e --&gt; t2.f --&gt; t2.g

  p --&gt; t1
  p --&gt; t2

  lo11 -- 100000 times --&gt; lo11
  lo21 -- 100000 times --&gt; lo21

  click p.a https://gitlab.freedesktop.org/mesa/piglit/-/blob/main/tests/util/piglit-framework-gl/piglit_drm_dma_buf.c#L519&quot;
  click p.b https://gitlab.freedesktop.org/mesa/piglit/-/blob/main/tests/util/piglit-framework-gl/piglit_drm_dma_buf.c#L519&quot;</code></pre>
<span id="more"></span>
<p><a href="https://gitlab.freedesktop.org/mesa/piglit">Piglit</a> 是为 OpenGL, Vulkan, OpenCL 实现设计的自动化测试套件。Piglit 的目标是提高 OpenGL, Vulkan 和 OpenCL 开源驱动的质量，并为开发者提供一个简单的回归测试途径。</p>
<p>这里我们通过 Piglit 里的几个有意思的测试用例，反过来了解 Mesa 实现的一些底层机制，比如 DMABUF, EGLImageKHR 等等。</p>
<h1 id="ext_image_dma_buf_importrefcount-multithread"><a class="markdownIt-Anchor" href="#ext_image_dma_buf_importrefcount-multithread"></a> <a href="https://gitlab.freedesktop.org/mesa/piglit/-/blob/main/tests/spec/ext_image_dma_buf_import/refcount-multithread.c">ext_image_dma_buf_import/refcount-multithread</a></h1>
<p>测试多线程下，驱动是否正确处理 dma-buf 的导入/导出，</p>
<ul>
<li>export <code>drmPrimeHandleToFD()</code></li>
<li>import <code>drmPrimeFDToHandle()</code></li>
</ul>
<p>FD 是文件描述符，而 bo handles 在内核态和用户态各自维护有一份，分别是 <strong>GEM bo handles</strong> 和 <strong>Userspace bo handles</strong>, 在 mesa 的实现里，这两个集合是 1:1 映射关系, 当一个 gem bo handle 被导入, 如果对应的 userspace bo handle(实际上就是 drmPrimeFDToHandle() 返回的整数)已经存在，mesa 驱动仅仅是将这个 userspace bo handle 的引用计数加 1. 这就有可能导致 bo_destroy 函数和 bo_import() 函数发生竞争 (race), 从而导致 UAF, 这个 Piglit 用例就是专门测试这种场景的。</p>
<h2 id="faq"><a class="markdownIt-Anchor" href="#faq"></a> FAQ</h2>
<h3 id="q-两个线程先后对同一个-fd-调用-drmprimefdtohandle返回给各自线程的-handle-是同一个值吗"><a class="markdownIt-Anchor" href="#q-两个线程先后对同一个-fd-调用-drmprimefdtohandle返回给各自线程的-handle-是同一个值吗"></a> Q: 两个线程先后对同一个 FD 调用 <code>drmPrimeFDToHandle()</code>，返回给各自线程的 handle ，是同一个值吗？</h3>
<p>A: 因为是同一个 FD, 所以它底层的或者说内核的 drm_gem_object 也是同一个，返回的 handle 是同一个值，这也正是 ext_image_dma_buf_import/refcount-multithread 这个用例要构建的场景。</p>
<h3 id="q-drmprimefdtohandledrmprimehandletofd-会影响-drm_gem_object-的引用计数吗"><a class="markdownIt-Anchor" href="#q-drmprimefdtohandledrmprimehandletofd-会影响-drm_gem_object-的引用计数吗"></a> Q: <code>drmPrimeFDToHandle()</code>/<code>drmPrimeHandleToFD()</code> 会影响 drm_gem_object 的引用计数吗？</h3>
<p>A: 不会</p>
<h1 id="waffle"><a class="markdownIt-Anchor" href="#waffle"></a> <a href="https://gitlab.freedesktop.org/mesa/waffle">Waffle</a></h1>
<p><a href="https://gitlab.freedesktop.org/mesa/waffle">Waffle /wa:fl/ 动听而无意义的话</a> 是一个跨平台的在运行时动态地选择一个 OpenGL API.piglit 用它来创建 EGLContext, 最终会创建 Galliumm pipe_context. 此外 apitrace, Dante (open source DOOM 3) 也使用 waffle</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Program Object</title>
    <url>/gfx/program-object/</url>
    <content><![CDATA[<h1 id="shader-object"><a class="markdownIt-Anchor" href="#shader-object"></a> Shader Object</h1>
<p>创建和使用<strong>Shader Object</strong>的API:</p>
<ul>
<li><code>GLuint glCreateShader(GLenum shaderType);</code></li>
<li><code>void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length);</code></li>
<li><code>void glCompileShader(GLunit shader);</code></li>
</ul>
<span id="more"></span>
<h1 id="shader-stage"><a class="markdownIt-Anchor" href="#shader-stage"></a> Shader Stage</h1>
<p>OpenGL里没有专门的Shader Stage Object去封装Stage相关的状态。但是事实上，一个或多个特定类型的Shader Object(s)组成一个特定的Shader Stage, 多个<strong>Shader Stages</strong>链接成一个Program Object. 只不过大多情况下，一个Shader Stage只来自于一个Shader Object，但是多个同一类型的Shader Objects组成一个Program Object的一个Shader Stage是完全符合OpenGL规范的。</p>
<img src="/gfx/program-object/shader-stage.png" class="">
<h1 id="program-object"><a class="markdownIt-Anchor" href="#program-object"></a> Program Object</h1>
<p>创建和使用<strong>Program Object</strong>的API:</p>
<ul>
<li><code>GLuint glCreateProgram();</code></li>
<li><code>void glAttachShader(GLuint program, GLuint shader);</code></li>
</ul>
<img src="/gfx/program-object/program-object.png" class="">
<h1 id="program-pipeline-object"><a class="markdownIt-Anchor" href="#program-pipeline-object"></a> Program Pipeline Object</h1>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>AMD GPU Vulkan Drivers for Linux</title>
    <url>/gfx/radv/</url>
    <content><![CDATA[<p>AMD 在 Linux 下维护着两套开源 Vulkan 驱动:</p>
<ul>
<li><a href="https://github.com/GPUOpen-Drivers/AMDVLK">AMDVLK</a>
<ul>
<li>从闭源 Windows Vulkan 驱动适配而来，主要不同在 shader 编译后端, AMDVLK 使用基于 LLVM 的 LLPC</li>
</ul>
</li>
<li><a href="https://docs.mesa3d.org/drivers/radv.html">RADV</a>
<ul>
<li>包含在 Mesa 内，有两套编译后端: 基于 LLVM 的后端和基于 NIR 的 <a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/amd/compiler/README.md">ACO</a> (<strong>A</strong>MD <strong>CO</strong>mpiler)，但默认的是 ACO</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="amdvlk"><a class="markdownIt-Anchor" href="#amdvlk"></a> AMDVLK</h1>
<p>AMDVLK 的 README 有一张<a href="https://github.com/GPUOpen-Drivers/AMDVLK?tab=readme-ov-file#amd-open-source-driver-for-vulkan">架构图</a>, 非常清晰地展示了整个驱动包含的组件和层次结构。</p>
<p><img src="/images/radv/topLevelArch.png" alt="topLevelArch" /></p>
<p>AMDVLK 驱动由 5 个代码仓库构建:</p>
<ul>
<li><a href="https://github.com/GPUOpen-Drivers/llvm-project">LLVM</a></li>
<li><a href="https://github.com/GPUOpen-Drivers/xgl">XGL</a> Vulkan API Translator</li>
<li><a href="https://github.com/GPUOpen-Drivers/llpc">LLPC</a> LLVM-based Pipeline Compiler</li>
<li><a href="https://github.com/GPUOpen-Drivers/gpurt">GPURT</a> GPU Ray Tracing Library</li>
<li><a href="https://github.com/GPUOpen-Drivers/pal">PAL</a> Platform Abstraction Library</li>
</ul>
<p>其中 XGL, LLPC, GPURT 都与 <strong>PAL</strong> 有关联。</p>
<h1 id="radv-radeon-vulkan"><a class="markdownIt-Anchor" href="#radv-radeon-vulkan"></a> RADV (Radeon Vulkan)</h1>
<p>RADV 和其它 Mesa 的 GPU UMD 一样都是使用 libdrm 库与 KMD 打交道，但后来为了<a href="https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/32067">GPU 虚拟化(amdgpu-virto) 支持 Native Context</a> 将大部分 libdrm_amdgpu 库的函数换成了 <strong>ac_drm_</strong> 开头的函数, 后来为了<a href="https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/21658">GPU 虚拟化(amdgpu-virto) 支持 Native Context</a> 也对 ac_drm 函数接口进行了的修改。 经过这两次修改，RADV 使用的 libdrm_amdgpu 函数基本分为两类：</p>
<ul>
<li>直接调用型</li>
<li>&quot;inline&quot;型</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Function</th>
<th style="text-align:left">IOCTL CMD</th>
<th style="text-align:left">Read/Write</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ac_drm_bo_set_metadata</td>
<td style="text-align:left">GEM_METADATA</td>
<td style="text-align:left">RW</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_bo_query_info</td>
<td style="text-align:left">GEM_METADATA, GEM_OP</td>
<td style="text-align:left">RW</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_bo_wait_for_idle</td>
<td style="text-align:left">GEM_WAIT_IDLE</td>
<td style="text-align:left">RW</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_bo_va_op_raw</td>
<td style="text-align:left">GEM_VA</td>
<td style="text-align:left">RW</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_cs_query_reset_state2</td>
<td style="text-align:left">CTX</td>
<td style="text-align:left">RW</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_cs_query_fence_status</td>
<td style="text-align:left">DRM_IOCTL_AMDGPU_WAIT_CS</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_cs_submit_raw2</td>
<td style="text-align:left">CS</td>
<td style="text-align:left">RW</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_query_hw_ip_count</td>
<td style="text-align:left">INFO</td>
<td style="text-align:left">W</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_query_hw_ip_info</td>
<td style="text-align:left">INFO</td>
<td style="text-align:left">W</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_query_firmware_version</td>
<td style="text-align:left">INFO</td>
<td style="text-align:left">W</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_query_uq_fw_area_info</td>
<td style="text-align:left">INFO</td>
<td style="text-align:left">W</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_read_mm_registers</td>
<td style="text-align:left">INFO</td>
<td style="text-align:left">W</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_query_info</td>
<td style="text-align:left">INFO</td>
<td style="text-align:left">W</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_query_sensor_info</td>
<td style="text-align:left">INFO</td>
<td style="text-align:left">W</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_query_video_caps_info</td>
<td style="text-align:left">INFO</td>
<td style="text-align:left">W</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_query_gpuvm_fault_info</td>
<td style="text-align:left">INFO</td>
<td style="text-align:left">W</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_vm_reserve_vmid</td>
<td style="text-align:left">VM</td>
<td style="text-align:left">RW</td>
</tr>
<tr>
<td style="text-align:left">ac_drm_vm_unreserve_vmid</td>
<td style="text-align:left">VM</td>
<td style="text-align:left">RW</td>
</tr>
</tbody>
</table>
<p>关于 libdrm_amdgpu 里的函数，其实还有一类，就是 AMDVLK 用到的，而 RADV 没有用的:</p>
<ul>
<li>amdgpu_bo_list_create</li>
<li>amdgpu_bo_list_create_raw</li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>ReadPixels in Mesa</title>
    <url>/gfx/readpixel/</url>
    <content><![CDATA[<h1 id="glreadpixels"><a class="markdownIt-Anchor" href="#glreadpixels"></a> glReadPixels</h1>
<p>glReadPixels 是将当前绑定的 FBO 里的内容从显存(renderbuffer, 通常是 read renderbuffer) 读到 <code>*data</code> 指向的内存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glReadPixels(GLint x, GLint y,</span><br><span class="line">                  GLsizei width, GLsizei height,</span><br><span class="line">                  GLenum format, GLenum type, void *data);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在这次从显存到主存的数据传输中可能源(renderbuffer) 数据格式有可能与请求的(glReadPixels参数 format, type 指定的)格式不相同，需要数据在被回读到 <code>*data</code> 前做一次格式或字节序转换。为了能够加速这个转换过程，就产生了基于 Blit 的 glReadPixels 的实现。 还有与之对应的所谓 slow path (其实就是让 CPU 做这次格式转换)</p>
<h1 id="why-prefer-to-blit-based-readpixels"><a class="markdownIt-Anchor" href="#why-prefer-to-blit-based-readpixels"></a> Why prefer to blit-based ReadPixels？</h1>
<p>原因有两方面：</p>
<ul>
<li>格式转换 (required than preferred)</li>
<li>memcpy 的效率 (row by row or one-shot)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (tex_xfer-&gt;stride == bytesPerRow &amp;&amp; destStride == bytesPerRow) &#123;</span><br><span class="line">   memcpy(dest, map, bytesPerRow * height);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   GLuint row;</span><br><span class="line"></span><br><span class="line">   for (row = 0; row &lt; (unsigned) height; row++) &#123;</span><br><span class="line">      memcpy(dest, map, bytesPerRow);</span><br><span class="line">      map += tex_xfer-&gt;stride;</span><br><span class="line">      dest += destStride;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 2 个问题需要理解一张图片或一块像素它在内存中的存储方式</p>
<p><img src="/images/readpixel/image-in-memory.png" alt="The usual layout of pixels of an image in memory" /><br />
<img src="/images/readpixel/image-in-address.png" alt="How to compute the address of a pixel" /></p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
        <tag>Mesa</tag>
      </tags>
  </entry>
  <entry>
    <title>Replacing NIR with SPIR-V?</title>
    <url>/gfx/replace-nir-with-spirv/</url>
    <content><![CDATA[<p><a href="https://www.mail-archive.com/mesa-dev@lists.freedesktop.org/msg224164.html">“Replacing NIR with SPIR_V?”</a> 是mesa-dev maillist 上2022-01-20的一封邮件主题. 从邮件讨论中我了解到了许多知识，在此记录一下。</p>
<table>
<thead>
<tr>
<th style="text-align:left">名词</th>
<th style="text-align:left">全称</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IR</td>
<td style="text-align:left">Intermediate Representation</td>
<td style="text-align:left">编译器中使用的中间表示，一般是编译器优化 Pass 和后端的输入</td>
</tr>
<tr>
<td style="text-align:left">NIR</td>
<td style="text-align:left">New IR</td>
<td style="text-align:left">Mesa 中专门为 Graphics shader 设计的一种 IR, 它可以作为特定后端的输入，如 LLVM AMDGPU 后端</td>
</tr>
<tr>
<td style="text-align:left">SPIR</td>
<td style="text-align:left">Standard Portable IR</td>
<td style="text-align:left">一种用于并行计算和图形的中间语言（interchage language), 由 Khronos Group 在 2012 年引入</td>
</tr>
<tr>
<td style="text-align:left">SPIR-V</td>
<td style="text-align:left">SPIR-Vulkan</td>
<td style="text-align:left">由 Khronos Group 在 2015 年引入，用来替代原来的 SPIR</td>
</tr>
<tr>
<td style="text-align:left">RISC</td>
<td style="text-align:left">Reduced Instruction Set Computer</td>
<td style="text-align:left">精简指令集， 与 CISC 相对</td>
</tr>
<tr>
<td style="text-align:left">RISC-V</td>
<td style="text-align:left">RISC five</td>
<td style="text-align:left">由加州 Berkeley 大学开发的一种开放且模块化的 RISC 指令集架构</td>
</tr>
<tr>
<td style="text-align:left">SIMD</td>
<td style="text-align:left">Single Instruction Multiple Data</td>
<td style="text-align:left">费林分类法（Flynn’s Taxonomy) 中的一种，其它的还有 SISD, MIMD, MISD</td>
</tr>
<tr>
<td style="text-align:left">SIMT</td>
<td style="text-align:left">Single Instruction Multi-Threads</td>
<td style="text-align:left">SIMD 的一种子类型</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="https://www.youtube.com/watch?v=kM0lsWjqOaw">Lightning Talk: Functional Gap between RISC-V V and SPIR-V: a Study Case on the Graphics Domain</a></li>
<li><a href="https://www.rastergrid.com/blog/gpu-tech/2022/02/simd-in-the-gpu-world/">SIMD in the GPU world</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>Render To Texture</title>
    <url>/gfx/rtt/</url>
    <content><![CDATA[<p>Render-To-Texture 是一种十分常见和简单的渲染技术，它将纹理对象和 FBO 绑定，把场景渲染到纹理中，以便之后可以反复使用。RTT 被广泛应用在 in-game cameras(virtual camera systems), post-processing 和各种特效中。本文主要比较 RTT 技术在两种不同的渲染架构下的不同和一些思考。</p>
<p><img src="/images/rtt/rtt-on-tbr.png" alt="rtt-on-tbr" /></p>
<span id="more"></span>
<h1 id="imr-vs-tbr"><a class="markdownIt-Anchor" href="#imr-vs-tbr"></a> IMR vs TBR</h1>
<p>IMR (Immediate Mode Rendering) 和 TBR (Tile-Based Rendering) 是两种不同的渲染架构，前者常见于桌面 GPU (NVIDIA, AMD), 后者常见于移动 GPU (Imagination, Mali)。</p>
<h2 id="imr"><a class="markdownIt-Anchor" href="#imr"></a> IMR</h2>
<ul>
<li>一整块一整块渲染，需要大量访存，所以必须有<strong>比较大的 L1, L2 Cache</strong> 来降低访存延时</li>
<li>需要大量带宽，所以<strong>功耗高</strong></li>
<li>渲染管线执行<strong>流畅</strong>， 从顶点到片段<strong>一口气弄完</strong></li>
</ul>
<pre><code class="highlight mermaid">block-beta
    columns 1
    block:pipeline
        A[&quot;Vertex&lt;br&gt;Processing&quot;] space B[&quot;Clip&lt;br&gt;Cull&quot;] space D[&quot;Raster&quot;] space E[&quot;Early-Z&lt;br&gt;Test&quot;] space F[&quot;Texture&lt;br&gt;Fragment&quot;] space G[&quot;Alpha&lt;br&gt;Test&quot;] space L[&quot;Late-Z&lt;br&gt;Test&quot;] space H[&quot;Alpha&lt;br&gt;Blend&quot;]
        A --&gt; B
        B --&gt; D
        D --&gt; E
        E --&gt; F
        F --&gt; G
        G --&gt; L
        L --&gt; H
    end
    space
    block:vram
        VD[&quot;Geometry&lt;br&gt;Data&quot;] space:7 TD[&quot;Texture&lt;data&gt;Data&quot;] space:3 ZB[&quot;Depth&lt;br&gt;Buffer&quot;] space FB[&quot;FrameBuffer&quot;]
    end
    VD --&gt; A
    TD --&gt; F
    L --&gt; ZB
    ZB --&gt; L
    H --&gt; FB
    FB --&gt; H</code></pre>
<h2 id="tbr"><a class="markdownIt-Anchor" href="#tbr"></a> TBR</h2>
<ul>
<li>一小块一小块<strong>渲染</strong>, 对于每一小块来说，所需要的访存的带宽就相对较小，可以在片上做一<strong>小块高速缓存</strong></li>
<li>需要的带宽小，所以<strong>功耗低</strong></li>
</ul>
<pre><code class="highlight mermaid">block-beta
    columns 1
    block:pipeline
        A[&quot;Vertex&lt;br&gt;Processing&quot;] space B[&quot;Clip&lt;br&gt;Cull&quot;] space C[&quot;Tiling&quot;] space D[&quot;Raster&quot;] space E[&quot;Early-Z&lt;br&gt;Test&quot;] space F[&quot;Texture&lt;br&gt;Fragment&quot;] space G[&quot;Late-Z&lt;br&gt;Test&quot;] space H[&quot;Alpha&lt;br&gt;Blend&quot;]
        A --&gt; B
        B --&gt; C
        D --&gt; E
        E --&gt; F
        F --&gt; G
        G --&gt; H
    end
    block:onchip
        space:12 ZC[&quot;On-Chip&lt;br&gt;Depth Buffer&quot;] space CC[&quot;On-Chip&lt;br&gt;Color Buffer&quot;]
    end
    space
    block:vram
        VD[&quot;Geometry&lt;br&gt;Data&quot;] space:4 PL[&quot;Primitive List&lt;br&gt;Vertex Data&quot;] space:4 TD[&quot;Texture&lt;data&gt;Data&quot;] space:3 FB[&quot;FrameBuffer&quot;]
    end
    VD --&gt; A
    C --&gt; PL
    PL --&gt; D
    TD --&gt; F
    G --&gt; ZC
    ZC --&gt; G
    H --&gt; CC
    CC --&gt; H
    CC --&gt; FB
    FB --&gt; CC

    style onchip   fill:#00bc00,stroke:#ff0000,stroke-dasharray:5 5</code></pre>
<p>由上面的两张图可以看到，在 TBR 架构下，GPU 产生的每个像素并不是直接写入显存的，而是暂存在<strong>片上的 Color Buffer</strong> 中，对于 RTT 来说，如果渲染得到的纹理作为后面绘制命令的源纹理，那么如果没有显式地将还存在于片上的 Color Buffer 刷新入显存中，那么当前的绘制中，纹理采样获取的纹素就是旧数据。</p>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-14-render-to-texture/">Tutorial 14: Render To Texture</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/654389634">GPU 帧缓冲内存：了解瓦片渲染 TBR(tile-based rendering)</a></li>
<li><a href="https://developer.samsung.com/galaxy-gamedev/resources/articles/gpu-framebuffer.html">GPU Framebuffer Memory: Understanding Tiling</a></li>
<li><a href="https://docs.qualcomm.com/bundle/publicresource/topics/80-78185-2/gpu.html">Qualcomm Adreno GPU</a></li>
<li><a href="https://developer.arm.com/documentation/102693/1-6/Useful-resources?lang=en">ARM Mali GPU</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan Application</title>
    <url>/gfx/vkapp/</url>
    <content><![CDATA[<p>Vulkan 是一个低开销、跨平台的二维和三维图形与计算的应用程序接口，由 Khronos 在2015年在 GDC 上首次发布。它旨在提供高效能和更均衡的 CPU 和 GPU 占用，类似于 Direct3D 12 和 AMD Mantle。</p>
<p>本文主要记录一下在 llvmpipe 软渲染 Vulkan 驱动下， 一个 vulkan 应用程序 (<a href="https://github.com/lucmann/VulkanExamples/tree/build-for-linux/examples/deferredmultisampling">demo</a>) 的执行过程。</p>
<span id="more"></span>
<h1 id="environment-variables"><a class="markdownIt-Anchor" href="#environment-variables"></a> Environment Variables</h1>
<h2 id="vk_icd_filenames"><a class="markdownIt-Anchor" href="#vk_icd_filenames"></a> VK_ICD_FILENAMES</h2>
<p>Vulkan 驱动的探测和加载是通过 ICD (Installable Client Driver) 机制实现的。当环境上同时存在多个 Vulkan 驱动时，使用环境变量 <code>VK_ICD_FILENAMES</code> 来选择指定的 vulkan 驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;VK_ICD_FILENAMES&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;/home/luc/mesa-install/share/vulkan/icd.d/lvp_icd.x86_64.json&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vk_loader_debugall"><a class="markdownIt-Anchor" href="#vk_loader_debugall"></a> VK_LOADER_DEBUG=all</h2>
<h2 id="mesa_vk_wsi_present_mode"><a class="markdownIt-Anchor" href="#mesa_vk_wsi_present_mode"></a> MESA_VK_WSI_PRESENT_MODE</h2>
<p>相当于 GL 的 <code>vblank_mode</code>, 用来控制 FPS 是否与 VSync 同步</p>
<p>Vulkan 程序的送显由 WSI (Window System Interface) 层实现，支持以下模式</p>
<ul>
<li>fifo</li>
<li>relaxed</li>
<li>mailbox</li>
<li>immediate</li>
</ul>
<p>注意：对于 lavapipe (软渲染的 Vulkan 实现)，它只支持 immediate 模式</p>
<h1 id="call-stack"><a class="markdownIt-Anchor" href="#call-stack"></a> Call Stack</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libvulkan_lvp.so!llvmpipe_create_screen(struct sw_winsys * winsys) (\home\luc\gh\forked\src\gallium\drivers\llvmpipe\lp_screen.c:1149)</span><br><span class="line">libvulkan_lvp.so!sw_screen_create_named(struct sw_winsys * winsys, const struct pipe_screen_config * config, const char * driver) (\home\luc\gh\forked\src\gallium\auxiliary\target-helpers\sw_helper.h:43)</span><br><span class="line">libvulkan_lvp.so!sw_screen_create_vk(struct sw_winsys * winsys, const struct pipe_screen_config * config, _Bool sw_vk) (\home\luc\gh\forked\src\gallium\auxiliary\target-helpers\sw_helper.h:90)</span><br><span class="line">libvulkan_lvp.so!pipe_loader_sw_create_screen(struct pipe_loader_device * dev, const struct pipe_screen_config * config, _Bool sw_vk) (\home\luc\gh\forked\src\gallium\auxiliary\pipe-loader\pipe_loader_sw.c:427)</span><br><span class="line">libvulkan_lvp.so!pipe_loader_create_screen_vk(struct pipe_loader_device * dev, _Bool sw_vk, _Bool driver_name_is_inferred) (\home\luc\gh\forked\src\gallium\auxiliary\pipe-loader\pipe_loader.c:181)</span><br><span class="line">libvulkan_lvp.so!lvp_physical_device_init(struct lvp_physical_device * device, struct lvp_instance * instance, struct pipe_loader_device * pld) (\home\luc\gh\forked\src\gallium\frontends\lavapipe\lvp_device.c:1240)</span><br><span class="line">libvulkan_lvp.so!lvp_enumerate_physical_devices(struct vk_instance * vk_instance) (\home\luc\gh\forked\src\gallium\frontends\lavapipe\lvp_device.c:1416)</span><br><span class="line">libvulkan_lvp.so!enumerate_physical_devices_locked(struct vk_instance * instance) (\home\luc\gh\forked\src\vulkan\runtime\vk_instance.c:434)</span><br><span class="line">libvulkan_lvp.so!enumerate_physical_devices(struct vk_instance * instance) (\home\luc\gh\forked\src\vulkan\runtime\vk_instance.c:459)</span><br><span class="line">libvulkan_lvp.so!vk_common_EnumeratePhysicalDevices(VkInstance _instance, uint32_t * pPhysicalDeviceCount, VkPhysicalDevice * pPhysicalDevices) (\home\luc\gh\forked\src\vulkan\runtime\vk_instance.c:475)</span><br><span class="line">libvulkan.so.1![Unknown/Just-In-Time compiled code] (Unknown Source:0)</span><br><span class="line">libvulkan.so.1!vkEnumeratePhysicalDevices (Unknown Source:0)</span><br><span class="line">vk::DispatchLoaderStatic::vkEnumeratePhysicalDevices(const vk::DispatchLoaderStatic * const this, VkInstance instance, uint32_t * pPhysicalDeviceCount, VkPhysicalDevice * pPhysicalDevices) (\usr\local\include\vulkan\vulkan.hpp:1047)</span><br><span class="line">vk::Instance::enumeratePhysicalDevices&lt;std::allocator&lt;vk::PhysicalDevice&gt;, vk::DispatchLoaderStatic&gt;(const vk::DispatchLoaderStatic &amp; d, const vk::Instance * const this) (\usr\local\include\vulkan\vulkan_funcs.hpp:120)</span><br><span class="line">vks::Context::pickDevice(vks::Context * const this, const vk::SurfaceKHR &amp; surface) (\home\luc\gh\VulkanExamples\base\vks\context.hpp:426)</span><br><span class="line">vks::Context::createDevice(vks::Context * const this, const vk::SurfaceKHR &amp; surface) (\home\luc\gh\VulkanExamples\base\vks\context.hpp:233)</span><br><span class="line">vkx::ExampleBase::initVulkan(vkx::ExampleBase * const this) (\home\luc\gh\VulkanExamples\base\vulkanExampleBase.cpp:123)</span><br><span class="line">vkx::ExampleBase::run(vkx::ExampleBase * const this) (\home\luc\gh\VulkanExamples\base\vulkanExampleBase.cpp:75)</span><br><span class="line">main(const int argc, const char ** argv) (\home\luc\gh\VulkanExamples\examples\deferredmultisampling\deferredmultisampling.cpp:684)</span><br></pre></td></tr></table></figure>
<h1 id="debug-options"><a class="markdownIt-Anchor" href="#debug-options"></a> Debug Options</h1>
<p>就像其它 Gallium 驱动一样，llvmpipe 也提供了很多调试和性能测试的选项, 这此选项通过环境变量 <code>LP_DEBUG</code> 和 <code>LP_PERF</code> 来设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug_parse_flags_option: help for LP_DEBUG:</span><br><span class="line">|        pipe [0x0000000000000001]</span><br><span class="line">|        tgsi [0x0000000000000002]</span><br><span class="line">|         tex [0x0000000000000004]</span><br><span class="line">|       setup [0x0000000000000010]</span><br><span class="line">|        rast [0x0000000000000020]</span><br><span class="line">|       query [0x0000000000000040]</span><br><span class="line">|      screen [0x0000000000000080]</span><br><span class="line">|    counters [0x0000000000000800]</span><br><span class="line">|       scene [0x0000000000001000]</span><br><span class="line">|       fence [0x0000000000002000]</span><br><span class="line">| no_fastpath [0x0000000000080000]</span><br><span class="line">|      linear [0x0000000000100000]</span><br><span class="line">|     linear2 [0x0000000000200000]</span><br><span class="line">|         mem [0x0000000000004000]</span><br><span class="line">|          fs [0x0000000000008000]</span><br><span class="line">|          cs [0x0000000000010000]</span><br><span class="line">| accurate_a0 [0x0000000000800000]</span><br><span class="line">|        mesh [0x0000000001000000]</span><br><span class="line">debug_parse_flags_option: help for LP_PERF:</span><br><span class="line">|         texmem [0x0000000000000001]</span><br><span class="line">|      no_mipmap [0x0000000000000004]</span><br><span class="line">|      no_linear [0x0000000000000008]</span><br><span class="line">|  no_mip_linear [0x0000000000000002]</span><br><span class="line">|         no_tex [0x0000000000000010]</span><br><span class="line">|       no_blend [0x0000000000000020]</span><br><span class="line">|       no_depth [0x0000000000000040]</span><br><span class="line">|   no_alphatest [0x0000000000000080]</span><br><span class="line">| no_rast_linear [0x0000000000000100]</span><br><span class="line">|       no_shade [0x0000000000000200]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan</title>
    <url>/gfx/vk/</url>
    <content><![CDATA[<p>Vulkan 是一个低开销、跨平台的二维和三维图形与计算的应用程序接口，由 Khronos 在2015年在 GDC 上首次发布。它旨在提供高效能和更均衡的 CPU 和 GPU 占用，类似于 Direct3D 12 和 AMD Mantle。</p>
<p>在这里主要收集一些与 Vulkan 强相关的一些项目，便于 Vulkan 的学习和使用。</p>
<span id="more"></span>
<h1 id="vulkan-sdk"><a class="markdownIt-Anchor" href="#vulkan-sdk"></a> <a href="https://vulkan.lunarg.com/">vulkan-sdk</a></h1>
<p>Vulkan SDK 为开发者提供了开发和调试 Vulkan 应用程序的关键工具，主要包括:</p>
<ul>
<li>Vulkan-Headers</li>
<li>Vulkan-Tools</li>
<li>SPIRV-Tools</li>
<li>glslang</li>
<li>VulkanMemoryAllocator (vma)</li>
<li>Vulkan-Utilities-Library (vul)</li>
</ul>
<p>这些基本都是 C++ 编写的工具或库。</p>
<p>LunarG 官方的 vulkan-sdk 同时会提供 Binary 和一个 vulkansdk 脚本，以及一个环境变量配置脚本。通常解压 (<code>tar -xvJf</code>) 后只需要</p>
<p><code>source setup-env.sh</code></p>
<p>SDK 中包含的所有库，应用程序及 cmake 文件都会在当前终端生效。另外，vulkansdk 允许用户方便地有选择地安装 SDK 包含的工具，例如单独下载安装 Vulkan-Headers:</p>
<p><code>./vulkansdk --skip-deps vulkan-headers</code></p>
<p>(注意 vulkansdk 默认都会将指定安装的项目安装在当前路径下的 <code>$(arch)</code> 目录下，这个安装路径在编译 Vulkan-Tools 时需要被设置到 Vulkan-Tools 的 cmake 变量 <code>-DVULKAN_HEADERS_INSTALL_DIR=/home/luc/gh/1.3.290.0/x86_64</code> 原因是 Vulkan-Tools 需要用到这个路径下的 Python 模块)</p>
<h2 id="vulkan-headers"><a class="markdownIt-Anchor" href="#vulkan-headers"></a> <a href="https://github.com/KhronosGroup/Vulkan-Headers">Vulkan-Headers</a></h2>
<p>Vulkan-Headers 主要包含 Vulkan API 的头文件和一些用于(根据 Khronos XML 文件)自动生成头文件的Python 脚本。Vulkan-Headers 的版本变更和 vulkan-sdk 是同步的，基本上所有 Vulkan 的相关的工具或库都依赖它。</p>
<p>例如 Vulkan-Tools 中的 vulkaninfo, 当需要构建它时，就需要指定 <code>-DVULKAN_HEADERS_INSTALL_DIR</code>, 而且必须将 Vulkan-Tools 仓库的 tag 检出到和 Vulkan-Headers 仓库的一样才能编译成功。</p>
<h1 id="vulkan-hpp"><a class="markdownIt-Anchor" href="#vulkan-hpp"></a> <a href="https://github.com/KhronosGroup/Vulkan-Hpp">Vulkan-Hpp</a></h1>
<p>Vulkan-Hpp 旨在为 Vulkan C API 提供头文件(header only)形式的 C++ 绑定, 以此来简化 Vulkan 应用的开发过程同时不引入额外的 CPU 运行时开销。 Vulkan-Hpp 依赖 Vulkan-Headers, 而且它俩同时是 vulkan-sdk 的一部分, 它们三者的版本号应该都要一致 (定义在 <code>$&#123;CMAKE_INSTALL_PREFIX&#125;/include/vulkan/vulkan_core.h</code> 的 <code>VK_HEADER_VERSION</code>)。 实际上， Vulkan-Hpp 里包含一个 <code>VulkanHppGenerator</code> 程序，它会自动重新生成 vulkan 的一些头文件。</p>
<pre><code class="highlight mermaid">flowchart LR
    A[&quot;Vulkan Registry XML&quot;]
    B[&quot;Vulkan .h/.hpp headers&quot;]
    C[&quot;Vulkan .hpp headers&quot;]
    A--&gt;|Vulkan-Headers .py|B
    B--&gt;|VulkanHppGenerator|C</code></pre>
<h2 id="vulkan-tools"><a class="markdownIt-Anchor" href="#vulkan-tools"></a> <a href="https://github.com/KhronosGroup/Vulkan-Tools">Vulkan-Tools</a></h2>
<ul>
<li><code>vulkaninfo --summary</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VULKANINFO</span><br><span class="line">==========</span><br><span class="line"></span><br><span class="line">Vulkan Instance Version: 1.3.261</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Instance Extensions: count = 17</span><br><span class="line">-------------------------------</span><br><span class="line">VK_EXT_debug_report                    : extension revision 10</span><br><span class="line">VK_EXT_debug_utils                     : extension revision 2</span><br><span class="line">VK_EXT_headless_surface                : extension revision 1</span><br><span class="line">VK_EXT_surface_maintenance1            : extension revision 1</span><br><span class="line">VK_EXT_swapchain_colorspace            : extension revision 5</span><br><span class="line">VK_KHR_device_group_creation           : extension revision 1</span><br><span class="line">VK_KHR_external_fence_capabilities     : extension revision 1</span><br><span class="line">VK_KHR_external_memory_capabilities    : extension revision 1</span><br><span class="line">VK_KHR_external_semaphore_capabilities : extension revision 1</span><br><span class="line">VK_KHR_get_physical_device_properties2 : extension revision 2</span><br><span class="line">VK_KHR_get_surface_capabilities2       : extension revision 1</span><br><span class="line">VK_KHR_portability_enumeration         : extension revision 1</span><br><span class="line">VK_KHR_surface                         : extension revision 25</span><br><span class="line">VK_KHR_surface_protected_capabilities  : extension revision 1</span><br><span class="line">VK_KHR_xcb_surface                     : extension revision 6</span><br><span class="line">VK_KHR_xlib_surface                    : extension revision 6</span><br><span class="line">VK_LUNARG_direct_driver_loading        : extension revision 1</span><br><span class="line"></span><br><span class="line">Instance Layers: count = 13</span><br><span class="line">---------------------------</span><br><span class="line">VK_LAYER_FROG_gamescope_wsi       Gamescope WSI (XWayland Bypass) Layer (x86_64) 1.3.221  version 1</span><br><span class="line">VK_LAYER_INTEL_nullhw             INTEL NULL HW                                  1.1.73   version 1</span><br><span class="line">VK_LAYER_KHRONOS_profiles         Khronos Profiles layer                         1.3.280  version 1</span><br><span class="line">VK_LAYER_KHRONOS_shader_object    Khronos Shader object layer                    1.3.280  version 1</span><br><span class="line">VK_LAYER_KHRONOS_synchronization2 Khronos Synchronization2 layer                 1.3.280  version 1</span><br><span class="line">VK_LAYER_KHRONOS_validation       Khronos Validation Layer                       1.3.280  version 1</span><br><span class="line">VK_LAYER_LUNARG_api_dump          LunarG API dump layer                          1.3.280  version 2</span><br><span class="line">VK_LAYER_LUNARG_gfxreconstruct    GFXReconstruct Capture Layer Version 1.0.3     1.3.280  version 4194307</span><br><span class="line">VK_LAYER_LUNARG_monitor           Execution Monitoring Layer                     1.3.280  version 1</span><br><span class="line">VK_LAYER_LUNARG_screenshot        LunarG image capture layer                     1.3.280  version 1</span><br><span class="line">VK_LAYER_MANGOHUD_overlay_x86_64  Vulkan Hud Overlay                             1.3.0    version 1</span><br><span class="line">VK_LAYER_MESA_device_select       Linux device selection layer                   1.3.211  version 1</span><br><span class="line">VK_LAYER_MESA_overlay             Mesa Overlay layer                             1.3.211  version 1</span><br><span class="line"></span><br><span class="line">Devices:</span><br><span class="line">========</span><br><span class="line">GPU0:</span><br><span class="line">        apiVersion         = 1.3.255</span><br><span class="line">        driverVersion      = 0.0.1</span><br><span class="line">        vendorID           = 0x10005</span><br><span class="line">        deviceID           = 0x0000</span><br><span class="line">        deviceType         = PHYSICAL_DEVICE_TYPE_CPU</span><br><span class="line">        deviceName         = llvmpipe (LLVM 15.0.7, 256 bits)</span><br><span class="line">        driverID           = DRIVER_ID_MESA_LLVMPIPE</span><br><span class="line">        driverName         = llvmpipe</span><br><span class="line">        driverInfo         = Mesa 23.2.1-1ubuntu3.1~22.04.2 (LLVM 15.0.7)</span><br><span class="line">        conformanceVersion = 1.3.1.1</span><br><span class="line">        deviceUUID         = 6d657361-3233-2e32-2e31-2d3175627500</span><br><span class="line">        driverUUID         = 6c6c766d-7069-7065-5555-494400000000</span><br><span class="line">GPU1:</span><br><span class="line">        apiVersion         = 1.3.292</span><br><span class="line">        driverVersion      = 0.0.1</span><br><span class="line">        vendorID           = 0x10005</span><br><span class="line">        deviceID           = 0x0000</span><br><span class="line">        deviceType         = PHYSICAL_DEVICE_TYPE_CPU</span><br><span class="line">        deviceName         = llvmpipe (LLVM 16.0.0, 256 bits)</span><br><span class="line">        driverID           = DRIVER_ID_MESA_LLVMPIPE</span><br><span class="line">        driverName         = llvmpipe</span><br><span class="line">        driverInfo         = Mesa 24.3.0-devel (git-d58f7a24d1) (LLVM 16.0.0)</span><br><span class="line">        conformanceVersion = 1.3.1.1</span><br><span class="line">        deviceUUID         = 6d657361-3234-2e33-2e30-2d6465766500</span><br><span class="line">        driverUUID         = 6c6c766d-7069-7065-5555-494400000000</span><br></pre></td></tr></table></figure>
<ul>
<li>vkcube/vkcubepp
<ul>
<li><code>vkcube --gpu_number 1 --width 800 --height 600</code><br />
<img src="/images/vk/vkcube.gif" alt="vkcube" /></li>
</ul>
</li>
</ul>
<h2 id="spirv-tools"><a class="markdownIt-Anchor" href="#spirv-tools"></a> <a href="https://github.com/KhronosGroup/SPIRV-Tools">SPIRV-Tools</a></h2>
<p>SPIRV-Tools 主要收集了与 shader 相关的一整套工具链，包括编译，链接，优化，反汇编等等。它依赖 <a href="https://github.com/KhronosGroup/SPIRV-Headers">SPIRV-Headers</a></p>
<p>SPIRV-Tools 包含的比较常用的工具:</p>
<ul>
<li>spirv-dis</li>
<li>spirv-opt</li>
</ul>
<h1 id="vulkan-samples"><a class="markdownIt-Anchor" href="#vulkan-samples"></a> <a href="https://github.com/KhronosGroup/Vulkan-Samples">Vulkan-Samples</a></h1>
<p><code>./build/app/bin/Debug/x86_64/vulkan_samples sample surface_rotation</code><br />
<img src="/images/vk/surface_rotation.png" alt="surface_rotation" /></p>
<h1 id="vulkanexamples"><a class="markdownIt-Anchor" href="#vulkanexamples"></a> <a href="https://github.com/jherico/VulkanExamples">VulkanExamples</a></h1>
<p>VulkanExamples 是将大部分 <a href="https://github.com/SaschaWillems/Vulkan">Sascha Willems 的 Vulkan examples</a> 移植到 Vulkan-Hpp, 但当我试着在 Ubuntu 20.04.3 上编译并在 LAVApipe 是运行时，发现一个问题，大多数 Demo 会 assert:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gears: ../src/vulkan/runtime/vk_render_pass.c:2347: vk_common_CmdBeginRenderPass2: Assertion `image_view-&gt;format == pass_att-&gt;format&#x27; failed.</span><br></pre></td></tr></table></figure>
<p>原因是 VulkanExamples 的 <code>ExampleBase::colorformat</code> 默认是 <code>vk::Format::eB8G8R8A8Unorm</code>, 而驱动侧 wsi 从窗口系统(Ubuntu 20.04.3是 X11) 获取的 visual 格式会在下面的 format 数据里顺序匹配:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const VkFormat formats[] = &#123;</span><br><span class="line">   VK_FORMAT_R5G6B5_UNORM_PACK16,</span><br><span class="line">   VK_FORMAT_B8G8R8A8_SRGB,</span><br><span class="line">   VK_FORMAT_B8G8R8A8_UNORM,</span><br><span class="line">   VK_FORMAT_A2R10G10B10_UNORM_PACK32,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而 VulkanExamples base 只会从 <code>physicalDevice.getSurfaceFormatsKHR()</code> 返回的列表里取第一个格式，而它取回的是 <code>vk::Format::eB8G8R8A8Srgb</code>, 所以才会导致驱动 <code>vk_common_CmdBeginRenderPass2()</code> 的断言失败。mesa 的 wsi common 层之所以会将 <code>VK_FORMAT_B8G8R8A8_SRGB</code> 放到 <code>VK_FORMAT_B8G8R8A8_UNORM</code> 前面，应该是考虑到在应用程序中可能 sRGB 颜色空间使用更为广泛吧(doge)。</p>
<p>而且 <a href="https://github.com/KhronosGroup/Vulkan-Samples">KhronosGroup/Vulkan-Samples</a> 自从 <a href="https://github.com/KhronosGroup/Vulkan-Samples/commit/38d628b032a88cf032e88877c1b75aa470333c32">38d628b032a8</a> 就已经首选 <code>vk::Format::eR8G8B8A8Srgb</code> 作为 swapchain image 的格式了。</p>
<p>将 <code>ExampleBase::colorformat</code> 改为 sRGB 后的对比效果(哪个是 sRGB 呢?)<br />
<img src="/images/vk/gears-srgb.gif" alt="gears-srgb" /><br />
<img src="/images/vk/gears-rgb.gif" alt="gears-rgb" /></p>
<h1 id="vulkan-icd"><a class="markdownIt-Anchor" href="#vulkan-icd"></a> Vulkan ICD</h1>
<p>Vulkan ICD (Installable Client Driver) 可安装客户端驱动程序是 Vulkan 生成系统中的关键组件。它在 Vulkan 应用程序和系统上安装的各种 Vulkan 驱动程序之间充当桥梁。每个 Vulkan 驱动程序有带有一个 ICD JSON 文件，它里面描述了驱动动态库文件的路径，以便 Vulkan-Loader 可以枚举系统安装的每个 Vulkan 驱动。ICD Json 文件的路径和命名都是规范的:</p>
<ul>
<li>命名规范
<ul>
<li><code>driver_name</code>_icd.<code>$arch</code>.json</li>
</ul>
</li>
<li>路径规范
<ul>
<li><code>$&#123;CMAKE_INSTALL_PREFIX&#125;</code>/<code>$&#123;CMAKE_INSTALL_DATADIR&#125;</code>/vulkan/icd.d/</li>
</ul>
</li>
</ul>
<p>Vulkan ICD 可以类比 OpenGL 世界的 <a href="https://gitlab.freedesktop.org/glvnd/libglvnd">GLVND (GL Vendor-Neutral Dispatch library)</a>, GLVND 的目的同样是在同一系统上允许多个 OpenGL 驱动库共存，并在运行时决定将每个 API 调用分派给哪个供应商的驱动。只不过 GLVND 的 GLX 没有使用 JSON 文件，而是依靠环境变量:</p>
<p>export __GLX_VENDOR_LIBRARY_NAME=<code>driver_name</code></p>
<p><code>driver_name</code> 就是 OpenGL 驱动库文件 libGLX_<code>driver_name</code>.so 的一部分, 这种方式更依赖于动态链接库 <em><a href="http://dl.so">dl.so</a></em></p>
<p>而 GLVND 的 EGL 实现基本上与 Vulkan ICD 是一样的(可能Vulkan ICD 就是来源于 GLVND EGL ICD)。GLVND EGL ICD 的 JSON 文件命名规范和安装路径规范:</p>
<ul>
<li>命名规范
<ul>
<li>10_<code>myvendor</code>.<code>$arch</code>.json</li>
</ul>
</li>
<li>路径规范
<ul>
<li><code>$&#123;CMAKE_INSTALL_PREFIX&#125;</code>/<code>$&#123;CMAKE_INSTALL_DATADIR&#125;</code>/glvnd/egl_vendor.d/</li>
</ul>
</li>
</ul>
<h1 id="vulkan-wsi"><a class="markdownIt-Anchor" href="#vulkan-wsi"></a> Vulkan WSI</h1>
<p>Vulkan WSI (Window System Integration) 是Vulkan API 的一个重要组成部分，用于将渲染结果显示在不同平台的窗口系统上。WSI 通过一系列可选的 Vulkan 扩展来实现，这些扩展抽象了每个平台的窗口机制，使得 Vulkan API 可以在各种平台上使用。</p>
<ul>
<li>VK_KHR_surface (object/handle <code>VkSurfaceKHR</code>)
<ul>
<li>VK_KHR_win32_surface</li>
<li>VK_KHR_android_surface</li>
<li>VK_KHR_wayland_surface</li>
<li>VK_KHR_xcb_surface, VK_KHR_xlib_surface</li>
<li>VK_MVK_macos_surface</li>
<li>VK_MVK_ios_surface</li>
</ul>
</li>
<li>VK_KHR_swapchain (object/handle <code>VkSwapchainKHR</code>)</li>
</ul>
<p><em>注意: <code>VkSurfaceKHR</code> 和 <code>VkSwapchainKHR</code> 本质上都是一个指向结构体的指针类型，即 <code>struct VkSurfaceKHR_T *</code> (详见 <a href="https://github.com/KhronosGroup/Vulkan-Headers/blob/main/include/vulkan/vulkan_core.h#L57">vulkan_core.h</a>)</em></p>
<ul>
<li>Vulkan SDK 自带的 vulkaninfo 在 Ubuntu 20.04/22.04 (llvmpipe Vulkan 驱动)段错误
<ul>
<li>Vulkan SDK 自带的 vulkaninfo 在编译时应该没有关闭 <code>-DBUILD_WSI_WAYLAND_SUPPORT</code></li>
<li>Ubuntu 20.04/22.04 的 Mesa 实现中 <code>vkIcdWsiPlatform</code> 不支持 wayland 平台
<ul>
<li>mesa 中的 <code>struct wsi_device</code> 定义了一个 <code>struct wsi_interface *</code> 的一个数组 <code>wsi[VK_ICD_WSI_PLATFORM_MAX]</code>, 在 Ubuntu 20.04/22.04 上该表 <code>VK_ICD_WSI_PLATFORM_WAYLAND</code> 对应的 wsi_interface 是空的  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">            (gdb) p wsi_device-&gt;wsi</span><br><span class="line">            $2 = &#123;0x0, 0x0, 0x0, 0x555555744e00, 0x555555744e00, 0x0, 0x0, 0x0, 0x555555702560, 0x555555753330&#125;</span><br><span class="line">            (gdb) ptype surface-&gt;platform</span><br><span class="line">type = enum &#123;VK_ICD_WSI_PLATFORM_MIR, VK_ICD_WSI_PLATFORM_WAYLAND, VK_ICD_WSI_PLATFORM_WIN32, VK_ICD_WSI_PLATFORM_XCB, VK_ICD_WSI_PLATFORM_XLIB, VK_ICD_WSI_PLATFORM_ANDROID, VK_ICD_WSI_PLATFORM_MACOS, VK_ICD_WSI_PLATFORM_IOS, VK_ICD_WSI_PLATFORM_DISPLAY, VK_ICD_WSI_PLATFORM_HEADLESS, VK_ICD_WSI_PLATFORM_METAL, VK_ICD_WSI_PLATFORM_DIRECTFB, VK_ICD_WSI_PLATFORM_VI, VK_ICD_WSI_PLATFORM_GGP, VK_ICD_WSI_PLATFORM_SCREEN, VK_ICD_WSI_PLATFORM_FUCHSIA&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="lavapipe"><a class="markdownIt-Anchor" href="#lavapipe"></a> <a href="https://gitlab.freedesktop.org/mesa/mesa/-/tree/main/src/gallium/frontends/lavapipe">LAVApipe</a></h1>
<p>Vulkan 的软实现，不依赖任何 GPU, 但它和 llvmpipe 一样，依赖 LLVM。构建它依赖:</p>
<ul>
<li>LLVM</li>
<li><a href="https://github.com/KhronosGroup/SPIRV-LLVM-Translator">SPIRV-LLVM-Translator</a>
<ul>
<li>(SPIRV-LLVM-Translator 的版本似乎与 LLVM 的版本有严格的耦合，亲测如果 <code>BASE_LLVM_VERSION=20.0.0</code>, 实际安装的 LLVM 是 16.0.0 编译失败)</li>
</ul>
</li>
</ul>
<h1 id="zink"><a class="markdownIt-Anchor" href="#zink"></a> <a href="https://docs.mesa3d.org/drivers/zink.html">Zink</a></h1>
<p>Zink 不是某个具体 GPU 的驱动，而是一个将OpenGL API 调用翻译成 Vulkan API, 以在只有Vulkan 驱动的平台上提供完整OpenGL支持。例如，同时编译安装 Mesa 的 Zink (-Dgallium-drivers=zink)和 LAVApipe (-Dvulkan-drivers=swrast) 驱动，你就不仅可以跑 vkcube 也可以跑 glxgears。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User defined options</span><br><span class="line">  buildtype                    : debug</span><br><span class="line">  prefix                       : /usr</span><br><span class="line">  cpp_rtti                     : false</span><br><span class="line">  gallium-drivers              : zink</span><br><span class="line">  glx                          : dri</span><br><span class="line">  llvm                         : enabled</span><br><span class="line">  platforms                    : x11</span><br><span class="line">  vulkan-drivers               : swrast</span><br></pre></td></tr></table></figure>
<p>但是在软渲染上跑需要提供一些环境变量 <code>MESA_LOADER_DRIVER_OVERRIDE=zink LIBGL_KOPPER_DRI2=true LIBGL_ALWAYS_SOFTWARE=true ZINK_DEBUG=nir glxgears</code></p>
<ul>
<li><code>LIBGL_KOPPER_DRI2=true</code> 是因为我的环境上没有 DRI3, Zink 在没有 DRI3 支持, 且用户没有要求使用 DRI2 的情况下是不被使能的。</li>
<li><code>LIBGL_ALWAYS_SOFTWARE=true</code> 是因为 zink 的实现要求 <a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/gallium/drivers/zink/zink_screen.c#L1763"><code>/* allow software rendering only if forced by the user */</code></a></li>
<li><code>ZINK_DEBUG=nir</code> 为了能直观地看到驱动使用的是 Zink 而非 LLVMpipe 的OpenGL实现，特意加了 Zink 调试环境变量，将 shader 的 NIR 打印出来
<ul>
<li>glxgears on Zink<br />
<img src="/images/vk/glxgears-on-zink.gif" alt="glxgears on Zink" /></li>
<li>glmark2 on Zink<br />
<img src="/images/vk/glmark2-on-zink.gif" alt="glmark2 on Zink" /></li>
</ul>
</li>
</ul>
<h1 id="appendix-apt-install-2304-lunar-lobster"><a class="markdownIt-Anchor" href="#appendix-apt-install-2304-lunar-lobster"></a> Appendix: apt install (23.04 Lunar Lobster)</h1>
<p><strong>书到用时方恨少，包到装时不好找</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y cmake ninja-build bison flex g++ git pkg-config python3-setuptools python3-lz4 \</span><br><span class="line">    python3-jinja2 libssl-dev libelf-dev libboost-dev libglm-dev libtinyobjloader-dev libstb-dev \</span><br><span class="line">    libpng-dev wayland-protocols libwayland-dev libdecor-0-dev freeglut3-dev libexpat1-dev libglvnd-dev \</span><br><span class="line">    libx11-dev libxext-dev libxshmfence-dev libxrandr-dev libxxf86vm-dev libxfixes-dev libx11-xcb-dev \</span><br><span class="line">    libxcb1-dev libxcb-randr0-dev libxcb-glx0-dev libxcb-shm0-dev libxcb-dri3-dev libxcb-dri2-0-dev libxcb-present-dev \</span><br><span class="line">    libselinux1-dev libvulkan-dev vulkan-tools mesa-utils</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>VkSemaphore</title>
    <url>/gfx/vksem/</url>
    <content><![CDATA[<pre><code class="highlight mermaid">---
title: VkSemaphore interface
---
classDiagram
    VkSemaphore ()-- vk_semaphore
    vk_object_base &lt;|-- vk_semaphore
    vk_semaphore &lt;|.. vk_sync
    vk_sync -- vk_sync_type
    link vk_semaphore &quot;https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/vulkan/runtime/vk_semaphore.h&quot; &quot;vk_semaphore&quot;
    link vk_sync &quot;https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/vulkan/runtime/vk_sync.h&quot; &quot;vk_sync&quot;
    link vk_sync_type &quot;https://gitlab.freedesktop.org/mesa/mesa/-/blob/main/src/vulkan/runtime/vk_sync.h&quot; &quot;vk_sync_type&quot;
    class vk_object_base&#123;
        VK_LOADER_DATA _loader_data
        VkObjectType type
        bool client_visible
        vk_device *device
        vk_instance *instance
        util_sparse_array private_data
        char *object_name
    &#125;
    class vk_semaphore&#123;
        VkSemaphoreType type
        vk_sync *temporary
        vk_sync permanent
    &#125;
    class vk_sync&#123;
        vk_sync_type *type
        vk_sync_flags flags
    &#125;
    class vk_sync_type&#123;
        size_t size
        vk_sync_features features
        init() VkResult
        finish() void
        signal() VkResult
        get_value() VkResult
        reset() VkResult
        move() VkResult
        wait() VkResult
        wait_many() VkResult
        import_opaque_fd() VkResult
        export_opaque_fd() VkResult
        import_sync_file() VkResult
        export_sync_file() VkResult
        import_win32_handle() VkResult
        export_win32_handle() VkResult
        set_win32_export_params() VkResult
    &#125;
    &lt;&lt;interface&gt;&gt; vk_sync_type</code></pre>
<span id="more"></span>
<p>如果把基于 Vulkan 的渲染看成一个图，那么 <code>VkCommandBuffer</code> 是节点 (node)，<code>VkSemaphore</code> 是边 (edge)</p>
<pre><code class="highlight mermaid">flowchart LR
    subgraph &quot;Process 1&quot;
        c1((VkCommandBuffer 1))
    end
    subgraph &quot;Process 2&quot;
        c2((VkCommandBuffer 2))
        c3((VkCommandBuffer 3))
    end
    subgraph &quot;Process 3&quot;
        c4((VkCommandBuffer 4))
        c5((VkCommandBuffer 5))
    end

    c1 --VkSemaphore 1--&gt; c2
    c2 --VkSemaphore 2--&gt; c4
    c3 --VkSemaphore 3--&gt; c5
    c1 --VkSemaphore 4--&gt; c5</code></pre>
<h1 id="implicit-sync-好好的为什么在-vulkan-里要搞-explicit-sync"><a class="markdownIt-Anchor" href="#implicit-sync-好好的为什么在-vulkan-里要搞-explicit-sync"></a> Implicit Sync 好好的，为什么在 Vulkan 里要搞 Explicit Sync?</h1>
<p>Implicit Sync 由内核负责，应用(甚至 UMD) 不用操心，确实也能工作，但是 implicit sync 存在<strong>过度同步 (over-synchronization)</strong> 的问题，必然导致不能最大限度地发挥出 CPU 和 GPU 的并行能力。</p>
<p>为什么 implicit sync 会有过度同步的问题? implicit sync 说白了，是由内核在不知道应用确切同步要求(谁等什么，什么时候完成)的情况下<strong>一股脑儿</strong>地给你进行<strong>不分青红皂白</strong>地阻塞式同步，是能正常工作，但不够精细，好多地方可能是白等了。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://www.collabora.com/news-and-blog/blog/2022/06/09/bridging-the-synchronization-gap-on-linux">Brigding the synchronization gap on Linux</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Wayland</title>
    <url>/gfx/wayland/</url>
    <content><![CDATA[<h1 id="wayland-architecture"><a class="markdownIt-Anchor" href="#wayland-architecture"></a> Wayland Architecture</h1>
<p>为了理解wayland的架构和它与X的区别，最好是看看从一个输入事件到这个输入事件的结果呈现到屏幕上这个过程都发生了什么。</p>
<span id="more"></span>
<img src="/gfx/wayland/x-architecture.png" class="" title="X Architecture">
<ol>
<li>
<p>kernel获取到一个输入事件，通过<code>evdev</code>输入设备驱动发送给X Server.这里kernel做了很多工作，包括驱动输入设备，转换各种不同的设备事件协议为标准的Linux <code>evdev</code>输入事件。</p>
</li>
<li>
<p>X Server决定这个事件影响哪个窗口，并发送这个事件给该窗口所属的那些客户端，但问题是，X Server并不能真正确定是哪个窗口，因为在屏幕坐标里的窗口位置是由compositor控制的，窗口位置可以被很多操作改变，缩小，旋转，晃动等等，而X Server并不知晓这些操作。</p>
</li>
<li>
<p>客户端收到这个事件，然后决定做什么。通常对事件的响应是UI的改变，也许是一个多选框被打勾，也许是鼠标落到一个按钮上，按钮高亮。因此客户端又向X Server发回一个渲染请求。</p>
</li>
<li>
<p>当X Server收到渲染请求后，又转发给驱动，由驱动控制图形硬件完成渲染，这里的驱动可能是像AMD显卡的驱动，也可能是一个像Mesa这样的OpenGL软件实现。X Server负责计算渲染区域的边界，以一个<code>damage event</code>发送结果给compositor.</p>
</li>
<li>
<p><code>damage event</code>告诉compositor, 窗口的内容已经改变，如果这个窗口是可见的，那么需要重新合成屏幕的这一部分。compositor基于它的场景图和X Window的内容负责渲染整个屏幕，但是它还得通过X Server去完成渲染，因为只有X Server才能和驱动打交道。</p>
</li>
<li>
<p>X Server收到compositor的渲染请求后，或者拷贝compositor back buffer到front buffer,或者做一次pageflip. 通常情况下，X Server必须做这一步，因为它需要计算窗口重叠，这可能需要裁剪操作，并且决定它是否可以pageflip. 但是，对于总是执行全屏操作的compositor来说，这又是一次不必要的上下文切换。</p>
</li>
</ol>
<p>上面的X Server的工作流程有一些问题。首先, X Server没有相关的信息去决定到底哪个窗口应该接收这个输入事件，它也不能将屏幕坐标转换成窗口内部坐标，甚至X Server把最后的屏幕渲染工作的职责都交给了合成管理器，X Server仍然控制着front buffer和modesetting. X Server过去大多数复杂的工作现在要么是在kernel中可以完成(<code>KMS</code>, <code>evdev</code>), 要么可以在一些自包含的库里完成(<code>mesa</code>, <code>fontconfig</code>, <code>freetype</code>, <code>cairo</code>, <code>Qt</code>, 等等). 总的来说，X Server现在已经成了在应用程序和compositor之间，compositor和硬件之间引入额外步骤的中间人了。</p>
<p>在wayland里，compositor就是<strong>Display Server</strong>. 我们把<code>KMS</code>和<code>evdev</code>的控制权移交给compositor. Wayland协议让compositor直接发送输入事件给客户端，让客户端直接发送<code>damage event</code>给compositor.</p>
<img src="/gfx/wayland/wayland-architecture.png" class="" title="Wayland Architecture">
<ol>
<li>
<p>kernel发送输入事件给compositor, 这一步与X Server类似，这没有问题，因为这样可以复用内核中所有的输入设备驱动。</p>
</li>
<li>
<p>compositor浏览它的场景图来决定输入事件应该发给哪个窗口。场景图对应屏幕上的显示，compositor知晓它已经应用到场景图中各个元素的坐标变换，因此compositor可以正确选择哪个窗口接收输入事件，也可以将屏幕坐标转换为窗口内部坐标通过逆变换。所能应用到某个窗口的变换类型完全取决于compositor的实现，只要它可以计算出对应输入事件的逆变换。</p>
</li>
<li>
<p>和X Server的场景类似，当客户端收到输入事件后，它相应地更新UI. 但在wayland下，客户端不再发送渲染请求给谁，渲染任务由客户端自己完成，客户端只需要发送消息告诉compositor哪块区域已经更新了。</p>
</li>
<li>
<p>compositor收集来自它的客户端的<code>damage event</code>, 然后重新合成整个屏幕。compositor能直接发送<code>ioctl</code>请求给KMS执行一次pageflip.</p>
</li>
</ol>
<p><a href="https://wayland.freedesktop.org/architecture.html">[阅读原文]</a></p>
<h2 id="waylandxml"><a class="markdownIt-Anchor" href="#waylandxml"></a> <a href="https://gitlab.freedesktop.org/wayland/wayland">wayland.xml</a></h2>
<h2 id="wayland-scanner"><a class="markdownIt-Anchor" href="#wayland-scanner"></a> <a href="https://gitlab.freedesktop.org/wayland/wayland">wayland-scanner</a></h2>
<pre><code class="highlight mermaid">flowchart LR
  A[wayland.xml]
  B[C headers &amp; glue code]
  A == wayland-scanner ==&gt; B

  click A &quot;https://gitlab.freedesktop.org/wayland/wayland/-/blob/main/protocol/wayland.xml?ref_type=heads&quot; _blank
  click B &quot;https://searchfox.org/mozilla-central/source/widget/gtk/wayland/linux-dmabuf-unstable-v1-client-protocol.h#476&quot;</code></pre>
<h2 id="libwayland-clientservercursoregl"><a class="markdownIt-Anchor" href="#libwayland-clientservercursoregl"></a> <a href="https://gitlab.freedesktop.org/wayland/wayland">libwayland-{client,server,cursor,egl}</a></h2>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://wayland-book.com/">Wayland Book</a></li>
<li><a href="https://wayland.app/protocols/hyprland-ctm-control-v1">Wayland Protocol Explorer</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>x11perf</title>
    <url>/gfx/x11perf/</url>
    <content><![CDATA[<h1 id="x11perf"><a class="markdownIt-Anchor" href="#x11perf"></a> <a href="https://gitlab.freedesktop.org/xorg/test/x11perf">x11perf</a></h1>
<p><a href="https://gitlab.freedesktop.org/xorg/test/x11perf">x11perf</a> 是一个 X11 Server 的性能测试程序</p>
<p><img src="/images/x11perf/x11perf-f24itext.png" alt="x11perf -range -ftext,-crgbftext" /></p>
<span id="more"></span>
<h1 id="xlib"><a class="markdownIt-Anchor" href="#xlib"></a> <a href="https://gitlab.freedesktop.org/xorg/lib/libx11">Xlib</a></h1>
<p><a href="https://gitlab.freedesktop.org/xorg/lib/libx11">Xlib</a> 是 X11 核心客户端库，客户端程序基本上都是调用它提供的 API 来绘制图形的。 而 Xlib 的函数基本上都是给 xserver 发请求</p>
<table>
<thead>
<tr>
<th style="text-align:left">File</th>
<th style="text-align:left">Request</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">src/ImText16.c:86:9:</td>
<td style="text-align:left">GetReq (ImageText16, req);</td>
</tr>
<tr>
<td style="text-align:left">src/Text16.c:50:5:</td>
<td style="text-align:left">GetReq (PolyText16, req);</td>
</tr>
<tr>
<td style="text-align:left">src/DrSegs.c:47:2:</td>
<td style="text-align:left">GetReq (PolySegment, req);</td>
</tr>
<tr>
<td style="text-align:left">src/LiHosts.c:85:5:</td>
<td style="text-align:left">GetReq (ListHosts, req);</td>
</tr>
<tr>
<td style="text-align:left">src/PolyTxt.c:49:5:</td>
<td style="text-align:left">GetReq (PolyText8, req);</td>
</tr>
<tr>
<td style="text-align:left">src/SetPntMap.c:43:5:</td>
<td style="text-align:left">GetReq (SetPointerMapping, req);</td>
</tr>
<tr>
<td style="text-align:left">src/SetPntMap.c:66:5:</td>
<td style="text-align:left">GetReq (ChangeKeyboardMapping, req);</td>
</tr>
<tr>
<td style="text-align:left">src/GetProp.c:60:5:</td>
<td style="text-align:left">GetReq (GetProperty, req);</td>
</tr>
<tr>
<td style="text-align:left">src/DrLines.c:45:5:</td>
<td style="text-align:left">GetReq (PolyLine, req);</td>
</tr>
<tr>
<td style="text-align:left">src/xcms/cmsLkCol.c:151:5:</td>
<td style="text-align:left">GetReq (LookupColor, req);</td>
</tr>
<tr>
<td style="text-align:left">src/RotProp.c:44:5:</td>
<td style="text-align:left">GetReq (RotateProperties, req);</td>
</tr>
<tr>
<td style="text-align:left">src/ImText.c:85:9:</td>
<td style="text-align:left">GetReq (ImageText8, req);</td>
</tr>
<tr>
<td style="text-align:left">src/OpenDis.c:532:6:</td>
<td style="text-align:left">GetReq (GetProperty, req);</td>
</tr>
<tr>
<td style="text-align:left">src/SetFPath.c:48:2:</td>
<td style="text-align:left">GetReq (SetFontPath, req);</td>
</tr>
<tr>
<td style="text-align:left">src/ParseCol.c:120:6:</td>
<td style="text-align:left">GetReq (LookupColor, req);</td>
</tr>
<tr>
<td style="text-align:left">src/ChProp.c:47:5:</td>
<td style="text-align:left">GetReq (ChangeProperty, req);</td>
</tr>
<tr>
<td style="text-align:left">src/Text.c:50:5:</td>
<td style="text-align:left">GetReq (PolyText8, req);</td>
</tr>
<tr>
<td style="text-align:left">src/PolyTxt16.c:49:5:</td>
<td style="text-align:left">GetReq (PolyText16, req);</td>
</tr>
<tr>
<td style="text-align:left">src/LookupCol.c:83:2:</td>
<td style="text-align:left">GetReq (LookupColor, req);</td>
</tr>
<tr>
<td style="text-align:left">src/GetImage.c:64:2:</td>
<td style="text-align:left">GetReq (GetImage, req);</td>
</tr>
<tr>
<td style="text-align:left">src/SetCRects.c:46:5:</td>
<td style="text-align:left">GetReq (SetClipRectangles, req);</td>
</tr>
</tbody>
</table>
<p><em>P.S.: formatting command</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rg &#x27;GetReq (.*, req)&#x27; --vimgrep -tc | awk -F&quot;[ \t]+&quot; &#x27;&#123;printf &quot;| %30-s | &quot;, $1; $1=&quot;&quot;; printf &quot;%40-s |\n&quot;, $0&#125;&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="xserver"><a class="markdownIt-Anchor" href="#xserver"></a> <a href="https://gitlab.freedesktop.org/xorg/xserver">Xserver</a></h1>
<p>Xserver 的工作方式是一个典型的 CS 架构，服务端接收到这些请求时，在一个 <code>while</code> 循环里分发和处理这些请求，或者睡眠(Block 自己)。Xserver 这个分发处理逻辑实现在 <a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/dix/dispatch.c#L483">dix/dispatch.c:Dispatch()</a> 函数里。Xserver 甚至搞了一个 <strong><a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/dix/dispatch.c#L338"><code>SmartScheduleClient()</code></a></strong> 的 robin 算法来更高效地服务客户端。</p>
<h1 id="ftext"><a class="markdownIt-Anchor" href="#ftext"></a> ftext</h1>
<pre><code class="highlight mermaid">flowchart TD
    subgraph one [InitText]
        A[&quot;XChangeGC()&quot;]
    end
    subgraph two [DoText]
        B[&quot;XDrawString()&quot;]
    end
    subgraph three [ClearTextWin]
        C[&quot;XClearWindow()&quot;]
    end
    subgraph four [EndText]
        D[&quot;XFreeFont()&quot;]
    end

    one --&gt; two --&gt; three --&gt; four</code></pre>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>X C Bindings</title>
    <url>/gfx/xcb/</url>
    <content><![CDATA[<p>XCB 是应用与 X 服务器交互使用的 C 绑定函数集，它里面的一些 C 函数是通过 python3-xcbgen 工具生成的，不经过编译在它的<a href="https://gitlab.freedesktop.org/xorg/lib/libxcb">源码库</a>是找不到的。而且 XCB 古老到仍然使用 autotools 那套构建系统，想要看到某些函数的“真容”，你还得“千呼万唤”。</p>
<span id="more"></span>
<h1 id="build"><a class="markdownIt-Anchor" href="#build"></a> Build</h1>
<ul>
<li>
<p>安装工具</p>
<ul>
<li><code>sudo apt install python3-xcbgen autoconf automake libtool xutils-dev xcb-proto</code></li>
<li><strong>xutils-dev</strong> 里包含 xorg-macros</li>
<li><strong>libxcb</strong> 的版本与 *<strong>xcb-proto</strong> 软件包的版本有依赖关系，如果你安装的 xcb-proto 版本是 1.14-2, 那么最好将 libxcb 的 tag 也检出到 libxcb-1.14</li>
</ul>
</li>
<li>
<p>构建</p>
<ul>
<li><code>./autogen.sh</code></li>
<li><code>make</code></li>
</ul>
</li>
<li>
<p>千呼万唤始出来</p>
<ul>
<li>在构建完之后，为了保存“成果”，需要使用一点 git 小技巧, 在 <code>src/.gitignore</code> 最后加上
<ul>
<li><code>!*.c</code></li>
</ul>
</li>
<li>现在可以好好看看 <code>xcb_dri3_pixmap_from_buffers()</code> 的实现了
<ul>
<li><a href="https://gitlab.freedesktop.org/lucmann/libxcb/-/tree/v1.14-where-you-will-find-xcb_dri3_pixmap_from_buffers">https://gitlab.freedesktop.org/lucmann/libxcb/-/tree/v1.14-where-you-will-find-xcb_dri3_pixmap_from_buffers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="bindings"><a class="markdownIt-Anchor" href="#bindings"></a> Bindings</h1>
<h2 id="xcb_create_pixmap"><a class="markdownIt-Anchor" href="#xcb_create_pixmap"></a> xcb_create_pixmap</h2>
<pre><code class="highlight mermaid">sequenceDiagram
    autonumber
    participant Mesa
    participant X11

    Mesa--&gt;&gt;X11: xcb_generate_id()
    X11--&gt;&gt;Mesa: uint32_t pid (pixmap id)
    Mesa--&gt;&gt;X11: xcb_create_pixmap()
    X11-&gt;&gt;X11: ProcCreatePixmap()
    note left of X11: CreatePixmapProcPtr 接口，有各种实现&lt;br/&gt;glamor, dri2, xwayland, xnest&lt;br/&gt;当初的 pixmap id 会&lt;br/&gt;记录在创建好的 Pixmap 的 drawable-&gt;id
    X11-&gt;&gt;X11: glamor_create_pixmap(usage=0)
    X11-&gt;&gt;X11: glamor_create_fbo()
    rect rgb(191, 223, 255)
    X11-&gt;&gt;X11: _glamor_create_tex()
    X11--&gt;&gt;Mesa: glGenTextures()
    end
    Mesa--&gt;&gt;X11: xcb_dri3_buffers_from_pixmap(pid)</code></pre>
<h2 id="xcb_dri3_buffers_from_pixmap"><a class="markdownIt-Anchor" href="#xcb_dri3_buffers_from_pixmap"></a> xcb_dri3_buffers_from_pixmap</h2>
<pre><code class="highlight mermaid">sequenceDiagram
    autonumber
    participant Mesa
    participant X11

    Mesa--&gt;&gt;X11: xcb_dri3_buffers_from_pixmap(pid)
    rect rgb(191, 223, 255)
    X11-&gt;&gt;X11: proc_dri3_buffers_from_pixmap()
    X11-&gt;&gt;X11: dixLookupResourceByType(pid)
    note left of X11: 通过 pid 找到当初的 PixmapPtr
    X11-&gt;&gt;X11: dri3_fds_from_pixmap(PixmapPtr)
    rect rgb(200, 150, 255)
    note left of X11: X11 导出 FD
    X11-&gt;&gt;X11: glamor_egl_fds_from_pixmap()
    X11-&gt;&gt;X11: glamor_make_pixmap_exportable()
    X11-&gt;&gt;X11: glamor_gbm_bo_from_pixmap_internal()
    note left of X11: 通过 PixmapPtr 获取 gbm_bo
    X11--&gt;&gt;Mesa: gbm_bo_get_fd()
    Mesa--&gt;&gt;X11: xcb_dri3_buffers_from_pixmap_reply()
    Mesa--&gt;&gt;X11: xcb_dri3_buffers_from_pixmap_reply_fds()
    note right of Mesa: 拿到导出的 FD 需要两步&lt;br/&gt; reply_fds() 才是真正拿到 FD
    end
    rect rgb(200, 150, 255)
    note right of Mesa: Mesa 导入 FD
    Mesa-&gt;&gt;Mesa: dri2_from_dma_bufs2()
    Mesa-&gt;&gt;Mesa: dri2_create_image_from_fd()
    Mesa-&gt;&gt;Mesa: dri2_create_image_from_winsys(winsys_handle)
    loop Every FD
        Mesa-&gt;&gt;Mesa: xxx_resource_from_handle()
        Mesa-&gt;&gt;Mesa: xxx_bo_import()
        note right of Mesa: resource_from_handle() 返回的&lt;br/&gt;pipe_resource 给 __DRIimage.texture
    end
    end
    end</code></pre>
<h2 id="glamor_make_pixmap_exportable"><a class="markdownIt-Anchor" href="#glamor_make_pixmap_exportable"></a> glamor_make_pixmap_exportable</h2>
<p>函数功能:</p>
<ul>
<li>100 创建一个新的 Pixmap <code>exported</code> 用来 export</li>
<li>200 同时创建一个 gbm_bo, 将 <code>exported</code> 的 header 设置成刚创建的 gbm_bo</li>
<li>300 将原来的 Pixmap 的内容 <code>CopyArea()</code> 到 <code>exported</code></li>
<li>400 <code>glamor_egl_exchange_buffers(pixmap, exported)</code>, 将 <code>exported</code> 里的 tex/gbm_bo/EGLImage 换到原来的 Pixmap 结构体中</li>
<li>500 销毁 <code>exported</code> Pixmap</li>
</ul>
<p>步骤 300 暗藏 bug, 因为 <code>CopyArea()</code> 会调用 <code>glamor_copy_fbo_fbo_draw()</code> 将原 Pixmap 作为纹理采样到新的 Pixmap <code>exported</code>, 也就是会调入 <code>_mesa_DrawArrays()</code>, 进而导致这个即将被导出的 BO, 被重新设置成 drawcall 的 render target buffer。 但是 <code>glamor_copy_fbo_fbo_draw()</code> 在调用 <code>_mesa_DrawArrays()</code> 进行&quot;拷贝&quot;后，并<strong>不会 <code>glFlush()</code></strong>, 只能等到 X11 定时触发 <code>Screen-&gt;BlockHandler()</code> 时 <code>glFlush()</code>。</p>
<p>另外一个进程导入 BO 后，同样会设置它为 render target buffer, 这就造成 X11 进程和 App 进程为同一个 render target buffer 都创建了 CommandBuffer, 而提交给 GPU 的先后顺序却变得不确定了(有可能 X11 后提交，取决于 <code>BlockHandler()</code> 触发点)。</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>Xephyr</title>
    <url>/gfx/xephyr/</url>
    <content><![CDATA[<p><a href="https://gitlab.freedesktop.org/xorg/xserver/-/blob/master/hw/kdrive/ephyr/README?ref_type=heads">Xephyr /'zefə/</a> 是一个嵌套的 X Server, 作为 X 应用程序运行。</p>
<figure class="highlight shell"><figcaption><span>Start Xephyr</span></figcaption><table><tr><td class="code"><pre><span class="line">Xephyr :1 -glamor -screen 1024x768 -ac -retro</span><br></pre></td></tr></table></figure>
<p><img src="/images/xephyr/xephyr-ok2.0.png" alt="Xephyr :1 -screen 1024x768 -glamor -ac -retro" /></p>
<span id="more"></span>
<p>Xephyr 比 Xnest 更强大， 因为 Xnest 只是 Host X Server 的一个代理，而 Xephyr 是一个真正的 X Server, 它使用 Host X Server 的一个窗口作为它的 “framebuffer”。Xephyr 对调试与 X Server 交互的应用程序非常有用。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Xephyr">维基百科 - Xephyr</a></li>
<li><a href="https://wiki.archlinuxcn.org/wiki/Xephyr">Archlinux Wiki - Xephyr</a></li>
<li><a href="https://blog.csdn.net/weixin_56291477/article/details/131856800">Xephyr 介绍与使用</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>HiKey970</title>
    <url>/hw/hikey970/</url>
    <content><![CDATA[<h1 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h1>
<h2 id="wsl2-作为上位机"><a class="markdownIt-Anchor" href="#wsl2-作为上位机"></a> WSL2 作为上位机</h2>
<h3 id="识别-windows-11-host-的-usb-serial-device"><a class="markdownIt-Anchor" href="#识别-windows-11-host-的-usb-serial-device"></a> 识别 Windows 11 Host 的 USB Serial Device</h3>
<p>分别在 Windows 11 上安装 <a href="https://github.com/dorssel/usbipd-win">usbipd-win</a>， 在 WSL2 上安装 <a href="https://github.com/dorssel/usbipd-win/wiki/WSL-support">user space tools for USB/IP</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Microsoft Windows [版本 10.0.22621.1702]</span><br><span class="line">(c) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">C:\Windows\System32&gt;usbipd wsl list</span><br><span class="line">BUSID  VID:PID    DEVICE                                                        STATE</span><br><span class="line">1-9    046d:c534  USB 输入设备                                                  Not attached</span><br><span class="line">1-13   04e2:1410  USB 串行设备 (COM4)                                           Not attached</span><br></pre></td></tr></table></figure>
<h3 id="wsl2-ubuntu-2004-创建-devttyusb0"><a class="markdownIt-Anchor" href="#wsl2-ubuntu-2004-创建-devttyusb0"></a> WSL2 Ubuntu-20.04 创建 /dev/ttyUSB0</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Thu Jun 15 19:19:44 2023] vhci_hcd vhci_hcd.0: pdev(0) rhport(0) sockfd(3)</span><br><span class="line">[Thu Jun 15 19:19:44 2023] vhci_hcd vhci_hcd.0: devid(65546) speed(2) speed_str(full-speed)</span><br><span class="line">[Thu Jun 15 19:19:44 2023] vhci_hcd vhci_hcd.0: Device attached</span><br><span class="line">[Thu Jun 15 19:19:45 2023] vhci_hcd: vhci_device speed not set</span><br><span class="line">[Thu Jun 15 19:19:45 2023] usb 1-1: new full-speed USB device number 2 using vhci_hcd</span><br><span class="line">[Thu Jun 15 19:19:45 2023] vhci_hcd: vhci_device speed not set</span><br><span class="line">[Thu Jun 15 19:19:45 2023] usb 1-1: SetAddress Request (2) to port 0</span><br><span class="line">[Thu Jun 15 19:19:45 2023] usb 1-1: New USB device found, idVendor=04e2, idProduct=1410, bcdDevice= 0.03</span><br><span class="line">[Thu Jun 15 19:19:45 2023] usb 1-1: New USB device strings: Mfr=0, Product=0, SerialNumber=0</span><br><span class="line">[Thu Jun 15 19:19:45 2023] xr_serial 1-1:1.0: xr_serial converter detected</span><br><span class="line">[Thu Jun 15 19:19:45 2023] usb 1-1: xr_serial converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure>
<h3 id="recovery-模式应该连接哪个-type-c-usb-serial-接口"><a class="markdownIt-Anchor" href="#recovery-模式应该连接哪个-type-c-usb-serial-接口"></a> Recovery 模式应该连接哪个 Type-C （USB SERIAL) 接口</h3>
<p>HiKey970 有两个 Type-C 接口，而且当板子被设置为 Recovery 模式时，两个接口均会被识别为“串口”。在左手边的 (J3101) 是用来访问 Debug UART 的，而在 HDMI 和 USB 中间的那个(J1801)是在 Recovery 模式下使用的。而且这两个接口是两个不同厂家提供的芯片，使用完全不同的内核驱动模块</p>
<p><img src="/images/hikey970/USB-Serial.png" alt="USB-to-Serial on Hikey970" /></p>
<ul>
<li>前者(J3101)：<br />
<code>Bus 001 Device 003: ID 04e2:1410 Exar Corp. XR21V1410 USB-UART IC</code></li>
</ul>
<p><img src="/images/hikey970/exar-USB-SER-driver.png" alt="Select CONFIG_USB_SERIAL_XR on WSL2 Kernal config" /></p>
<ul>
<li>后者(J1801)：<br />
<code>Bus 001 Device 002: ID 12d1:3609 Huawei Technologies Co., Ltd. USB SER</code></li>
</ul>
<p><img src="/images/hikey970/huawei-USB-SER-driver.png" alt="Select CONFIG_USB_SERIAL_OPTION on WSL2 Kernal config" /></p>
<h1 id="显示"><a class="markdownIt-Anchor" href="#显示"></a> 显示</h1>
<pre><code class="highlight mermaid">flowchart LR
    DPE[&quot;Display Engine&lt;br&gt;(display controller)&quot;]
    DSI[&quot;Display Serial Interface&quot;]
    HDMI[&quot;external HDMI converter&quot;]

    subgraph in-chip
      DPE -- RGB timing --&gt; DSI
    end

    DSI --&gt; HDMI</code></pre>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://www.96boards.org/documentation/consumer/hikey/hikey970/installation/board-recovery.md.html">HiKey970 官方文档</a></li>
<li><a href="https://lore.kernel.org/bpf/20200820100440.2d30dc02@coco.lan/T/">DRM driver for HiKey 970</a></li>
<li><a href="https://github.com/dorssel/usbipd-win/issues/59">usbipd-win github issues</a></li>
</ul>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>SiPEED LicheePi4A</title>
    <url>/hw/licheepi4a/</url>
    <content><![CDATA[<p><img src="/images/licheepi4a/lp4a-closeup.jpg" alt="LicheePi4A close-up" /></p>
<span id="more"></span>
<p><img src="/images/licheepi4a/lp4a-spec.png" alt="LicheePi4A specification" /><br />
<img src="/images/licheepi4a/lp4a-working.jpg" alt="LicheePi4A bring-up" /><br />
<img src="/images/licheepi4a/lp4a-desktop.jpg" alt="LicheePi4A desktop (debian)" /></p>
<h1 id="upstream-drivers"><a class="markdownIt-Anchor" href="#upstream-drivers"></a> Upstream Drivers</h1>
<ul>
<li><a href="https://patchwork.kernel.org/project/dri-devel/patch/20241203134137.2114847-12-m.wilczynski@samsung.com/">drm/imagination: Enable PowerVR driver for RISC-V (WIP)</a></li>
<li><a href="https://lore.kernel.org/all/20241120061848.196754-1-keith.zhao@starfivetech.com/">drm/verisilicon : support DC8200 and inno hdmi (WIP)</a><br />
(平头哥 TH1520 和 赛昉 JH7110 都集成了显示控制器 IP - DC8200 (好像来自芯原))</li>
</ul>
<h1 id="boot-from-sd-card"><a class="markdownIt-Anchor" href="#boot-from-sd-card"></a> Boot from SD-Card</h1>
<p>dd 写入 <a href="https://fast-mirror.isrc.ac.cn/revyos/extra/images/lpi4a/20250110/">img</a> 到 sd-card 之后 lsblk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sda           8:0    1 119.1G  0 disk </span><br><span class="line">├─sda1        8:1    1     2M  0 part </span><br><span class="line">├─sda2        8:2    1   500M  0 part /media/luc/44c74757-aab2-4d25-9ed8-c29e027c3f3f</span><br><span class="line">├─sda3        8:3    1     4G  0 part </span><br><span class="line">└─sda4        8:4    1     5G  0 part /media/luc/f929e2c1-6c06-419a-9c7b-28f5ded4e665</span><br></pre></td></tr></table></figure>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<p><a href="https://docs.revyos.dev/en/docs/Installation/licheepi4a/">Installing RevyOS</a></p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>龙芯 CPU &amp; GPU</title>
    <url>/hw/loongson/</url>
    <content><![CDATA[<h1 id="cpu"><a class="markdownIt-Anchor" href="#cpu"></a> CPU</h1>
<h2 id="ls3a6000"><a class="markdownIt-Anchor" href="#ls3a6000"></a> <a href="https://www.loongson.cn/product/show?id=26">LS3A6000</a></h2>
<p>龙芯的芯片产品可以分为信息化领域和工控/嵌入式领域, 3A6000 也有分别应用于这两个领域的配置，7A2000同样有两种。3A6000 是龙芯第四代微架构的首款产品，同样采用龙芯自主指令集架构LoongArch64(首款LoongArch64架构的处理器是<a href="https://www.loongson.cn/product/show?id=10">3A5000</a>)</p>
<span id="more"></span>
<h1 id="gpu"><a class="markdownIt-Anchor" href="#gpu"></a> GPU</h1>
<h2 id="ls7a2000"><a class="markdownIt-Anchor" href="#ls7a2000"></a> <a href="https://www.loongson.cn/product/show?id=16">LS7A2000</a></h2>
<p>7A2000是第二代龙芯3号系列处理器配置桥片，片内首次集成了自研GPU(应该是 Vivante GC2000), 搭配32位DDR4显存接口，最大支持16GB显存容量。</p>
<h2 id="关于驱动"><a class="markdownIt-Anchor" href="#关于驱动"></a> 关于驱动</h2>
<p>根据龙芯工程师提交的Linux 内核驱动<a href="https://patchwork.freedesktop.org/series/133512/">补丁</a>，LS7A2000 是一个多功能 PCIe 设备(同时有2D, 3D 功能)，为了避免可能的循环依赖问题，驱动采用了内核的 <a href="https://www.kernel.org/doc/html/latest/driver-api/component.html">component framework</a>。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a href="https://blog.xen0n.name/posts/tinkering/loongarch-faq/">1. Unofficial LoongArch FAQ</a></p>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>Resizable PCI BAR</title>
    <url>/hw/pci/</url>
    <content><![CDATA[<p><img src="/images/pci/pci-configuration-space-memory-map.png" alt="pci-configuration-space-memory-map" /></p>
<span id="more"></span>
<h1 id="pci-config-space-span-stylecolor-red256-bytes-per-devicespan"><a class="markdownIt-Anchor" href="#pci-config-space-span-stylecolor-red256-bytes-per-devicespan"></a> PCI Config Space (<span style="color: red;">256 Bytes per Device</span>)</h1>
<p>PCI config space 本质上是 64 个 32-bit 寄存器</p>
<p><img src="/images/pci/pci-configuration-space-headers.png" alt="Type 0 / 1 PCI Configuration Space Header" /></p>
<h2 id="pci-30-type-0-configuration-space-header"><a class="markdownIt-Anchor" href="#pci-30-type-0-configuration-space-header"></a> PCI 3.0 Type 0 Configuration Space Header</h2>
<p><strong>Type 0 Configuration Space Header</strong> 用于最终的实际功能设备，也就是 <strong>Endpoint Device</strong></p>
<h2 id="pci-30-type-1-configuration-space-header"><a class="markdownIt-Anchor" href="#pci-30-type-1-configuration-space-header"></a> PCI 3.0 Type 1 Configuration Space Header</h2>
<p><strong>Type 1 Configuration Space Header</strong> 用于连接两条总线的设备，也就是 <strong>Bridge Device</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pci 0000:00:00.0: config space:</span><br><span class="line">00000000: 86 80 34 3e</span><br><span class="line">00000004: 06 00 90 20</span><br><span class="line">00000008: 0c 00 00 06</span><br><span class="line">0000000c: 00 00 00 00 </span><br><span class="line">00000010: 00 00 00 00 &lt;- BAR0</span><br><span class="line">00000014: 00 00 00 00 &lt;- BAR1</span><br><span class="line">00000018: 00 00 00 00 &lt;- BAR2</span><br><span class="line">0000001c: 00 00 00 00 &lt;- BAR3</span><br><span class="line">00000020: 00 00 00 00 &lt;- BAR4</span><br><span class="line">00000024: 00 00 00 00 &lt;- BAR5</span><br><span class="line">00000028: 00 00 00 00</span><br><span class="line">0000002c: 28 10 20 09</span><br><span class="line">00000030: 00 00 00 00</span><br><span class="line">00000034: e0 00 00 00</span><br><span class="line">00000038: 00 00 00 00</span><br><span class="line">0000003c: 00 00 00 00</span><br><span class="line">00000040: 01 90 d1 fe</span><br><span class="line">00000044: 00 00 00 00</span><br><span class="line">00000048: 01 00 d1 fe</span><br><span class="line">0000004c: 00 00 00 00</span><br><span class="line">00000050: c1 02 00 00</span><br><span class="line">00000054: b1 80 00 00</span><br><span class="line">00000058: 47 00 70 8f</span><br><span class="line">0000005c: 07 01 00 8a</span><br><span class="line">00000060: 01 00 00 e0</span><br><span class="line">00000064: 00 00 00 00</span><br><span class="line">00000068: 01 80 d1 fe</span><br><span class="line">0000006c: 00 00 00 00</span><br><span class="line">00000070: 00 00 00 fc</span><br><span class="line">00000074: 01 00 00 00</span><br><span class="line">00000078: 00 0c 00 fc</span><br><span class="line">0000007c: 7f 00 00 00</span><br><span class="line">00000080: 01 00 00 00</span><br><span class="line">00000084: 00 00 00 00</span><br><span class="line">00000088: 1a 00 00 00</span><br><span class="line">0000008c: 00 00 00 00</span><br><span class="line">00000090: 01 00 00 fc</span><br><span class="line">00000094: 01 00 00 00</span><br><span class="line">00000098: 01 00 70 6c</span><br><span class="line">0000009c: 02 00 00 00</span><br><span class="line">000000a0: 01 00 00 00</span><br><span class="line">000000a4: 02 00 00 00</span><br><span class="line">000000a8: 01 00 80 6c</span><br><span class="line">000000ac: 02 00 00 00</span><br><span class="line">000000b0: 01 00 80 8b</span><br><span class="line">000000b4: 01 00 00 8b</span><br><span class="line">000000b8: 01 00 00 8a</span><br><span class="line">000000bc: 01 00 80 8f</span><br><span class="line">000000c0: 00 00 00 00</span><br><span class="line">000000c4: 00 00 00 00</span><br><span class="line">000000c8: 00 00 00 00</span><br><span class="line">000000cc: 00 00 00 00</span><br><span class="line">000000d0: 00 00 00 00</span><br><span class="line">000000d4: 00 00 00 00</span><br><span class="line">000000d8: 00 00 00 00</span><br><span class="line">000000dc: 00 00 00 00</span><br><span class="line">000000e0: 09 00 10 01</span><br><span class="line">000000e4: c1 60 61 7a</span><br><span class="line">000000e8: 8c 80 11 94</span><br><span class="line">000000ec: 00 c0 04 00</span><br><span class="line">000000f0: 00 00 00 00</span><br><span class="line">000000f4: c8 0f 0c 00</span><br><span class="line">000000f8: 00 00 00 00</span><br><span class="line">000000fc: 00 00 00 00</span><br><span class="line">pci 0000:00:00.0: [8086:3e34] type 00 class 0x060000 conventional PCI endpoint</span><br><span class="line">pci 0000:00:02.0: config space:</span><br><span class="line">00000000: 86 80 a0 3e</span><br><span class="line">00000004: 07 00 10 00</span><br><span class="line">00000008: 02 00 00 03</span><br><span class="line">0000000c: 00 00 00 00</span><br><span class="line">00000010: 04 00 00 c0 &lt;- BAR 0 * (type=mem)</span><br><span class="line">00000014: 00 00 00 00 &lt;- BAR 1</span><br><span class="line">00000018: 0c 00 00 b0 &lt;- BAR 2 * (type=mem)</span><br><span class="line">0000001c: 00 00 00 00 &lt;- BAR 3</span><br><span class="line">00000020: 01 40 00 00 &lt;- BAR 4 * (type=io)</span><br><span class="line">00000024: 00 00 00 00 &lt;- BAR 5</span><br><span class="line">00000028: 00 00 00 00</span><br><span class="line">0000002c: 28 10 20 09</span><br><span class="line">00000030: 00 00 00 00</span><br><span class="line">00000034: 40 00 00 00 &lt;- Capability Pointer : 40h</span><br><span class="line">00000038: 00 00 00 00</span><br><span class="line">0000003c: ff 01 00 00</span><br><span class="line">00000040: 09 70 0c 01 &lt;- Capability Next : 70h, ID: 09h (Vendor Specific)</span><br><span class="line">00000044: c1 60 61 7a</span><br><span class="line">00000048: 8c 80 11 94</span><br><span class="line">0000004c: 00 00 00 00</span><br><span class="line">00000050: c1 02 00 00</span><br><span class="line">00000054: b1 80 00 00</span><br><span class="line">00000058: 00 00 00 00</span><br><span class="line">0000005c: 01 00 80 8b</span><br><span class="line">00000060: 00 00 01 00</span><br><span class="line">00000064: 00 00 00 00</span><br><span class="line">00000068: 00 00 00 00</span><br><span class="line">0000006c: 00 00 00 00</span><br><span class="line">00000070: 10 ac 92 00 &lt;- Capability Next : ach, ID: 10h (PCI Express)</span><br><span class="line">00000074: 00 80 00 10</span><br><span class="line">00000078: 00 00 00 00</span><br><span class="line">0000007c: 00 00 00 00</span><br><span class="line">00000080: 00 00 00 00</span><br><span class="line">00000084: 00 00 00 00</span><br><span class="line">00000088: 00 00 00 00</span><br><span class="line">0000008c: 00 00 00 00</span><br><span class="line">00000090: 00 00 00 00</span><br><span class="line">00000094: 00 00 00 00</span><br><span class="line">00000098: 00 00 00 00</span><br><span class="line">0000009c: 00 00 00 00</span><br><span class="line">000000a0: 00 00 00 00</span><br><span class="line">000000a4: 00 00 00 00</span><br><span class="line">000000a8: 00 00 00 00</span><br><span class="line">000000ac: 05 d0 00 00 &lt;- Capability Next : d0h, ID: 05h (Message Signaled Interrupts)</span><br><span class="line">000000b0: 00 00 00 00</span><br><span class="line">000000b4: 00 00 00 00</span><br><span class="line">000000b8: 00 00 00 00</span><br><span class="line">000000bc: 00 00 00 00</span><br><span class="line">000000c0: 00 00 00 00</span><br><span class="line">000000c4: 00 00 00 00</span><br><span class="line">000000c8: 00 00 00 00</span><br><span class="line">000000cc: 00 00 00 00</span><br><span class="line">000000d0: 01 00 22 00 &lt;- Capability Last : 00h, ID: 01h (PCI Power Management Interface)</span><br><span class="line">000000d4: 00 00 00 00</span><br><span class="line">000000d8: 00 00 00 00</span><br><span class="line">000000dc: 00 00 00 00</span><br><span class="line">000000e0: 00 00 00 00</span><br><span class="line">000000e4: 00 00 00 00</span><br><span class="line">000000e8: 00 80 00 00</span><br><span class="line">000000ec: 00 00 00 00</span><br><span class="line">000000f0: 00 00 00 00</span><br><span class="line">000000f4: 00 00 00 00</span><br><span class="line">000000f8: 00 00 00 00</span><br><span class="line">000000fc: 18 00 e1 88</span><br><span class="line">pci 0000:00:02.0: [8086:3ea0] type 00 class 0x030000 PCIe Root Complex Integrated Endpoint</span><br><span class="line">pci 0000:00:02.0: BAR 0 [mem 0xc0000000-0xc0ffffff 64bit] &lt;- FB (mmapped Write-Combining)</span><br><span class="line">pci 0000:00:02.0: BAR 2 [mem 0xb0000000-0xbfffffff 64bit pref] &lt;- (mapped Write-Through)</span><br><span class="line">pci 0000:00:02.0: BAR 4 [io  0x4000-0x403f]</span><br><span class="line">pci 0000:00:02.0: Video device with shadowed ROM at [mem 0x000c0000-0x000dffff]</span><br><span class="line">...</span><br><span class="line">pci 0000:01:00.0: config space:</span><br><span class="line">00000000: de 10 13 1d</span><br><span class="line">00000004: 00 00 10 00</span><br><span class="line">00000008: a1 00 02 03</span><br><span class="line">0000000c: 00 00 00 00</span><br><span class="line">00000010: 00 00 00 c1 &lt;- BAR 0 * (type=mem)</span><br><span class="line">00000014: 0c 00 00 90 &lt;- BAR 1 * (type=mem)</span><br><span class="line">00000018: 00 00 00 00 &lt;- BAR 2</span><br><span class="line">0000001c: 0c 00 00 a0 &lt;- BAR 3 * (type=mem)</span><br><span class="line">00000020: 00 00 00 00 &lt;- BAR 4</span><br><span class="line">00000024: 01 30 00 00 &lt;- BAR 5 * (type=io)</span><br><span class="line">00000028: 00 00 00 00</span><br><span class="line">0000002c: 28 10 20 09</span><br><span class="line">00000030: 00 00 f8 ff</span><br><span class="line">00000034: 60 00 00 00 &lt;- Capability Pointer : 60h</span><br><span class="line">00000038: 00 00 00 00</span><br><span class="line">0000003c: ff 01 00 00</span><br><span class="line">00000040: 28 10 20 09</span><br><span class="line">00000044: 00 00 00 00</span><br><span class="line">00000048: 00 00 00 00</span><br><span class="line">0000004c: 00 00 00 00</span><br><span class="line">00000050: 00 00 00 00</span><br><span class="line">00000054: 01 00 00 00</span><br><span class="line">00000058: ce d6 23 00</span><br><span class="line">0000005c: 00 00 00 00</span><br><span class="line">00000060: 01 68 03 00 &lt;- Capability Next : 68h, ID: 01h (PCI Power Management Interface)</span><br><span class="line">00000064: 08 00 00 00</span><br><span class="line">00000068: 05 78 80 00 &lt;- Capability Next : 78h, ID: 05h (Message Signaled Interrupts)</span><br><span class="line">0000006c: 00 00 00 00</span><br><span class="line">00000070: 00 00 00 00</span><br><span class="line">00000074: 00 00 00 00</span><br><span class="line">00000078: 10 00 02 00 &lt;- Capability Last : 00h, ID: 10h (PCI Express)</span><br><span class="line">0000007c: e1 8d e8 07</span><br><span class="line">00000080: 30 29 09 00</span><br><span class="line">00000084: 43 4c 45 00</span><br><span class="line">00000088: 42 01 43 10</span><br><span class="line">0000008c: 00 00 00 00</span><br><span class="line">00000090: 00 00 00 00</span><br><span class="line">00000094: 00 00 00 00</span><br><span class="line">00000098: 00 00 00 00</span><br><span class="line">0000009c: 13 08 04 00</span><br><span class="line">000000a0: 00 00 00 00</span><br><span class="line">000000a4: 0e 00 00 00</span><br><span class="line">000000a8: 03 00 1e 00</span><br><span class="line">000000ac: 00 00 00 00</span><br><span class="line">000000b0: 00 00 00 00</span><br><span class="line">000000b4: 09 00 14 01</span><br><span class="line">000000b8: 00 00 00 00</span><br><span class="line">000000bc: 00 00 00 00</span><br><span class="line">000000c0: 00 00 00 00</span><br><span class="line">000000c4: 00 00 00 00</span><br><span class="line">000000c8: 00 00 00 00</span><br><span class="line">000000cc: 00 00 00 00</span><br><span class="line">000000d0: 00 00 00 00</span><br><span class="line">000000d4: 00 00 00 00</span><br><span class="line">000000d8: 00 00 00 00</span><br><span class="line">000000dc: 00 00 00 00</span><br><span class="line">000000e0: 00 00 00 00</span><br><span class="line">000000e4: 00 00 00 00</span><br><span class="line">000000e8: 00 00 00 00</span><br><span class="line">000000ec: 00 00 00 00</span><br><span class="line">000000f0: 00 00 00 00</span><br><span class="line">000000f4: 00 00 00 00</span><br><span class="line">000000f8: 00 00 00 00</span><br><span class="line">000000fc: 00 00 00 00</span><br><span class="line">pci 0000:01:00.0: [10de:1d13] type 00 class 0x030200 PCIe Endpoint</span><br><span class="line">pci 0000:01:00.0: BAR 0 [mem 0xc1000000-0xc1ffffff]</span><br><span class="line">pci 0000:01:00.0: BAR 1 [mem 0x90000000-0x9fffffff 64bit pref]</span><br><span class="line">pci 0000:01:00.0: BAR 3 [mem 0xa0000000-0xa1ffffff 64bit pref]</span><br><span class="line">pci 0000:01:00.0: BAR 5 [io  0x3000-0x307f]</span><br><span class="line">pci 0000:01:00.0: ROM [mem 0xfff80000-0xffffffff pref]</span><br></pre></td></tr></table></figure>
<p>上面的 PCI config space dump 可以通过内核启动参数 <span style="background-color: yellow; padding: 4px;">pci=earlydump</span> 开启打印。所谓 <strong>earlydump</strong> 是指打印的是内核<strong>未经修改的</strong> config space, 也就是说是 UEFI 初始化过的 config space, 像 BAR 里的物理地址一般不会是这个设备最终的物理内存起始地址，内核一般都会<strong>重新规划</strong> PCI 设备的物理内存地址空间，由内核重新填入的 BAR 值，可以通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -xxx -s &lt;Bus:Dev.Func&gt;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxd /sys/bus/pci/devices/&lt;Domain:Bus:Dev.Func&gt;/config</span><br></pre></td></tr></table></figure>
<p>来查看。</p>
<h1 id="pci-extended-config-space-span-stylecolor-red0x100-~-0xfffspan"><a class="markdownIt-Anchor" href="#pci-extended-config-space-span-stylecolor-red0x100-~-0xfffspan"></a> PCI Extended Config Space (<span style="color: red;">0x100 ~ 0xFFF</span>)</h1>
<p>PCI 的 Capability 有 Base 和 Extended 之分，Base Capability List 在 PCI Config Space, 而 Extended Capability List 在 Extended Config Space，即在整个配置空间 0x100 的位置。</p>
<p>查看方法同上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -xxxx -s &lt;Bus:Dev.Func&gt;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxd /sys/bus/pci/devices/&lt;Domain:Bus:Dev.Func&gt;/config</span><br></pre></td></tr></table></figure>
<p>以上都是纯数据形式打印，如果想以 Human-readable 形式看到，请使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -vv -s &lt;Domain:Bus:Dev.Func&gt;</span><br></pre></td></tr></table></figure>
<h1 id="消失的南桥和北桥"><a class="markdownIt-Anchor" href="#消失的南桥和北桥"></a> 消失的南桥和北桥</h1>
<p><img src="/images/pci/modern-computer.png" alt="" /></p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://wiki.osdev.org/PCI">osdev.org: PCI</a></li>
<li><a href="https://pcisig.com/sites/default/files/files/PCI_Code-ID_r_1_11__v24_Jan_2019.pdf">PCI Code and ID Assignment Specification,Rev. 1.11</a></li>
</ul>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>芯原 VPU</title>
    <url>/hw/verisilicon/</url>
    <content><![CDATA[<h1 id="hantro-vpu"><a class="markdownIt-Anchor" href="#hantro-vpu"></a> Hantro VPU</h1>
<p><a href="https://www.nexitventures.com/cases/hantro-products-oy/">Hantro Products OY</a> 是一家专注于视频编解码技术的芬兰公司，它的视频编码 IP (Hantro H1) 和解码 IP(Hantro G1) 被集成在瑞芯微 RK3288 SoC 上。其开源驱动在 <a href="https://elixir.bootlin.com/linux/v6.10.6/source/drivers/media/platform/verisilicon">drivers/media/platform/verisilicon</a></p>
<span id="more"></span>
<ul>
<li>OOC
<ul>
<li>Hantro 的 IP 为什么会在芯原的<a href="https://www.verisilicon.com/cn/IPPortfolio/HantroVPUIP">货架</a>上</li>
<li>Hantro 的名字好像来自一个芬剧(Shattered Dreams)角色，有点像 Python<br />
<img src="/images/verisilicon/hantro.jpeg" alt="Hantro" /></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux accel 子系统</title>
    <url>/lnx/accel/</url>
    <content><![CDATA[<p>Linux 计算加速器子系统旨在以通用的方式向用户空间开放计算加速器的接口。这些计算加速器可以是独立的 ASIC, 也可以是 SoC/GPU 内的 IP 块。通常计算加速器包括以下几种类型:</p>
<ul>
<li>边缘 AI - 在边缘设备上进行推理计算</li>
<li>推理数据中心 - 大型服务器中的单用户/多用户设备</li>
<li>训练数据中心 - 类似于推理数据中心卡，但通常具有更强的计算能力和更高的存储带宽</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if DRM</span><br><span class="line"></span><br><span class="line">menuconfig DRM_ACCEL</span><br><span class="line">	bool &quot;Compute Acceleration Framework&quot;</span><br><span class="line">	help</span><br><span class="line">	  Framework for device drivers of compute acceleration devices, such</span><br><span class="line">	  as, but not limited to, Machine-Learning and Deep-Learning</span><br><span class="line">	  acceleration devices.</span><br><span class="line">	  If you say Y here, you need to select the module that&#x27;s right for</span><br><span class="line">	  your acceleration device from the list below.</span><br><span class="line">	  This framework is integrated with the DRM subsystem as compute</span><br><span class="line">	  accelerators and GPUs share a lot in common and can use almost the</span><br><span class="line">	  same infrastructure code.</span><br><span class="line">	  Having said that, acceleration devices will have a different</span><br><span class="line">	  major number than GPUs, and will be exposed to user-space using</span><br><span class="line">	  different device files, called accel/accel* (in /dev, sysfs</span><br><span class="line">	  and debugfs).</span><br><span class="line"></span><br><span class="line">source &quot;drivers/accel/habanalabs/Kconfig&quot;</span><br><span class="line">source &quot;drivers/accel/ivpu/Kconfig&quot;</span><br><span class="line">source &quot;drivers/accel/qaic/Kconfig&quot;</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>下面是 accel 子系统被合入主线时的 commit message</p>
<blockquote>
<p>drivers/accel: define kconfig and register a new major</p>
<p>Add a new Kconfig for the accel subsystem. The Kconfig currently<br />
contains only the basic CONFIG_DRM_ACCEL option that will be used to<br />
decide whether to compile the accel registration code. Therefore, the<br />
kconfig option is defined as bool.</p>
<p>The accel code will be compiled as part of drm.ko and will be called<br />
directly from the DRM core code. The reason we compile it as part of<br />
drm.ko and not as a separate module is because of cyclic dependency<br />
between drm.ko and the separate module (if it would have existed).<br />
This is due to the fact that DRM core code calls accel functions and<br />
vice-versa.</p>
<p>The accelerator devices will be exposed to the user space with a new,<br />
dedicated major number - 261.</p>
<p>The accel init function registers the new major number as a char device<br />
and create corresponding sysfs and debugfs root entries, similar to<br />
what is done in DRM init function.</p>
<p>I added a new header called drm_accel.h to include/drm/, that will hold<br />
the prototypes of the drm_accel.c functions. In case CONFIG_DRM_ACCEL<br />
is set to ‘N’, that header will contain empty inline implementations of<br />
those functions, to allow DRM core code to compile successfully<br />
without dependency on CONFIG_DRM_ACCEL.</p>
<p>I Updated the MAINTAINERS file accordingly with the newly added folder<br />
and I have taken the liberty to appropriate the dri-devel mailing list<br />
and the dri-devel IRC channel for the accel subsystem.</p>
</blockquote>
<p>目前 accel 下已经有 3 个 AI 加速芯片的驱动:</p>
<ul>
<li><strong>habanalabs.ko</strong> - Intel 旗下的哈瓦那 (Habana) AI 处理器 (AIP)</li>
<li><strong>intel_vpu.ko</strong> - Intel Neural Proccessing Unit (NPU) (之前叫 VPU Versatile Proccessing Unit)</li>
<li><strong>qaic.ko</strong> - Qualcomm Cloud AI 加速器</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>AMDGPU 驱动(KMD + UMD)中的一些缩写词解释</title>
    <url>/lnx/amdgpu-glossary/</url>
    <content><![CDATA[<p><img src="/images/amdgpu-glossary/amd-arch.jpg" alt="AMDGPU Microarchitecture Roadmap" /></p>
<span id="more"></span>
<h1 id="glossary"><a class="markdownIt-Anchor" href="#glossary"></a> Glossary</h1>
<h2 id="gpu-hardware"><a class="markdownIt-Anchor" href="#gpu-hardware"></a> <a href="https://docs.kernel.org/gpu/amdgpu/driver-core.html#gpu-hardware-structure">GPU Hardware</a></h2>
<p>这里的 hardware block, IP (Intellectual Property) block, controller, processor, engine 基本上都是指一个具有相对独立功能的<strong>硬件处理单元</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Abbr.</th>
<th style="text-align:left">Stands for</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GMC</td>
<td style="text-align:left">Graphics Memory Controller</td>
<td style="text-align:left">管理 GPU 上不同 IP 如何获取内存 (VRAM) 的控制器，它也提供每进程 GPU 虚拟地址空间的支持(听起来有点像 MMU)</td>
</tr>
<tr>
<td style="text-align:left">IH</td>
<td style="text-align:left">Interrupt Handler</td>
<td style="text-align:left">GPU 上的中断控制器</td>
</tr>
<tr>
<td style="text-align:left">PSP</td>
<td style="text-align:left">Platform Security Processor</td>
<td style="text-align:left">处理 SoC 上的安全策略，执行 trusted app, 为其它 IP 验证和加载固件程序</td>
</tr>
<tr>
<td style="text-align:left">SMU</td>
<td style="text-align:left">System Management Unit</td>
<td style="text-align:left">SoC 的电源管理微控制器，驱动通过这个模块来控制芯片的时钟，电压域，电源轨等</td>
</tr>
<tr>
<td style="text-align:left">DCN</td>
<td style="text-align:left">Display Controller Next</td>
<td style="text-align:left">显示控制器</td>
</tr>
<tr>
<td style="text-align:left">SDMA</td>
<td style="text-align:left">System DMA</td>
<td style="text-align:left">多功能 DMA engine, KMD 利用它完成分页，GPU 页表更新，而且它通过 UMD 暴露给用户态使用</td>
</tr>
<tr>
<td style="text-align:left">GC</td>
<td style="text-align:left">Graphics and Compute</td>
<td style="text-align:left">GFX/Compute engine, 这是 GPU 上最大的 IP, 它包含 3D pipeline 和 shader cores</td>
</tr>
<tr>
<td style="text-align:left">VCN</td>
<td style="text-align:left">Video Codec Next</td>
<td style="text-align:left">Multi-media engine，它处理视频和图像的编解码，通过 UMD 暴露给用户态使用</td>
</tr>
<tr>
<td style="text-align:left">CP</td>
<td style="text-align:left">Command Processor</td>
<td style="text-align:left">包含 GFX/Compute engine 的前端，一批微控制器，包括 PFP,ME,CE,MEC，它们上面运行固件代码，为驱动提供与 GFX/Compute engine 进行交互的接口</td>
</tr>
<tr>
<td style="text-align:left">CE</td>
<td style="text-align:left">Constant Engine</td>
<td style="text-align:left">GFX CP 里的一个小处理器，主要用来更新 buffer descriptor 以便异步地将 PFP/ME 使用的 buffer 加载进 cache</td>
</tr>
<tr>
<td style="text-align:left">PFP</td>
<td style="text-align:left">Pre-Fetch Parser</td>
<td style="text-align:left">GFX CP 里的一个小处理器，需要给它加载 µCode 去执行, 从名字能看出来它是预取 packets 的</td>
</tr>
<tr>
<td style="text-align:left">ME</td>
<td style="text-align:left">MicroEngine</td>
<td style="text-align:left">GFX CP 里的一个小处理器，它和 PFP 组成一个 Drawing Engine，可以和 CE 异步执行</td>
</tr>
<tr>
<td style="text-align:left">MEC</td>
<td style="text-align:left">MicroEngine Compute</td>
<td style="text-align:left">微控制器用来控制 GFX/Compute engine 上的 compute queues, Compute Engine 一般有 2 个 MEC, 而且每个 MEC 支持 32 个 HW ring(queue)</td>
</tr>
<tr>
<td style="text-align:left">MES</td>
<td style="text-align:left">MicroEngine Scheduler</td>
<td style="text-align:left">一个新的微控制器用来控制 queues, 估计既可以控制 compute queues, 也可以控制 gfx queues, 而且它上面运行的固件可能取代现有的内核 gpu scheduler, 而变成 firmware-based scheduling 😃 猜</td>
</tr>
<tr>
<td style="text-align:left">RLC</td>
<td style="text-align:left">RunList Controller</td>
<td style="text-align:left">又一个 GFX/Compute engine 里的微控制器，用来处理 GFX/Compute engine 内部的电源管理，至于名字是历史遗留，与它的功能没有毛关系</td>
</tr>
</tbody>
</table>
<h2 id="driver"><a class="markdownIt-Anchor" href="#driver"></a> <a href="https://docs.kernel.org/gpu/amdgpu/driver-core.html#driver-structure">Driver</a></h2>
<table>
<thead>
<tr>
<th style="text-align:left">Abbr.</th>
<th style="text-align:left">Stands for</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">KIQ</td>
<td style="text-align:left">Kernel Interface Queue</td>
<td style="text-align:left">KMD 的一个控制队列，用来管理 GFX/Compute engine 上的其它队列</td>
</tr>
<tr>
<td style="text-align:left">IB</td>
<td style="text-align:left">Indirect Buffer</td>
<td style="text-align:left">某个特定 engine 的 command buffer, 通常不是直接将命令写入硬件 queue 里，而是先将命令写入一块内存，然后再将内存的地址写入硬件 queue</td>
</tr>
<tr>
<td style="text-align:left">HQD</td>
<td style="text-align:left">Hardware Queue Descriptor</td>
<td style="text-align:left">kernel queues 或 user queues 将“映射”到一个 HQD, 一个 HQD 可能就是一个 MMIO 地址寄存器。kernel queues 和 user queues 映射的区别是， kernel queues 总是<strong>静态地</strong>映射到<strong>一个 HQD</strong>, 而 user queues 由 MES <strong>动态地</strong> 映射到剩余的所有其它 HQDs</td>
</tr>
<tr>
<td style="text-align:left">MQD</td>
<td style="text-align:left">Memory Queue Descriptor</td>
<td style="text-align:left">定义 queue 的状态，包括 GPU virtual address, doorbell 等，驱动为每个它创建的 queue 设置一个 MQD， MQD 被交给 MES firmware 去映射</td>
</tr>
<tr>
<td style="text-align:left">KFD</td>
<td style="text-align:left">Kernel Fusion Driver</td>
<td style="text-align:left">AMD APU 芯片的内核驱动， 主要用于 HSA 架构的芯片</td>
</tr>
<tr>
<td style="text-align:left">KGD</td>
<td style="text-align:left">Kernel Graphics Driver</td>
<td style="text-align:left">AMD GPU 芯片的内核驱动， 主要用于独立显卡和 OEM 上的 GPU 芯片</td>
</tr>
<tr>
<td style="text-align:left">RAS</td>
<td style="text-align:left">Reliability, Availability, Serviceability</td>
<td style="text-align:left">AMDGPU 驱动的一个功能特性，帮助错误检测上报，错误处理和调试</td>
</tr>
</tbody>
</table>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://docs.kernel.org/gpu/amdgpu/driver-core.html">Kernel Doc</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, Arch Linux</title>
    <url>/lnx/arch/</url>
    <content><![CDATA[<p><img src="/images/arch/gdm-screenshot.png" alt="" /></p>
<span id="more"></span>
<h1 id="安装-arch-linux"><a class="markdownIt-Anchor" href="#安装-arch-linux"></a> 安装 Arch Linux</h1>
<p>安装 Arch Linux 可以分为两个阶段：</p>
<ul>
<li>CLI：系统可以从 console 登录</li>
<li>GUI：安装图形桌面环境，可以从 login greeter 登录
<ul>
<li>这里就体现出 Arch Linux 的特点，你可以自由安装喜欢的桌面环境: KDE Plasma, GNOME</li>
<li>桌面环境安装后，还有就是各种图形应用，包括 google-chrome, fcitx5-configtool, vscode 等等，有些没有在 pacman 的源里，需要使用 yay (Yet Another Yogurt, Yogurt 是早期的 AUR 助手) 安装</li>
<li>pacman 的源可以自己配成国内源，但 yay 的好多下载地址都XX了，所以这个阶段可能需要梯子，否则很难进行下去</li>
</ul>
</li>
</ul>
<h2 id="cli-boot"><a class="markdownIt-Anchor" href="#cli-boot"></a> CLI boot</h2>
<h3 id="基于-uefigpt-的硬盘分区"><a class="markdownIt-Anchor" href="#基于-uefigpt-的硬盘分区"></a> 基于 UEFI/GPT 的硬盘分区</h3>
<ul>
<li>boot 分区 (EFI System Partition, ESP) 必须是 <strong>FAT32</strong> 文件系统</li>
<li>boot 分区除了放 bootloader (GRUB) 的配置文件外，还会放 vmlinuz, initrd 这些，最好弄到 5G ~ 10G, 以容纳多个内核版本的 elf 和 initrd</li>
</ul>
<h3 id="iwctl"><a class="markdownIt-Anchor" href="#iwctl"></a> iwctl</h3>
<h3 id="pacman"><a class="markdownIt-Anchor" href="#pacman"></a> pacman</h3>
<h3 id="arch-chroot"><a class="markdownIt-Anchor" href="#arch-chroot"></a> arch-chroot</h3>
<h2 id="gui-boot"><a class="markdownIt-Anchor" href="#gui-boot"></a> GUI boot</h2>
<h3 id="gnome-desktop-environment"><a class="markdownIt-Anchor" href="#gnome-desktop-environment"></a> GNOME Desktop Environment</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S gnome gnome-extra</span><br></pre></td></tr></table></figure>
<h3 id="yay"><a class="markdownIt-Anchor" href="#yay"></a> yay</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay-git.git</span><br><span class="line">pacman -S --needed base-devel</span><br><span class="line"><span class="built_in">cd</span> yay-git</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure>
<h3 id="中文字体"><a class="markdownIt-Anchor" href="#中文字体"></a> 中文字体</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S noto-fonts noto-fonts-cjk</span><br></pre></td></tr></table></figure>
<h3 id="中文输入法"><a class="markdownIt-Anchor" href="#中文输入法"></a> 中文输入法</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S fcitx5 fcitx5-gtk fcitx5-chinese-addons fcitx5-configtool</span><br><span class="line">yay -S fcitx5-sogou</span><br></pre></td></tr></table></figure>
<p>安装后启动 fcitx5-configtool，添加搜狗输入法即可</p>
<h1 id="编译内核"><a class="markdownIt-Anchor" href="#编译内核"></a> 编译内核</h1>
<p>要制作一个可启动的内核，涉及到 3 个步骤</p>
<ul>
<li>编译内核，生成内核 ELF 可执行文件 vmlinuz (压缩格式)，安装内核模块</li>
<li>生成初始内存文件系统 initramfs</li>
<li>更新引导加载程序 bootloader 的配置，即 <code>/boot/grub/grub.cfg</code></li>
</ul>
<p>总的来说，在 Arch Linux 上制作一个可启动的新内核，让系统能够用新内核正常工作，是相对比较简单的，这也是我放弃 openKylin，转向 Arch Linux 的主要原因，在 openKylin 上，光是找到目前正在运行的内核源码都费半天劲儿，包括内核源码库，整个发行版的软件包源码仓库，软件版本管理都有点混乱。</p>
<h2 id="配置内核"><a class="markdownIt-Anchor" href="#配置内核"></a> 配置内核</h2>
<h3 id="config_module_compress_all"><a class="markdownIt-Anchor" href="#config_module_compress_all"></a> CONFIG_MODULE_COMPRESS_ALL</h3>
<p>控制 <code>make modules_install</code> 时是否压缩 <code>.ko</code> 文件，它依赖 <code>CONFIG_MODULE_COMPRESS</code>。</p>
<h2 id="内核可执行文件"><a class="markdownIt-Anchor" href="#内核可执行文件"></a> 内核可执行文件</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make modules_install</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>
<ul>
<li>内核配置 .config 可以通过 <code>zcat /proc/config.gz &gt; .config</code> 得到一个基础配置，然后 <code>make menuconfig</code> 在此基础上修改保存。</li>
<li>vmlinuz 的安装脚本有一个搜索顺序 <code>scripts/install.sh -&gt; (1) ~/bin/installkernel; (2) /sbin/installkernel; (3) arch/x86/boot/install.sh</code>, 而且默认的安装名总是 <code>vmlinuz</code>, 为了更好地区分多个 <code>vmlinuz</code>, 最好将 <code>kernel version</code> 加到 <code>vmlinuz</code> 后面。如果使用第一搜索顺序，在 <code>sudo make install</code> 时，需要</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo --preserve-env=HOME make install</span><br></pre></td></tr></table></figure>
<h2 id="制作初始内存文件系统"><a class="markdownIt-Anchor" href="#制作初始内存文件系统"></a> 制作初始内存文件系统</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkinitcpio --generate /boot/initramfs-6.16.1-arch1.img --kernel 6.16.1-arch1</span><br></pre></td></tr></table></figure>
<p>其中 <code>--kernel</code> 参数来自 <code>make kernelrelease</code>, 它也是 <code>sudo make modules_install</code> 后在 <code>/lib/modules</code> 下创建的目录名. 同时新内核安装重启后有 <strong><code>make kernelrelease ≡ uname -r</code></strong></p>
<h2 id="更新-bootloader-配置"><a class="markdownIt-Anchor" href="#更新-bootloader-配置"></a> 更新 bootloader 配置</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<p>这一步在两种情况下需要执行：</p>
<ul>
<li>修改了 bootloader 程序的配置，如修改了 <code>/etc/default/grub</code></li>
<li>当 <code>/boot</code> 目录新增了 <code>vmlinuz</code> 和 <code>initramfs.img</code>， 如果只是重新编译了内核，而安装的 vmlinuz 和 initramfs.img 还是<strong>原来的名字</strong>, 就无需执行这一步</li>
</ul>
<h1 id="截屏-greeter"><a class="markdownIt-Anchor" href="#截屏-greeter"></a> 截屏 Greeter</h1>
<p>截屏系统登录界面(Login Greeter) 并不那么容易，因为它和用户登录之后的 Display Manager 会话通常是两个独立的 Session, 它们各自由一个独立的 Xorg 进程渲染(如果当前会话类型 <code>XDG_SESSION_TYPE</code> 是 <em>wayland</em>, 这两个 X 服务则变成 <code>Xwayland</code>), 而且通过在 GDM 环境下的观察，负责渲染 Greeter 的进程(Xorg 或 Xwayland)是反复创建和销毁的，当你切换到登录界面时，它们才被 <code>gdm-x-session</code>(或 <code>gdm-wayland-session</code>) 拉起(创建)，一旦登录后进入桌面，这个进程又会被很快销毁。</p>
<p><img src="/images/arch/gdm-wayland-session.png" alt="" /></p>
<p>如果不了解这一点，在你尝试<a href="https://ao2.it/en/blog/2016/10/01/capturing-screenshot-gdm-login-screen">截屏 GDM login screen</a> 时，就会很不顺利。不过下面的截屏方法只在 x11 会话下有效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span> 6</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> -u gdm DISPLAY=:0 XAUTHORITY=/run/user/120/gdm/Xauthority import -display :0 -win root /tmp/gdm-screenshot.png</span><br></pre></td></tr></table></figure>
<h2 id="gnome-display-manager"><a class="markdownIt-Anchor" href="#gnome-display-manager"></a> GNOME Display Manager</h2>
<h2 id="observer-effect"><a class="markdownIt-Anchor" href="#observer-effect"></a> <a href="https://en.wikipedia.org/wiki/Observer_effect_(physics)">Observer Effect</a>-style <code>/usr/lib/gdm-x-session</code></h2>
<p><img src="/images/arch/gdm-x-session-oneshot.png" alt="" /></p>
<h1 id="选-gpu"><a class="markdownIt-Anchor" href="#选-gpu"></a> 选 GPU</h1>
<p>当 Linux 系统中同时存在多个 GPU 时，有多种方法可以指定使用哪一个。</p>
<h2 id="kernel-boot-parameter"><a class="markdownIt-Anchor" href="#kernel-boot-parameter"></a> kernel boot parameter</h2>
<p>通过内核启动参数，如 <code>modprobe.blacklist=i915</code>，将相应 GPU 的内核驱动屏蔽，但有时可能有副作用，例如我的 Dell Vostro 5390，如果将 <code>i915</code> 驱动屏蔽掉，Audio Subsystem 会出问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00:1c.0 PCI bridge [0604]: Intel Corporation Cannon Point-LP PCI Express Root Port #5 [8086:9dbc] (rev f0)</span><br><span class="line">00:1d.0 PCI bridge [0604]: Intel Corporation Cannon Point-LP PCI Express Root Port #13 [8086:9db4] (rev f0)</span><br><span class="line">00:1f.3 Audio device [0403]: Intel Corporation Cannon Point-LP High Definition Audio Controller [8086:9dc8] (rev 30)</span><br></pre></td></tr></table></figure>
<p>由于Vostro 使用的 Audio interface 就是 Intel HDA, 所以当 <code>i915</code> 被屏蔽后，由于某种原因，Intel HDA 设备没有初始化成功，而它又没有连接其它独显的音频接口(如 Nvidia HDA)，导致系统的声音不能正常工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pci 0000:00:1f.3: deferred probe pending: snd_hda_intel: couldn&#x27;t bind with audio component</span><br><span class="line">nouveau 0000:01:00.0: Enabling HDA controller</span><br></pre></td></tr></table></figure>
<p>基本上只有内核启动日志里有下面一行，intel audio 才能正常工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snd_hda_intel 0000:00:1f.3: bound 0000:00:02.0 (ops intel_audio_component_bind_ops [i915])</span><br></pre></td></tr></table></figure>
<p>更保险的启动参数是 <code>i915.modeset=0</code>，即不禁用整个 i915 驱动，只禁用 graphics 功能。但 <a href="https://bbs.archlinux.org/viewtopic.php?id=292453">snd_hda_intel 和 i915 好像有些耦合问题</a>，必须再使用 <code>snd_hda_core.gpu_bind=0</code> 才能只禁用 Intel graphics, 不影响 Intel audio</p>
<h1 id="更换-boot-partition"><a class="markdownIt-Anchor" href="#更换-boot-partition"></a> 更换 boot partition</h1>
<p>需要使用 USB 启动盘和 <strong>parted</strong> 命令， <strong>parted</strong> 的只能改变原有分区的 end (分区的 start,end), 如果你的当前分区是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      17.4kB  1074MB  1074MB  fat32              boot, esp</span><br><span class="line"> 2      1074MB  1000GB  999GB   ext4</span><br></pre></td></tr></table></figure>
<p>是无法直接扩大 boot 分区的，可行的方案是先缩小 root 分区，然后用释放的空间重新创建 boot 的分区，再将原 boot 分区的内容整个 copy 到新的 boot 分区</p>
<ol>
<li><code>resize2fs /dev/nvme0n1p2 990G</code></li>
<li><code>(parted) resizepart 2 991GiB</code></li>
<li><code>resizepart /dev/nvme0n1 2 1931503615 (in 512-bytes sectors)</code></li>
<li><code>(parted) mkpart &quot;EFI system partition&quot; ext4 991GiB 100%</code></li>
</ol>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/596227524">Arch Linux 详细安装教程</a></li>
<li><a href="https://aur.archlinux.org/">Arch Linux User Repository</a></li>
<li><a href="https://help.gnome.org/admin/gdm/stable/">GNOME Display Manager Reference Manual</a></li>
<li><a href="https://ao2.it/en/blog/2016/10/01/capturing-screenshot-gdm-login-screen">Capturing a screenshot of GDM login screen</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>distro</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache 一致性</title>
    <url>/lnx/cache/</url>
    <content><![CDATA[<h1 id="cache"><a class="markdownIt-Anchor" href="#cache"></a> Cache</h1>
<p>音同 cash, 不管是在硬件还是软件都是影响性能的一个重要因素之一。Cache 无论是 CPU cache 还是 GPU cache 一般都分级， L1，L2, 在 Multi-processor CPU/GPU 架构中， L1 一般是分开的，每个 Processor 有一个自己的 L1 Cache, 而 L2 Cache 是全局的，所有 processors 共享的。</p>
<span id="more"></span>
<p>不管 Cache 有多少级，反正是为了降低 processor 访问 memory 的时延的。但是另一方面，当数据缓存到 Cache 中后，就必然引出一致性问题，这里的一致性应该有两个方面</p>
<ul>
<li>各个 processor 看到的 cache 里的内容一致</li>
<li>cache 与 memory 里的内容一致</li>
</ul>
<p>注：“内容一致”的另一种说法是“数据是不是最新的”，</p>
<h1 id="wc-vs-gre"><a class="markdownIt-Anchor" href="#wc-vs-gre"></a> WC vs GRE</h1>
<p>Write-Combining 是 X86-64 平台上一种特殊的内存类型 (Memory Type), 它被广泛应用在 X86-64 平台的 I/O 和其它各种外设的交互中。它的主要含义是<strong>将多个 stores (写内存) 收集到 burst transactions中</strong>，所以它主要是为了优化 CPU 访存(写)的效率。</p>
<p>同样的想法和技术在不同的平台下，只是叫法不同。Arm 平台自然也有类似的优化技术，即 GRE (Gathering, Reordering, Early write acknowledgement), Arm 架构定义了两种<strong>不使用 Cache (Non-Cacheable</strong>) 的内存类型</p>
<ul>
<li>Normal Non-Cacheable (Normal NC)</li>
<li>Device memory with GRE attributes (Device-GRE)</li>
</ul>
<p>这两种内存类型的共同点是：</p>
<ul>
<li>不使用 Cache</li>
<li>支持 GRE (相当于支持 Write-Combining)</li>
</ul>
<p>下表将 X86-64, Arm Normal NC, Arm Device-GRE 做了一个对比</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">X86-64</th>
<th style="text-align:left">Arm Normal NC</th>
<th style="text-align:left">Arm Device-GRE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Relaxed Order</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Gathering</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Read Speculation</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">Unaligned Access</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left">Gathering Size</td>
<td style="text-align:left">64 Bytes</td>
<td style="text-align:left">micro-arch</td>
<td style="text-align:left">micro-arch</td>
</tr>
</tbody>
</table>
<p>注：micro-arch 的意思是具体大小取决于具体微架构设计</p>
<p>从上表可以看出，Arm 的 Normal NC 等同于 X86-64 的 WC, 而 Arm 上的两种非 cache 的内存的主要区别在读预测和非对齐访问，实际上，个人理解 Arm Device-GRE 之所以会存在只是因为&quot;读预测&quot; 和 “非对齐访问” 这两种特性在 Arm 架构下本来就<strong>不常用</strong>, 单就优化 CPU 写内存来说，它俩并不是什么影响因素。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>Display Pipeline in Linux</title>
    <url>/lnx/display-pipeline/</url>
    <content><![CDATA[<p>在 Linux GPU 软件栈这块，大体包含 3 个 Pipelines</p>
<ul>
<li>Graphics Pipeline</li>
<li>Display Pipeline</li>
<li>Compute Pipeline</li>
</ul>
<span id="more"></span>
<p>Graphics Pipeline 和 Compute Pipeline 基本上都是围绕 GPU 这个 IP 进行的，Vulkan API 的设计也可以看出这一点。 而 Display Pipeline （这里指显示）主要围绕 DC (Display Controller) 这个 IP 进行。</p>
<p>本文所涉及的知识本身并没有什么新的东西，但对我来说是新的，所以这篇文章也是作为一个学习笔记来整理和记录自己对 Display Pipeline 的理解。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ol>
<li><a href="https://ppaalanen.blogspot.com/2014/06/from-pre-history-to-beyond-global.html">From pre-history to beyond the global thermonuclear war</a></li>
<li><a href="https://lists.freedesktop.org/archives/dri-devel/2014-March/055222.html">RFCv2 00/10 Universal plane support</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/gpu/amdgpu/display/mpo-overview.html?highlight=mpo">Multiplane Overlay (MPO)</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Boot-up Graphics in Linux</title>
    <url>/lnx/default-vga/</url>
    <content><![CDATA[<p>Boot-up Graphics 指在 Linux 系统启动时涉及到一些和图形显示相关的问题。</p>
<span id="more"></span>
<p>当主板上同时有多张PCI显卡时, 哪一个会做为<strong>默认</strong>显示输出呢？</p>
<p>一个最简单的场景，主板上有一个 Intel 的集显，还有一个 AMD 的独显，这两个 GPU 各自通过 HDMI 接口连接到同一个显示器上，那么在Linux 系统启动时（未进入桌面环境），是哪个 GPU 在显示呢？</p>
<h1 id="linux-vgaarbiter"><a class="markdownIt-Anchor" href="#linux-vgaarbiter"></a> <a href="https://www.kernel.org/doc/html/v4.10/gpu/vgaarbiter.html">Linux VGAArbiter</a></h1>
<p>Linux kernel vgaarbiter 的创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit deb2d2ecd43dfc51efe71eed7128fda514da96c6</span><br><span class="line">Author: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;</span><br><span class="line">Date:   Tue Aug 11 15:52:06 2009 +1000</span><br><span class="line"></span><br><span class="line">    PCI/GPU: implement VGA arbitration on Linux</span><br><span class="line"></span><br><span class="line">    Background:</span><br><span class="line">    Graphic devices are accessed through ranges in I/O or memory space. While most</span><br><span class="line">    modern devices allow relocation of such ranges, some &quot;Legacy&quot; VGA devices</span><br><span class="line">    implemented on PCI will typically have the same &quot;hard-decoded&quot; addresses as</span><br><span class="line">    they did on ISA. For more details see &quot;PCI Bus Binding to IEEE Std 1275-1994</span><br><span class="line">    Standard for Boot (Initialization Configuration) Firmware Revision 2.1&quot;</span><br><span class="line">    Section 7, Legacy Devices.</span><br><span class="line"></span><br><span class="line">    The Resource Access Control (RAC) module inside the X server currently does</span><br><span class="line">    the task of arbitration when more than one legacy device co-exists on the same</span><br><span class="line">    machine. But the problem happens when these devices are trying to be accessed</span><br><span class="line">    by different userspace clients (e.g. two server in parallel). Their address</span><br><span class="line">    assignments conflict. Therefore an arbitration scheme _outside_ of the X</span><br><span class="line">    server is needed to control the sharing of these resources. This document</span><br><span class="line">    introduces the operation of the VGA arbiter implemented for Linux kernel.</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;</span><br><span class="line">    Signed-off-by: Tiago Vignatti &lt;tiago.vignatti@nokia.com&gt;</span><br><span class="line">    Signed-off-by: Dave Airlie &lt;airlied@redhat.com&gt;</span><br><span class="line">    Signed-off-by: Jesse Barnes &lt;jbarnes@virtuousgeek.org&gt;</span><br><span class="line"></span><br><span class="line"> drivers/gpu/Makefile     |    2 +-</span><br><span class="line"> drivers/gpu/vga/Kconfig  |   10 +</span><br><span class="line"> drivers/gpu/vga/Makefile |    1 +</span><br><span class="line"> drivers/gpu/vga/vgaarb.c | 1206 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> drivers/pci/pci.c        |   44 ++++</span><br><span class="line"> drivers/video/Kconfig    |    2 +</span><br><span class="line"> include/linux/pci.h      |    2 +</span><br><span class="line"> include/linux/vgaarb.h   |  195 +++++++++++++++++</span><br><span class="line"> 8 files changed, 1461 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<h1 id="x-server的输出设备检测和驱动加载"><a class="markdownIt-Anchor" href="#x-server的输出设备检测和驱动加载"></a> X Server的输出设备检测和驱动加载</h1>
<h2 id="a-namexf86_platform_deviceaxorg抽象的输出设备"><a class="markdownIt-Anchor" href="#a-namexf86_platform_deviceaxorg抽象的输出设备"></a> <a name="xf86_platform_device"></a>Xorg抽象的输出设备</h2>
<p>Linux下的显示输出设备一般要么是一个<code>pci_device</code>，要么是一个<code>xf86_platform_device</code><br />
Xorg定义了一个全局数组<code>xf86_platform_devices</code>, 这个数组的元素类型是<code>xf86_platform_device</code>, 存储是动态申请的，Xorg探测到一个PCI显卡时，就申请一个存储。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct xf86_platform_device *xf86_platform_devices;</span><br><span class="line"></span><br><span class="line">struct xf86_platform_device &#123;</span><br><span class="line">		struct OdevAttributes *attribs;</span><br><span class="line">		struct pci_device *pdev;</span><br><span class="line">		int flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct OdevAttributes &#123;</span><br><span class="line">		char *path;</span><br><span class="line">		char *syspath;</span><br><span class="line">		char *busid;</span><br><span class="line">		int fd;</span><br><span class="line">		int major;</span><br><span class="line">		int minor;</span><br><span class="line">		char *driver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>OdevAttributes</code>定义了一个PCI输出设备的属性。</p>
<ul>
<li>
<p>path</p>
<p>kernel device node, <code>/dev/dri/card0</code></p>
</li>
<li>
<p>syspath</p>
<p>system device path, <code>/sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/drm/card1</code></p>
</li>
<li>
<p>busid</p>
<p>DRI 风格的Bus ID， 如 “pci:0000:04:00.0”</p>
</li>
<li>
<p>fd</p>
<p>文件描述符，<code>open(/dev/dri/card0)</code>返回值</p>
</li>
<li>
<p>major</p>
<p>主设备号</p>
</li>
<li>
<p>minor</p>
<p>次设备号</p>
</li>
<li>
<p>driver</p>
<p>kernel driver name, 如 “amdgpu”</p>
</li>
</ul>
<h1 id="pci-busid"><a class="markdownIt-Anchor" href="#pci-busid"></a> PCI BusID</h1>
<h2 id="dri-style"><a class="markdownIt-Anchor" href="#dri-style"></a> DRI-style</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pci:0000:04:00.0</span><br></pre></td></tr></table></figure>
<ul>
<li><code>0000</code> PCI domain</li>
<li><code>  04</code> PCI bus</li>
<li><code>  00</code> PCI device</li>
<li><code>   0</code> PCI function</li>
</ul>
<h2 id="xorg-日志"><a class="markdownIt-Anchor" href="#xorg-日志"></a> Xorg 日志</h2>
<ul>
<li>来自 xorg-server-1.18.4 版本的 Xorg 日志</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[     8.456] (--) PCI: (0:5:0:0) 1002:677b:174b:3000 rev 0, Mem @ 0x1040000000/268435456, 0x58600000/131072, I/O @ 0x00002000/256, BIOS @ 0x????????/131072</span><br></pre></td></tr></table></figure>
<ul>
<li>来自 xorg-server-1.20.0 版本的 Xorg 日志</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    40.891] (--) PCI: (10@0:0:0) 1a03:2000:1a03:2000 rev 65, Mem @ 0x60000000/16777216, 0x61000000/131072, I/O @ 0x00002000/128, BIOS @ 0x????????/65536</span><br></pre></td></tr></table></figure>
<p>变更发生于 2017-06-19:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit e905b19a53f96013c4417bec993a1dea5a3b0a5f</span><br><span class="line">Author: Michel Dänzer &lt;michel.daenzer@amd.com&gt;</span><br><span class="line">Date:   Mon Jun 19 19:05:29 2017 +0900</span><br><span class="line"></span><br><span class="line">    xfree86: Print BusID stanza compatible bus IDs for found devices</span><br><span class="line"></span><br><span class="line">    The PCI domain has to be specified like this:</span><br><span class="line"></span><br><span class="line">     &quot;PCI:&lt;bus&gt;@&lt;domain&gt;:&lt;device&gt;:&lt;function&gt;&quot;</span><br><span class="line"></span><br><span class="line">    Example before:</span><br><span class="line"></span><br><span class="line">     (--) PCI:*(0:0:1:0) 1002:130f:1043:85cb [...]</span><br><span class="line">     (--) PCI: (0:1:0:0) 1002:6939:1458:229d [...]</span><br><span class="line"></span><br><span class="line">    after:</span><br><span class="line"></span><br><span class="line">     (--) PCI:*(0@0:1:0) 1002:130f:1043:85cb [...]</span><br><span class="line">     (--) PCI: (1@0:0:0) 1002:6939:1458:229d [...]</span><br><span class="line"></span><br><span class="line">    Reviewed-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;</span><br><span class="line">    Signed-off-by: Michel Dänzer &lt;michel.daenzer@amd.com&gt;</span><br></pre></td></tr></table></figure>
<h2 id="xorg-配置文件-device-section"><a class="markdownIt-Anchor" href="#xorg-配置文件-device-section"></a> Xorg 配置文件 “Device” Section</h2>
<p>上面两种格式都可以作为<code>Device</code>段里<code>BusID</code>的格式，X11规定的<code>BusID</code>的格式是</p>
<p>“bus<font color="green">[@domain]</font>:device<font color="green">[:func]</font>”</p>
<p>Xserver依赖下面的用户空间库来填写该结构，这个过程也体现了Xserver检测显卡及加载驱动的过程</p>
<ul>
<li><a href="https://gitlab.freedesktop.org/xorg/lib/libpciaccess">libpciaccess</a></li>
<li><a href="https://github.com/systemd/systemd/tree/main/src/libudev">libudev</a></li>
<li><a href="https://gitlab.freedesktop.org/mesa/drm">libdrm</a></li>
</ul>
<ol>
<li>通过<code>libpciaccess</code>的接口发现系统PCI设备，获取<code>syspath</code>, <code>path</code></li>
<li>通过<code>open</code>系统调用打开侦测到的<code>drm_device</code>，<code>fd</code>有了</li>
<li>通过<code>libdrm</code>接口获取<code>major</code>, <code>minor</code>和<code>driver</code></li>
</ol>
<h2 id="如何快速确定-pci-busid-与-dev-设备节点的对应关系"><a class="markdownIt-Anchor" href="#如何快速确定-pci-busid-与-dev-设备节点的对应关系"></a> 如何快速确定 PCI BusID 与 <code>/dev</code> 设备节点的对应关系</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /dev/dri/by-path</span><br></pre></td></tr></table></figure>
<h1 id="device-detect-routines"><a class="markdownIt-Anchor" href="#device-detect-routines"></a> Device Detect Routines</h1>
<p>Xserver提供了两种设备检测方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void xf86PlatformDeviceProbe(struct OdevAttributes *attribs);</span><br><span class="line">void xf86PciProbe(void);</span><br></pre></td></tr></table></figure>
<p>默认是使用<code>xf86PlatformDeviceProbe</code>， 当这个函数完成<code>xf86_add_platform_device</code>后，除了<code>attribs</code>, <code>xf86_platform_device</code>的其它成员还没有被填写，剩下的任务交由<code>libudev</code>, <code>libpciaccess</code>和<code>libdrm</code>的接口完成。</p>
<h2 id="libudev"><a class="markdownIt-Anchor" href="#libudev"></a> libudev</h2>
<ul>
<li>udev_enumerate_add_match_subsys</li>
<li>udev_enumerate_add_match_sysname</li>
</ul>
<h2 id="libpciaccess"><a class="markdownIt-Anchor" href="#libpciaccess"></a> libpciaccess</h2>
<ul>
<li>pci_device_probe</li>
<li>pci_device_is_boot_vga</li>
</ul>
<h2 id="libdrm"><a class="markdownIt-Anchor" href="#libdrm"></a> libdrm</h2>
<ul>
<li>drmSetInterfaceVersion</li>
<li>drmGetBusid</li>
<li>drmGetVersion</li>
</ul>
<h1 id="primary-bus"><a class="markdownIt-Anchor" href="#primary-bus"></a> Primary Bus</h1>
<p>在多卡的情况下，Xserver启动后默认使用哪个显卡显示？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _bus &#123;</span><br><span class="line">	BusType type;</span><br><span class="line">	union &#123;</span><br><span class="line">		struct pci_device *pci;</span><br><span class="line">		SbusBusId sbus;</span><br><span class="line">		struct xf86_platform_device *plat;</span><br><span class="line">	&#125; id;</span><br><span class="line">&#125; BusRec, *BusPtr;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Xserver定义了一个全局的<code>BusRec</code>类型变量<code>primaryBus</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BusRec primaryBus = &#123; BUS_NONE, &#123;0&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>这个<code>primaryBus</code>将是Xserver启动后默认使用的显卡设备的唯一候选者。</p>
<h1 id="who-is-the-lucky-boy"><a class="markdownIt-Anchor" href="#who-is-the-lucky-boy"></a> Who Is The Lucky Boy?</h1>
<p>Xserver有两个规则去确定<a href="#primary-bus">primaryBus</a>:</p>
<ul>
<li><a href="#libudev">config_udev_odev_probe</a></li>
<li><a href="#libpciaccess">pci_device_is_boot_vga</a></li>
</ul>
<h2 id="how-config_udev_odev_probe-works"><a class="markdownIt-Anchor" href="#how-config_udev_odev_probe-works"></a> How <code>config_udev_odev_probe</code> Works?</h2>
<p><code>config_udev_odev_probe</code>唯一的参数是一个callback函数<code>xf86PlatformDeviceProbe</code>, <code>config_udev_odev_probe</code>要做的就是调用<a href="#libudev">libudev</a>的接口枚举出<code>/dev</code>文件系统里注册的<code>drm</code>设备，将它的<code>path</code>填到<a href="#xf86_platform_device">xf86_platform_device.attribs-&gt;path</a>。所以这一步决定了<a href="#xf86_platform_devices">xf86_platform_devices</a>数组中platform device的顺序，按照此顺序最后那个<code>pci_device_is_boot_vga</code>返回<code>True</code>的显示设备将为<code>primaryBus</code>, 但这是在没有配置<code>PrimaryGPU</code>选项时的行为。下面的代码来自<code>libudev</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_public_ int sd_device_enumerator_add_match_sysname(sd_device_enumerator *enumerator, const char *sysname) &#123;</span><br><span class="line">        int r;</span><br><span class="line"></span><br><span class="line">        assert_return(enumerator, -EINVAL);</span><br><span class="line">        assert_return(sysname, -EINVAL);</span><br><span class="line"></span><br><span class="line">        r = set_put_strdup(&amp;enumerator-&gt;match_sysname, sysname);</span><br><span class="line">        if (r &lt;= 0)</span><br><span class="line">                return r;</span><br><span class="line"></span><br><span class="line">        enumerator-&gt;scan_uptodate = false;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里参数<code>sysname</code>是一个正则表达式<code>card[0-9]*</code></p>
<h2 id="how-pci_device_is_boot_vga-works"><a class="markdownIt-Anchor" href="#how-pci_device_is_boot_vga-works"></a> How <code>pci_device_is_boot_vga</code> Works?</h2>
<p><code>pci_device_is_boot_vga</code>是一个虚接口，在Linux下的实现是<code>pci_device_linux_sysfs_boot_vga</code>, 下面的代码来自<code>libpciaccess</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int pci_device_linux_sysfs_boot_vga(struct pci_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    char name[256];</span><br><span class="line">    char reply[3];</span><br><span class="line">    int fd, bytes_read;</span><br><span class="line">    int ret = 0;</span><br><span class="line"></span><br><span class="line">    snprintf( name, 255, &quot;%s/%04x:%02x:%02x.%1u/boot_vga&quot;,</span><br><span class="line">	      SYS_BUS_PCI,</span><br><span class="line">	      dev-&gt;domain,</span><br><span class="line">	      dev-&gt;bus,</span><br><span class="line">	      dev-&gt;dev,</span><br><span class="line">	      dev-&gt;func );</span><br><span class="line"></span><br><span class="line">    fd = open( name, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    if (fd == -1)</span><br><span class="line">       return 0;</span><br><span class="line"></span><br><span class="line">    bytes_read = read(fd, reply, 1);</span><br><span class="line">    if (bytes_read != 1)</span><br><span class="line">	goto out;</span><br><span class="line">    if (reply[0] == &#x27;1&#x27;)</span><br><span class="line">	ret = 1;</span><br><span class="line">out:</span><br><span class="line">    close(fd);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>SYS_BUS_PCI</code>被定义为<code>/sys/bus/pci/devices</code>, <code>pci_device_is_boot_vga</code>的返回值取决于显示设备的<strong>kernel driver</strong>如何实现<code>sysfs</code>文件系统中的<code>/sys/bus/pci/devices/0000:05:00.0/boot_vga</code>节点。</p>
<p>以上两点规则说明，在多卡系统中，不使用<code>PrimaryGPU</code>的情况下，当且仅当目标卡的<code>drm</code>设备节点号最大，而且<code>/sys/bus/pci/devices/XXXX:XX:XX.X/boot_vga</code>被实现为read它返回ASCII字符<code>'1'</code>. 这样目标卡才能做为<code>primaryBus</code>设备默认显示输出。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://patchwork.freedesktop.org/patch/539963/?series=118518&amp;rev=1">pci/vgaarb: make vga_is_firmware_default() arch independent</a></li>
<li><a href="https://lore.kernel.org/dri-devel/20230906132904.4e49e269.alex.williamson@redhat.com/T/#t">discussion on ML</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>Buffer Sharing and Synchronization</title>
    <url>/lnx/dma-buf/</url>
    <content><![CDATA[<h1 id="dma-buf"><a class="markdownIt-Anchor" href="#dma-buf"></a> DMA-BUF</h1>
<pre><code class="highlight mermaid">flowchart BT
	App@&#123; img: &quot;/images/dma-buf/window-content.png&quot;, label: &quot;vram for rendering&quot;, pos: &quot;d&quot;, w: 60, h: 60, constraint: &quot;on&quot; &#125;
	Window@&#123; img: &quot;/images/dma-buf/window-frame.png&quot;, label: &quot;vram for window frame&quot;, pos: &quot;d&quot;, w: 60, h: 60, constraint: &quot;on&quot; &#125;

	subgraph app [glxgears]
		BO_10
	end
	subgraph x11 [Xorg]
		BO_20
		BO_11
	end
	subgraph compositor [kwin_x11]
		BO_21
	end

	App ~~~ BO_10 --Exporter--&gt; App
	App --Importer--&gt; BO_11

	Window ~~~ BO_20 --Exporter--&gt; Window
	Window --Importer--&gt; BO_21</code></pre>
<span id="more"></span>
<p>DMA-BUF 是 Linux 内核驱动中在上下文间，进程间，设备间，子系统间共享 buffer 的一种机制。 大概在<a href="https://lwn.net/Articles/473668/">内核 3.2 版本就实现了</a>。 按最初的设计文档描述的，该框架大致是这样的:</p>
<ul>
<li>导出者创建一个固定大小的 buffer object, 并将一个 struct file(anon file) 和 allocator 定义的一组操作(map/unmap/cache-sync 等等) (<code>struct dma_buf_ops</code>) 与之关联</li>
<li>不同的设备调用 <code>dma_buf_attach()</code> 将自己加到 buffer object 的 attachments 列表， 因为一个 buffer object 可以供多个设备(importers)使用</li>
<li>这个导出的 buffer object 在各种实体间通过共享文件描述符 fd 来共享</li>
<li>收到 fd 的导入者将重新获取到 buffer object, 使用导出时关联的 <code>dma_buf_attach_ops</code> 去访问这个 buffer</li>
<li>导出者和导入者使用 <code>map_dma_buf()</code> 和 <code>unmap_dma_buf()</code> 来共享 buffer object 的 scatterlist</li>
</ul>
<p><code>struct dma_buf</code> 是一种<strong>胶水结构</strong>， 它将一个 <strong>anonymous file</strong> 和一个 <strong>drm_gem_object</strong> 以及导出者需要实现的一组对这个 buffer 的一组操作 <strong>dma_buf_ops</strong> 等等<strong>粘合在一起</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_buf</span> &#123;</span></span><br><span class="line">  <span class="type">size_t</span> size; <span class="comment">// buffer size,  不变</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// anonymous file struct</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">attachments</span>;</span> <span class="comment">// 所有导入者的一个链表</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dma_buf_ops</span> *<span class="title">ops</span>;</span> <span class="comment">// 由导出者负责实现，如 map/unmap</span></span><br><span class="line">  <span class="type">unsigned</span> vmapping_counter； <span class="comment">// vmaps 的引用计数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iosys_map</span> <span class="title">vmap_ptr</span>;</span> <span class="comment">// 当 vmapping_counter 大于 0 时，指向当前的 vmap</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *exp_name;  <span class="comment">// 导出者字符串，debugging</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">// accounting &amp; debugging</span></span><br><span class="line">  <span class="type">spinlock_t</span> name_lock； <span class="comment">// 互斥访问 name 的锁</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>  <span class="comment">// 导出者 module</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_node</span>;</span> <span class="comment">// accounting &amp; debugging</span></span><br><span class="line">  <span class="type">void</span> *priv; <span class="comment">// 指向 drm_gem_object</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dma_resv</span> *<span class="title">resv</span>;</span></span><br><span class="line">  <span class="type">wait_queue_head_t</span> poll; <span class="comment">// 允许用户空间 poll()</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dma_buf_poll_cb_t</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_fence_cb</span> <span class="title">cb</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> *poll;</span><br><span class="line"></span><br><span class="line">	<span class="type">__poll_t</span> active;</span><br><span class="line">  &#125; cb_in, cb_out;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dma_buf_sysfs_entry</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_buf</span> *<span class="title">dmabuf</span>;</span></span><br><span class="line">  &#125; *sysfs_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 glxgears(<code>PRIME_HANDLE_TO_FD</code>) 和 Xorg(<code>PRIME_FD_TO_HANDLE</code>) 之间的共享过程为例, 主要有两个主要问题：</p>
<ul>
<li>要给 DMA-BUF 套一层匿名文件(Anonymous File), 这样才可以安全地在进程间共享</li>
<li>导入后，导入进程新建的 GPU <strong>虚拟显存地址到物理显存地址</strong>的映射要能够映射到<strong>与导出侧相同的 GPU 物理显存地址</strong> (GPU VA 倒无所谓)</li>
</ul>
<p>内核在 drm_file 下搞了一个 dmabuf 和 handle 的红黑树作为 <strong>DMA-BUF 缓存</strong>， 这样在同一设备文件中的导出导入或同一个 drm_gem_object 被同一个设备多次导入的情况就会高效一些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct drm_prime_file_private - per-file tracking for PRIME</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This just contains the internal &amp;struct dma_buf and handle caches for each</span></span><br><span class="line"><span class="comment"> * &amp;struct drm_file used by the PRIME core code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_prime_file_private</span> &#123;</span></span><br><span class="line"><span class="comment">/* private: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">dmabufs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">handles</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个 <strong>import/export caches</strong> 有几个必要的作用：</p>
<ul>
<li>保证对于任意一个 drm_gem_object 总是有<strong>一个唯一的用户态 handle</strong> (见 <a href="https://lucmann.github.io/gfx/piglit/">Piglit: ext_image_dma_buf_import-refcount-multithread</a>)</li>
<li>可以允许 UMD 去<strong>检测重复的导入</strong></li>
</ul>
<p><code>struct file</code>, <code>struct drm_file</code>, <code>struct drm_prime_file_private</code> 三者的关系是</p>
<pre><code class="highlight mermaid">erDiagram
	file ||--|| drm_file : contains
	file &#123;
		atomic_long_t	f_count
		spinlock_t		f_lock
		fmode_t			f_mode
		file_operations	*f_op
		address_space	*f_mapping
		void			*private_data
	&#125;
	drm_file ||--|| drm_prime_file_private : contains
	drm_file &#123;
		TYPES					others
		drm_prime_file_private	prime
	&#125;
	drm_prime_file_private &#123;
		mutex lock
		rb_root dmabufs
		rb_root handles
	&#125;</code></pre>
<h2 id="导入导出的实现"><a class="markdownIt-Anchor" href="#导入导出的实现"></a> 导入/导出的实现</h2>
<pre><code class="highlight mermaid">flowchart LR
  subgraph export [&quot;Export&quot;]
    direction TB
    1a[&quot;drmPrimeHandleToFD()&quot;]
	1b[&quot;DRM_IOCTL_PRIME_HANDLE_TO_FD&quot;]
	1c[&quot;drm_prime_handle_to_fd_ioctl()&quot;]
	1d[&quot;drm_gem_prime_handle_to_fd()&quot;]
	1e[&quot;drm_gem_prime_handle_to_dmabuf()&quot;]
	1f[&quot;export_and_register_object()&quot;]
  end
  subgraph import [&quot;Import&quot;]
    direction TB
    2a[&quot;drmPrimeFDToHandle()&quot;]
	2b[&quot;DRM_IOCTL_PRIME_FD_TO_HANDLE&quot;]
	2c[&quot;drm_prime_fd_to_handle_ioctl()&quot;]
	2d[&quot;drm_gem_prime_fd_to_handle()&quot;]
	2e[&quot;drm_prime_lookup_buf_handle()&quot;]
	2f[&quot;drm_gem_prime_import()&quot;]
  end

  1a --&gt; 1b --&gt; 1c --&gt; 1d --&gt; 1e --&gt; 1f
  2a --&gt; 2b --&gt; 2c --&gt; 2d --&gt; 2e --&gt; 2f

  export --&gt; import</code></pre>
<p><code>struct file</code>， <code>struct dma_buf</code> 的关系</p>
<ul>
<li>导出者 <code>DRM_IOCTL_PRIME_HANDLE_TO_FD</code></li>
</ul>
<p>先拿这个 gem_handle 去红黑树里找 dma_buf (<strong><code>drm_prime_lookup_buf_by_handle()</code></strong>), 如果有就返回这个 dma_buf，如果没有就调用 <code>export_and_register_object()</code> 给对应的 drm_gem_object 新申请一个 <code>struct dma_buf</code>，再由内核把这个 gem_handle 和 dma_buf 都缓存到红黑树中 (<strong><code>drm_prime_add_buf_handle()</code></strong>)， 最后 <code>fd_install(fd, dmabuf-&gt;file);</code> 把 fd 返回用户态的导出者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dma_buf_export - Creates a new dma_buf, and associates an anon file</span></span><br><span class="line"><span class="comment"> * with this buffer, so it can be exported.</span></span><br><span class="line"><span class="comment"> * Also connect the allocator specific data and ops to the buffer.</span></span><br><span class="line"><span class="comment"> * Additionally, provide a name string for exporter; useful in debugging.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @exp_info:	[in]	holds all the export related information provided</span></span><br><span class="line"><span class="comment"> *			by the exporter. see &amp;struct dma_buf_export_info</span></span><br><span class="line"><span class="comment"> *			for further details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns, on success, a newly created struct dma_buf object, which wraps the</span></span><br><span class="line"><span class="comment"> * supplied private data and operations for struct dma_buf_ops. On either</span></span><br><span class="line"><span class="comment"> * missing ops, or error in allocating struct dma_buf, will return negative</span></span><br><span class="line"><span class="comment"> * error.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For most cases the easiest way to create @exp_info is through the</span></span><br><span class="line"><span class="comment"> * %DEFINE_DMA_BUF_EXPORT_INFO macro.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dma_buf *<span class="title function_">dma_buf_export</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dma_buf_export_info *exp_info)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_buf</span> *<span class="title">dmabuf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_resv</span> *<span class="title">resv</span> =</span> exp_info-&gt;resv;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">size_t</span> alloc_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dma_buf);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!exp_info-&gt;priv || !exp_info-&gt;ops</span><br><span class="line">		    || !exp_info-&gt;ops-&gt;map_dma_buf</span><br><span class="line">		    || !exp_info-&gt;ops-&gt;unmap_dma_buf</span><br><span class="line">		    || !exp_info-&gt;ops-&gt;release))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(exp_info-&gt;ops-&gt;cache_sgt_mapping &amp;&amp;</span><br><span class="line">		    (exp_info-&gt;ops-&gt;pin || exp_info-&gt;ops-&gt;unpin)))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!exp_info-&gt;ops-&gt;pin != !exp_info-&gt;ops-&gt;unpin))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(exp_info-&gt;owner))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line"></span><br><span class="line">	file = dma_buf_getfile(exp_info-&gt;size, exp_info-&gt;flags);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">		ret = PTR_ERR(file);</span><br><span class="line">		<span class="keyword">goto</span> err_module;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!exp_info-&gt;resv)</span><br><span class="line">		alloc_size += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dma_resv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* prevent &amp;dma_buf[1] == dma_buf-&gt;resv */</span></span><br><span class="line">		alloc_size += <span class="number">1</span>;</span><br><span class="line">	dmabuf = kzalloc(alloc_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dmabuf) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_file;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dmabuf-&gt;priv = exp_info-&gt;priv;</span><br><span class="line">	dmabuf-&gt;ops = exp_info-&gt;ops;</span><br><span class="line">	dmabuf-&gt;size = exp_info-&gt;size;</span><br><span class="line">	dmabuf-&gt;exp_name = exp_info-&gt;exp_name;</span><br><span class="line">	dmabuf-&gt;owner = exp_info-&gt;owner;</span><br><span class="line">	spin_lock_init(&amp;dmabuf-&gt;name_lock);</span><br><span class="line">	init_waitqueue_head(&amp;dmabuf-&gt;poll);</span><br><span class="line">	dmabuf-&gt;cb_in.poll = dmabuf-&gt;cb_out.poll = &amp;dmabuf-&gt;poll;</span><br><span class="line">	dmabuf-&gt;cb_in.active = dmabuf-&gt;cb_out.active = <span class="number">0</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;dmabuf-&gt;attachments);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!resv) &#123;</span><br><span class="line">		dmabuf-&gt;resv = (<span class="keyword">struct</span> dma_resv *)&amp;dmabuf[<span class="number">1</span>];</span><br><span class="line">		dma_resv_init(dmabuf-&gt;resv);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dmabuf-&gt;resv = resv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = dma_buf_stats_setup(dmabuf, file);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_dmabuf;</span><br><span class="line"></span><br><span class="line">	file-&gt;private_data = dmabuf;</span><br><span class="line">	file-&gt;f_path.dentry-&gt;d_fsdata = dmabuf;</span><br><span class="line">	dmabuf-&gt;file = file;</span><br><span class="line"></span><br><span class="line">	__dma_buf_debugfs_list_add(dmabuf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dmabuf;</span><br><span class="line"></span><br><span class="line">err_dmabuf:</span><br><span class="line">	<span class="keyword">if</span> (!resv)</span><br><span class="line">		dma_resv_fini(dmabuf-&gt;resv);</span><br><span class="line">	kfree(dmabuf);</span><br><span class="line">err_file:</span><br><span class="line">	fput(file);</span><br><span class="line">err_module:</span><br><span class="line">	module_put(exp_info-&gt;owner);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>导入者 <code>DRM_IOCTL_PRIME_FD_TO_HANDLE</code></li>
</ul>
<p>导入者接收到底层透过 UNIX domain socket 传来的 prime_fd 后 (如 Xorg 通过 <code>proc_dri3_pixmap_from_buffers()</code> 接收)，通过 <code>DRM_IOCTL_PRIME_FD_TO_HANDLE</code> IOCTL 陷入内核态，内核通过 <code>dma_buf_get(prime_fd)</code> 直接找到对应的 DMA-BUF, 然后先去 DMA-BUF 缓存中找 (<code>drm_prime_lookup_buf_handle()</code>)，如果命中就直接将 handle 返回给导入者， 如果不命中，就调用 <code>drm_gem_prime_import_dev()</code> 来完成 DMA-BUF Sharing 中最最关键的操作：<strong>当 Buffer 导入另外一个进程后，这个 Buffer 的 GPU Mappings (GPU pagetables) 怎么复制过来</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_gem_prime_import_dev - core implementation of the import callback</span></span><br><span class="line"><span class="comment"> * @dev: drm_device to import into</span></span><br><span class="line"><span class="comment"> * @dma_buf: dma-buf object to import</span></span><br><span class="line"><span class="comment"> * @attach_dev: struct device to dma_buf attach</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is the core of drm_gem_prime_import(). It&#x27;s designed to be called by</span></span><br><span class="line"><span class="comment"> * drivers who want to use a different device structure than &amp;drm_device.dev for</span></span><br><span class="line"><span class="comment"> * attaching via dma_buf. This function calls</span></span><br><span class="line"><span class="comment"> * &amp;drm_driver.gem_prime_import_sg_table internally.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Drivers must arrange to call drm_prime_gem_destroy() from their</span></span><br><span class="line"><span class="comment"> * &amp;drm_gem_object_funcs.free hook when using this function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> drm_gem_object *<span class="title function_">drm_gem_prime_import_dev</span><span class="params">(<span class="keyword">struct</span> drm_device *dev,</span></span><br><span class="line"><span class="params">					    <span class="keyword">struct</span> dma_buf *dma_buf,</span></span><br><span class="line"><span class="params">					    <span class="keyword">struct</span> device *attach_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_buf_attachment</span> *<span class="title">attach</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> *<span class="title">sgt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">drm_gem_object</span> *<span class="title">obj</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dma_buf-&gt;ops == &amp;drm_gem_prime_dmabuf_ops) &#123;</span><br><span class="line">		obj = dma_buf-&gt;priv;</span><br><span class="line">		<span class="keyword">if</span> (obj-&gt;dev == dev) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Importing dmabuf exported from our own gem increases</span></span><br><span class="line"><span class="comment">			 * refcount on gem itself instead of f_count of dmabuf.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			drm_gem_object_get(obj);</span><br><span class="line">			<span class="keyword">return</span> obj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;driver-&gt;gem_prime_import_sg_table)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	attach = dma_buf_attach(dma_buf, attach_dev);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(attach))</span><br><span class="line">		<span class="keyword">return</span> ERR_CAST(attach);</span><br><span class="line"></span><br><span class="line">	get_dma_buf(dma_buf);</span><br><span class="line"></span><br><span class="line">	sgt = dma_buf_map_attachment_unlocked(attach, DMA_BIDIRECTIONAL);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(sgt)) &#123;</span><br><span class="line">		ret = PTR_ERR(sgt);</span><br><span class="line">		<span class="keyword">goto</span> fail_detach;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	obj = dev-&gt;driver-&gt;gem_prime_import_sg_table(dev, attach, sgt);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(obj)) &#123;</span><br><span class="line">		ret = PTR_ERR(obj);</span><br><span class="line">		<span class="keyword">goto</span> fail_unmap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	obj-&gt;import_attach = attach;</span><br><span class="line">	obj-&gt;resv = dma_buf-&gt;resv;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">fail_unmap:</span><br><span class="line">	dma_buf_unmap_attachment_unlocked(attach, sgt, DMA_BIDIRECTIONAL);</span><br><span class="line">fail_detach:</span><br><span class="line">	dma_buf_detach(dma_buf, attach);</span><br><span class="line">	dma_buf_put(dma_buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dynamic-dma-buf-mapping-和-cached-sg-table"><a class="markdownIt-Anchor" href="#dynamic-dma-buf-mapping-和-cached-sg-table"></a> Dynamic DMA-BUF Mapping 和 Cached Sg Table</h2>
<p>sg_table 是描述<strong>不连续的物理内存块</strong>(这个内存块是以物理页为单位的)的表结构，就是 scatterlist 的数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> &#123;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> 	page_link;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> 	offset;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> 	length;</span><br><span class="line">		<span class="type">dma_addr_t</span>		dma_address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>page_link</code> 保存的是 <code>struct page *</code>, 即物理页的结构体指针再加最低两位的两个标识位</li>
<li><code>dma_address</code> 在有 IOMMU 的系统中是一个 I/O 虚拟地址(下图中的 Z)，在没有 IOMMU 的系统中就是设备地址空间(或 DMA 地址空间)的物理地址(下图中的 Y)</li>
</ul>
<p><img src="/images/dma-buf/cpuva-cpupa-dma-addr.gif" alt="本图来自蜗窝科技" /></p>
<ul>
<li><code>dma_direct_map_sg()</code></li>
</ul>
<p><code>dma_direct_map_sg()</code> 是由一个 scatterlist 对应的物理页得到对应的 <code>dma_address</code>, 就是上图中 <strong>Y 到 Z 的映射</strong></p>
<pre><code class="highlight mermaid">flowchart LR
	A[&quot;struct scatterlist *&quot;]
	B[&quot;struct page *&quot;]
	C[&quot;phys_addr_t phys&quot;]
	D[&quot;sg-&gt;dma_address&quot;]

	A -- sg_page() --&gt; B -- page_to_phys() --&gt; C -- phys_to_dma() --&gt; D</code></pre>
<h2 id="dma_fence"><a class="markdownIt-Anchor" href="#dma_fence"></a> dma_fence</h2>
<p><code>struct dma_fence</code> 是一个类似 <code>struct completion</code> 的结构体，用来跟踪 GPU 任务，当一个 GPU 任务结束时，对应的 dma_fence 被 signaled.</p>
<p><code>dma_fence_default_wait</code> 是 dma-fence 默认的 wait 操作。该函数会让当前进程(task) 进入睡眠状态 (可中断睡眠或不可中断睡眠，取决于调用者传入的参数 <code>intr</code>）, 直到 dma-fence 被 signaled 或者设置的超时时间到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cb.base.func = dma_fence_default_wait_cb;</span><br><span class="line">cb.task = current;</span><br><span class="line">list_add(&amp;cb.base.node, &amp;fence-&gt;cb_list);</span><br></pre></td></tr></table></figure>
<h2 id="dma_resv"><a class="markdownIt-Anchor" href="#dma_resv"></a> dma_resv</h2>
<p><code>dma_resv</code> (reservation object) 是一组 dma_fence + 一个锁，当调用者通过 <code>dma_resv_add_fence()</code> 向 dma_resv 里加入新的 dma_fence 时需要持有这个锁。</p>
<ul>
<li>描述对 <code>dma_resv</code> 不同的使用场景</li>
<li>在调用 <code>dma_resv_get_fences()</code> 时，决定哪些 fences 被返回</li>
</ul>
<pre><code class="highlight mermaid">flowchart TD
    subgraph gem [drm_gem_object]
        D[dma_buf]
        subgraph _resv [&quot;struct dma_resv _resv&quot;]
            _F@&#123; shape: docs, label: &quot;dma_fence&quot;&#125;
        end
        RP[&quot;struct dma_resv *resv&quot;]
    end
    B@&#123; shape: lin-cyl, label: &quot;dma_buf&quot;&#125;
    subgraph resv [dma_resv]
        F@&#123; shape: docs, label: &quot;dma_fence&quot;&#125;
    end
    D --&gt; B --&gt; resv
    RP --except for imported GEM objects--&gt; _resv</code></pre>
<ul>
<li>为什么同一个 <code>dma_buf</code> 会有那么多 <code>dma_fence</code> 与之关联呢？</li>
</ul>
<p>因为同一个 Buffer 会有多个<strong>使用者</strong>， 有的读，有的写，有的等，这个 Buffer 的所有使用者的每个操作，理论上都有一个 <code>dma_fence</code>, 这些 <code>dma_fence</code> 在这整个机制下“有条不紊”地被 signaled, 才能保证所有访问都是按预期的顺序发生，这就是同步(每个使用者都可能是并发的进程)。</p>
<h1 id="synchronization"><a class="markdownIt-Anchor" href="#synchronization"></a> Synchronization</h1>
<p>隐式还是显式同步的主要区别在于同步是否由应用 (Applications) 直接控制，Vulkan 以前的图形 API，同步是由内核驱动或用户驱动完成的，应用完全不参与，这就是所谓的 “Implicit Synchronization”, Vulkan 中，同步完全是由应用控制的，哪个渲染任务等哪个渲染任务，CPU 什么时候等 GPU, 都是由应用直接控制，从这一点也说明 Vulkan 应用是比较难写的，但 Vulkan 驱动(尤其用户驱动) 相对简单一些。但是问题是，不是所有的图形应用都是 Vulkan 写的 (Xorg, Wayland compositor 都不是 Vulkan 写的，而好多 Wayland client 可能是 Vulkan 写的)，所以目前还需要一些其它方案解决这种隐式同步和显式同步共存的场景。<a href="https://zamundaaa.github.io/wayland/2024/04/05/explicit-sync.html">Explicit sync</a> 这篇博文关于这两者的概念讲得很清楚，这里主要是从实现的角度，做一下自己学习理解<strong>隐式同步和显式同步</strong>的记录。</p>
<h2 id="implicit-synchronization"><a class="markdownIt-Anchor" href="#implicit-synchronization"></a> Implicit Synchronization</h2>
<p>所谓<strong>隐式同步</strong>，就是驱动 (KMD) 会在每个 dmabuf 以及 buffer object 上附加一个 <code>dma_fence</code>, 以确保渲染命令的<strong>有序</strong>执行，以及 buffer 是否已经准备就绪后才可让<strong>消费者</strong>进行读取，所有这些工作基本上在内核完成，完全不需要应用程序的干预。这种方案虽然简单（对于应用开发者）来说，但会有<strong>过度同步 (Over-Synchronization)</strong> 的问题。</p>
<h2 id="explicit-synchronization"><a class="markdownIt-Anchor" href="#explicit-synchronization"></a> Explicit Synchronization</h2>
<ul>
<li>sync_file</li>
</ul>
<p><code>CONFIG_SYNC_FILE</code> 是内核 3.10 引入的一个可配置的 (configurable) 配置选项， 它控制的是 Linux 内核 Explicit Synchronization Framework 的编译。Sync File Framework 增加了由用户空间控制的显式同步, 它提供了通过用户空间组件 (Wayland, Vulkan 等)在驱动之间以 Sync File 文件描述符形式的 <code>struct dma_fence</code> 向用户空间的收发能力。Sync File 的主要使用者是 GPU 和 V4L 驱动, 它们通常会将一个 <code>dma_fence</code> 关联到一个 dmabuf, 这是<strong>隐式同步</strong>的做法,  而现在驱动会将与 dmabuf 相关的这个 <code>dma_fence</code> 以 <strong>Sync File FD</strong>传送到用户空间。</p>
<p><em>NOTE: sync file 最初是先在 Android kernel 内实现的</em></p>
<p>这里我们可以将 <a href="https://elixir.bootlin.com/linux/v6.13.5/source/include/drm/drm_syncobj.h#L39"><code>struct drm_syncobj</code></a> 和 <a href="https://elixir.bootlin.com/linux/v6.13.5/source/include/drm/drm_gem.h#L273"><code>struct drm_gem_object</code></a> 做个对比, 何其相似！</p>
<ul>
<li>drm_syncobj</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
  A[file descriptor]
  B[dma_fence]

  A -- SYNCOBJ_FD_TO_HANDLE&lt;br&gt;drmSyncobjFDToHandle() --&gt; B
  A &lt;-- drm_syncobj --&gt; B
  B -- SYNCOBJ_HANDLE_TO_FD&lt;br&gt;drmSyncobjHandleToFD() --&gt; A</code></pre>
<ul>
<li>drm_gem_object</li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
  A[file descriptor]
  B[dma_buf]

  A -- PRIME_FD_TO_HANDLE&lt;br&gt;drmPrimeFDToHandle() --&gt; B
  A &lt;-- drm_gem_object --&gt; B
  B -- PRIME_HANDLE_TO_FD&lt;br&gt;drmPrimeHandleToFD() --&gt; A</code></pre>
<ul>
<li>drmSyncobjCreate()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">drmSyncobjCreate</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> flags, <span class="type">uint32_t</span> *handle)</span>;</span><br></pre></td></tr></table></figure>
<p>drm_syncobj 在用户空间只是一个 32 位整数 (handle), 创建它的用户态接口接受两个入参，一个出参:</p>
<ul>
<li>fd: drm 设备节点打开后的文件描述符</li>
<li>flags: 要么 0， 要么 <code>DRM_SYNCOBJ_CREATE_SIGNALED</code></li>
<li>handle: 由内核返回的代表新创建的 drm_syncobj 的 ID 存放在 handle 这个地址</li>
</ul>
<p>再看看创建 syncobj 的内核态接口，它里面有两步:</p>
<ul>
<li>drm_syncobj_create()</li>
</ul>
<p>仅仅是申请 <code>struct drm_syncobj</code> 的内存, 初始化它的数据成员, 而且最关键的成员 <code>dma_fence</code> 还是空的，当用户传入 <code>DRM_SYNCOBJ_CREATE_SIGNALED</code> 标志时，<code>drm_syncobj_create()</code> 会自己创建一个 <strong>stub fence</strong> 赋给这个 syncobj, 如果创建时标志是 0， 则由用户后面绑定相关的 <code>dma_fence</code> (当然还是通过 syncobj 的形式，因为 <code>dma_fence</code> 对用户态不可见， 一般是用 <code>drmSyncobjExportSyncFile()</code>, <code>drmSyncobjCreate()</code>, <code>drmSyncobjImportSyncFile()</code> 来完成的。)</p>
<ul>
<li>drm_syncobj_get_handle()</li>
</ul>
<p>返回的这个 32 位整数代表的就是 drm_syncobj, 但它仍然不是文件描述符 fd, 最终要让 drm_syncobj 能有一个真正的文件描述符还需要两个 IOCTL:</p>
<ul>
<li><code>DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD</code></li>
<li><code>DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE</code></li>
</ul>
<p>感觉为了让用户空间能够直接操作 <code>dma_fence</code> 这个内核的同步原语，费了“好大劲”，这背后应该有系统设计层面的考虑，后面有时间再琢磨。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drm_syncobj_get_handle - get a handle from a syncobj</span></span><br><span class="line"><span class="comment"> * @file_private: drm file private pointer</span></span><br><span class="line"><span class="comment"> * @syncobj: Sync object to export</span></span><br><span class="line"><span class="comment"> * @handle: out parameter with the new handle</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Exports a sync object created with drm_syncobj_create() as a handle on</span></span><br><span class="line"><span class="comment"> * @file_private to userspace.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success or a negative error value on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">drm_syncobj_get_handle</span><span class="params">(<span class="keyword">struct</span> drm_file *file_private,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> drm_syncobj *syncobj, u32 *handle)</span></span><br></pre></td></tr></table></figure>
<h2 id="fd-to-handle-convert"><a class="markdownIt-Anchor" href="#fd-to-handle-convert"></a> FD to Handle Convert</h2>
<ul>
<li><code>int drmSyncobjFDToHandle(int fd, int obj_fd, uint32_t *handle);</code></li>
<li><code>int drmSyncobjHandleToFD(int fd, uint32_t handle, int *obj_fd);</code></li>
</ul>
<h2 id="sync-file-transfer"><a class="markdownIt-Anchor" href="#sync-file-transfer"></a> Sync File Transfer</h2>
<ul>
<li><code>int drmSyncobjImportSyncFile(int fd, uint32_t handle, int sync_file_fd);</code></li>
<li><code>int drmSyncobjExportSyncFile(int fd, uint32_t handle, int *sync_file_fd);</code></li>
</ul>
<p><code>drmSyncobjFDToHandle()</code> 和 <code>drmSyncobjImportSyncFile()</code> 的区别仅仅是后者设置了 <code>DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE</code> 这个 flags。<code>drmSyncobjHandleToFD()</code> 和 <code>drmSyncobjExportSyncFile()</code> 也是类似。</p>
<p><code>drmSyncobjExportSyncFile()</code> 通过 ioctl 将用户给定的 syncobj ID 转换成一个文件描述符返回给用户。而 SyncobjExport/ImportSyncFile 这对操作和 SyncobjFDToHandle/HandleToFD 这对操作的区别是后者是给<strong>同一个 drm_syncobj</strong> 提供<strong>两个不同的 ID</strong> 而已。</p>
<p>而前者通过和 <code>drmSyncobjCreate()</code> 配合，会产生另外一个<strong>新的 drm_syncobj</strong></p>
<h1 id="questions"><a class="markdownIt-Anchor" href="#questions"></a> Questions</h1>
<ul>
<li>syncobj 的 handle 可以是 0 吗？</li>
</ul>
<p><strong>不会是 0</strong></p>
<p><code>drm_syncobj_get_handle()</code> 和 <code>drm_gem_handle_create_tail()</code> 一样，是通过 <code>idr_alloc()</code> 申请的一个给定范围内的 32 位整数，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = idr_alloc(&amp;file_private-&gt;syncobj_idr, syncobj, <span class="number">1</span>, <span class="number">0</span>, GFP_NOWAIT);</span><br></pre></td></tr></table></figure>
<p>它申请范围在最小值是 1 (包含)和最大值是 0 (不包含，实际上最大值是 0xffffffff) 之间的一个整数。</p>
<p>这里主要根据<a href="https://patchwork.kernel.org/project/kvm/patch/20250107142719.179636-2-yilun.xu@linux.intel.com/">内核邮件列表里的一个讨论</a>来更好的理解 dma-buf 的设计思路和使用原则。</p>
<ul>
<li>
<p>对于 dma-buf 来说， 什么是 <strong>static attach</strong> ？ 什么是 <strong>dynamic attach</strong> ?</p>
<ul>
<li>static attach 应该是指 dma-buf 对应的 page 不会在内存中移动 (move), 而 dynamic attach 相反<strong>有可能移动</strong></li>
</ul>
</li>
<li>
<p>用户为什么不直接将 dma-buf 的 PFN (物理页帧号) 共享给 importer, 让 importer 自己去创建 mappings ？</p>
<ul>
<li>dma-buf 设计的就是不把 <code>struct page</code> 或 pfn 暴露给 importer, 本质上, dma-buf 只传送 dma_addr。所以 mappings 总是由 exporter 创建，而不是由 importer。</li>
<li>exported buffer 未必一定是内存 (有 <code>struct page</code>), 也可能是 MMIO</li>
</ul>
</li>
<li>
<p>但为什么一定要让 exporter 去 map 呢？</p>
</li>
<li>
<p>Exporter mapping 存在问题的场景:</p>
<ul>
<li>Private address space</li>
<li>Multi-path PCI</li>
<li>Importing devices need to do things like turn on ATS on their DMA</li>
<li>TPH bits needs to be programmed into importer device</li>
<li>iommufd and KVM</li>
</ul>
</li>
<li>
<p>为什么把 dma-buf 的 backing storage 信息暴露给 importer 是一个坏主意？</p>
</li>
<li>
<p>exporter 会获取 importer 的 <code>struct device</code></p>
</li>
<li>
<p>multipath 总是需要在 importer 侧有额外的元信息去告诉 device 选择哪个 path</p>
</li>
</ul>
<p>😦 这5个场景目前一个都不知道是干什么的 😦</p>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://docs.kernel.org/driver-api/dma-buf.html">kdoc: Buffer Sharing and Synchronization</a></li>
<li><a href="https://docs.kernel.org/driver-api/sync_file.html">Sync File API Guide</a></li>
<li><a href="https://lwn.net/Articles/454389/">Sharing buffers between devices</a></li>
<li><a href="https://blog.csdn.net/hexiaolong2009/article/details/105961192">PRIME</a></li>
<li><a href="https://blog.csdn.net/hexiaolong2009/category_10838100.html">何小龙的 DMA-BUF 系列文章</a></li>
<li><a href="http://www.wowotech.net/memory_management/DMA-Mapping-api.html">Dynamic DMA Mapping Guide</a></li>
<li><a href="http://www.wowotech.net/memory_management/scatterlist.html">Linux kernel scatterlist API 介绍</a></li>
<li><a href="https://kernelnote.com/deep-dive-iommu-hardware-driver.html">深入理解 iommu 系列一：iommu 硬件架构和驱动初始化</a></li>
<li><a href="https://zamundaaa.github.io/wayland/2024/04/05/explicit-sync.html">Explicit sync</a></li>
<li><a href="https://www.collabora.com/news-and-blog/blog/2022/06/09/bridging-the-synchronization-gap-on-linux/">Bridging the synchronization gap on Linux</a></li>
<li><a href="https://royhunter.github.io/2016/03/13/kvm-mmu-virtualization/">KVM 之内存虚拟化</a></li>
<li><a href="https://lwn.net/Articles/997563/">Dancing the DMA two-step</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>DRM Device</title>
    <url>/lnx/drm-device/</url>
    <content><![CDATA[<h1 id="drm-introduction"><a class="markdownIt-Anchor" href="#drm-introduction"></a> DRM Introduction</h1>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager">Direct Rendering Manager</a>是Linux kernel中负责与GPU接口的子系统，但它不仅仅用在Linux, 它也会用在像<a href="https://zh.wikipedia.org/zh-cn/OpenBSD">OpenBSD</a>的其它一些类UNIX系统。</p>
<span id="more"></span>
<h1 id="drm-device-nodes"><a class="markdownIt-Anchor" href="#drm-device-nodes"></a> DRM Device Nodes</h1>
<p>DRM Device node 有 3 种</p>
<ul>
<li>primary (cardn), 如 <code>/dev/dri/card0</code></li>
<li>renderDn, 如 <code>/dev/dri/renderD128</code></li>
<li>controlDn, 如 <code>/dev/dri/controlD0</code></li>
</ul>
<p>在各种 UMD 和 Compositor 的实现中使用比较多的是 cardn 和 renderDn 节点， 两者的主要区别在于文件权限，访问 cardn 需要 root 权限，cardn 是 Linux DRM 历史遗留产物，在现代图形应用中， 一般推荐使用 renderDn 节点。 比如 Xorg 使用的就是 cardn 节点。</p>
<p>关于 primary 节点，需要了解:</p>
<ul>
<li>无论它是低端的显示卡，还是 SoC，或像 Intel/AMD/NVIDIA 那些桌面 GPU, 只要注册一个 DRM 设备就都会默认有 primary 节点 <code>/dev/dri/card123</code></li>
<li>primary 节点和 render 节点的主要区别在<strong>权限</strong>， 操作 (open, ioctl) primary 节点需要 root 权限， 而 render 节点不需要</li>
<li>primary 节点和 render 节点底层可以是同一个物理设备，也可以是不同的物理设备，比如在一个使用 Mali GPU IP 和 MTK display controller IP 的 MTK SoC 上， MTK 设备只有显示能力 (<code>/dev/dri/card0</code>), 而 Mali 设备只有渲染能力，但它同时会有 primary 节点 (<code>/dev/dri/card1</code>) 和 render 节点 (<code>/dev/dri/renderD128</code>).</li>
<li>render 节点是专门用来执行非全局的渲染命令的（那些全局的 modeset 命令是通过 primary 节点执行的)，如果一个驱动不支持 render 节点，那么它只能通过 primary 节点和 <code>drmAuth</code> 功能一起完成渲染任务。</li>
</ul>
<h2 id="major-number"><a class="markdownIt-Anchor" href="#major-number"></a> Major Number</h2>
<p>DRM设备的主设备号在不同的系统上不同。</p>
<table>
<thead>
<tr>
<th style="text-align:left">OS</th>
<th style="text-align:left">Major Number</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DragonFlyBSD</td>
<td style="text-align:left">145</td>
</tr>
<tr>
<td style="text-align:left">NetBSD</td>
<td style="text-align:left">34</td>
</tr>
<tr>
<td style="text-align:left">OpenBSD</td>
<td style="text-align:left">88/87</td>
</tr>
<tr>
<td style="text-align:left">Linux</td>
<td style="text-align:left">226</td>
</tr>
</tbody>
</table>
<h2 id="minor-number"><a class="markdownIt-Anchor" href="#minor-number"></a> Minor Number</h2>
<p>每种类型的DRM设备都有一个<strong>Base Minor</strong>, 每种类型允许的子设备号个数是<code>64</code> 个. 所以，Linux下最大的DRM Render Node设备文件名是<code>/dev/dri/renderD191</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r = idr_alloc(&amp;drm_minors_idr,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	<span class="number">64</span> * type,</span><br><span class="line">	<span class="number">64</span> * (type + <span class="number">1</span>),</span><br><span class="line">	GFP_NOWAIT);</span><br></pre></td></tr></table></figure>
<img src="/lnx/drm-device/drm-minor.png" class="">
<h2 id="name-convention"><a class="markdownIt-Anchor" href="#name-convention"></a> Name Convention</h2>
<p>DRM设备在文件系统中的文件名规则在不同的系统上不同。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">OpenBSD</th>
<th style="text-align:left">Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DIR_NAME</td>
<td style="text-align:left"><code>/dev</code></td>
<td style="text-align:left"><code>/dev/dri</code></td>
</tr>
<tr>
<td style="text-align:left">PRIMARY_MINOR_NAME</td>
<td style="text-align:left"><code>drm</code></td>
<td style="text-align:left"><code>card</code></td>
</tr>
<tr>
<td style="text-align:left">CONTROL_MINOR_NAME</td>
<td style="text-align:left"><code>drmC</code></td>
<td style="text-align:left"><code>controlD</code></td>
</tr>
<tr>
<td style="text-align:left">RENDER_MINOR_NAME</td>
<td style="text-align:left"><code>drmR</code></td>
<td style="text-align:left"><code>renderD</code></td>
</tr>
</tbody>
</table>
<ol>
<li><a href="https://cgit.freedesktop.org/~airlied/linux/commit/?h=drm-next&amp;id=1793126fcebd7c18834f95d43b55e387a8803aa8">drm: implement experimental render nodes</a></li>
</ol>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Direct Rendering Management</title>
    <url>/lnx/drm-driver/</url>
    <content><![CDATA[<h1 id="drm-driver-features"><a class="markdownIt-Anchor" href="#drm-driver-features"></a> DRM driver features</h1>
<h2 id="新drm驱动的特性"><a class="markdownIt-Anchor" href="#新drm驱动的特性"></a> 新DRM驱动的特性</h2>
<ul>
<li>DRIVER_GEM</li>
</ul>
<p>使用<strong>GEM</strong>内存管理器，所有新的驱动都应该支持。</p>
<ul>
<li>DRIVER_MODESET</li>
</ul>
<p>支持<strong>Kernel Modesetting Interfaces</strong></p>
<ul>
<li>DRIVER_RENDER</li>
</ul>
<p>支持专门的渲染节点， 即**/dev/dri/renderD**</p>
<ul>
<li>DRIVER_ATOMIC</li>
</ul>
<p>支持所有的<strong>Atomic Modesetting</strong>用户空间API</p>
<ul>
<li>DRIVER_SYNCOBJ</li>
</ul>
<p>支持<strong>drm_syncobj</strong>, 用于渲染命令提交的显式同步。</p>
<ul>
<li>DRIVER_SYNCOBJ_TIMELINE</li>
</ul>
<p>支持<strong>drm_syncobj</strong>的<strong>timeline</strong>特性</p>
<h2 id="旧drm驱动的特性"><a class="markdownIt-Anchor" href="#旧drm驱动的特性"></a> 旧DRM驱动的特性</h2>
<ul>
<li>DRIVER_USE_AGP</li>
<li>DRIVER_LEGACY</li>
<li>DRIVER_PCI_DMA</li>
<li>DRIVER_SG</li>
<li>DRIVER_HAVE_DMA</li>
<li>DRIVER_HAVE_IRQ</li>
<li>DRIVER_KMS_LEGACY_CONTEXT</li>
</ul>
<h1 id="内核-drm-子系统是如何维护的"><a class="markdownIt-Anchor" href="#内核-drm-子系统是如何维护的"></a> 内核 DRM 子系统是如何维护的</h1>
<p>内核 DRM 子系统的代码仓库托管在cgit上，<a href="https://cgit.freedesktop.org/drm/drm">Upstream DRM Subsystem Repository</a>, 这个仓库最主要的两个分支</p>
<ul>
<li>
<p>drm-next</p>
<p>这个分支的补丁包括 DRM 核心和所有 GPU 驱动的新特性</p>
</li>
<li>
<p>drm-fixes</p>
</li>
</ul>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://docs.kernel.org/gpu/index.html">GPU Driver Developer’s Guide</a></li>
<li><a href="https://drm.pages.freedesktop.org/maintainer-tools/repositories.html">DRM Maintainer Tools</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>DRM format modifier</title>
    <url>/lnx/drm-mod/</url>
    <content><![CDATA[<h1 id="fourcc"><a class="markdownIt-Anchor" href="#fourcc"></a> FourCC</h1>
<p>FourCC format code是Linux内核DRM子系统用来描述framebuffer像素格式。它们被定义在内核源码<a href="https://github.com/torvalds/linux/blob/master/include/uapi/drm/drm_fourcc.h#L156">include/uapi/drm/drm_fourcc.h</a>. 基本上FourCC format code足以描述framebuffer中像素的内容了，但是随着GPU的更新，原来线性排列的buffers，为了获取更好的性能，可能会采取vendor specific的布局方式。另外，这些buffer也可能保存的是各种不同的压缩数据，这样一来，原来的FourCC format code就无法携带新的buffer<br />
layout或compression format的信息，DRM format modifier就是用来解决这些问题的。</p>
<span id="more"></span>
<h1 id="modifier"><a class="markdownIt-Anchor" href="#modifier"></a> Modifier</h1>
<h1 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h1>
<h2 id="drm_format_mod_arm_16x16_block_u_interleaved"><a class="markdownIt-Anchor" href="#drm_format_mod_arm_16x16_block_u_interleaved"></a> <a href="https://elixir.bootlin.com/mesa/latest/source/include/drm-uapi/drm_fourcc.h#L1332">DRM_FORMAT_MOD_ARM_16X16_BLOCK_U_INTERLEAVED</a></h2>
<h3 id="how-u-interleaved-improves-performance"><a class="markdownIt-Anchor" href="#how-u-interleaved-improves-performance"></a> How U-interleaved improves performance?</h3>
<p><img src="/images/drm-mod/u-interleaved.drawio.svg" alt="U-interleaved memory layout" /></p>
<p>这种交错 (interleave) 方式类似 <a href="https://en.wikipedia.org/wiki/Z-order_curve">Morton order(Z-order)</a>, Morton order 是一种将<strong>多维数据映射到一维</strong>的函数, 同时<strong>保留数据点的位置特征</strong>， 也就是说在<strong>多维时离得近的数据点在一维时也离得近</strong>。</p>
<p><img src="/images/drm-mod/Z-curve45.svg.png" alt="four iterations of Z-order curve" /></p>
<h3 id="what-is-the-block-size"><a class="markdownIt-Anchor" href="#what-is-the-block-size"></a> What is the block size?</h3>
<p>对于 U-interleaved 布局的纹理, 有两种可能的 block size:</p>
<ul>
<li>4x4 (压缩格式)</li>
<li>16x16 (非压缩格式)</li>
</ul>
<h3 id="what-is-the-row-stride"><a class="markdownIt-Anchor" href="#what-is-the-row-stride"></a> What is the row stride?</h3>
<p>row stride 通常指纹理图片中相邻两行之间的字节数。对于 Linear 布局的纹理, block size 是 1x1, 它的 row stride 即为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>o</mi><mi>w</mi><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>=</mo><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>P</mi><mi>e</mi><mi>r</mi><mi>P</mi><mi>i</mi><mi>x</mi><mi>e</mi><mi>l</mi><mo>∗</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">RowStride = BytesPerPixel * Width 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span></span></p>
<p>这也是所谓的逻辑 row stride, 而对于 U-interleaved 布局的纹理，由于它在内存中是按块存储的（块与块之间是线性的），所以 U-interleaved 布局的纹理的 row stride 已经不是通常意义的“行”了，而是由<strong>块</strong>组成的<strong>行</strong>。所以 U-interleaved 布局的纹理的 row stride 为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>o</mi><mi>w</mi><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>=</mo><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>P</mi><mi>e</mi><mi>r</mi><mi>B</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mo>∗</mo><mi>n</mi><mi>B</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>s</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">RowStride = BytesPerBlock * nBlocksX 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></span></p>
<h4 id="非压缩格式的-u-interleaved-布局的-row-stride"><a class="markdownIt-Anchor" href="#非压缩格式的-u-interleaved-布局的-row-stride"></a> 非压缩格式的 U-interleaved 布局的 row stride</h4>
<p><img src="/images/drm-mod/u-interleaved-row-stride-non-compress.drawio.svg" alt="U-interleaved row stride in regular format" /></p>
<h4 id="压缩格式的-u-interleaved-布局的-row-stride"><a class="markdownIt-Anchor" href="#压缩格式的-u-interleaved-布局的-row-stride"></a> 压缩格式的 U-interleaved 布局的 row stride</h4>
<p>以 <a href="https://sv-journal.org/2014-1/06/en/index.php?lang=en#5">BC1 压缩格式</a>为例, BC1 是 S3TC 家族的一员(所有的 S3TC 家族都使用 4x4 的块大小)，而 DRM_FORMAT_MOD_ARM_16X16_BLOCK_U_INTERLEAVED 是 16x16 大小的，所以一个 U-interleaved 块中包含 4x4 个 BC1 压缩块。</p>
<p><img src="/images/drm-mod/u-interleaved-row-stride-compress.drawio.svg" alt="U-interleaved row stride in BC1 compression format" /></p>
<h1 id="modifier-negotiation"><a class="markdownIt-Anchor" href="#modifier-negotiation"></a> Modifier Negotiation</h1>
<h2 id="on-x11"><a class="markdownIt-Anchor" href="#on-x11"></a> On X11</h2>
<p>在 DRI3 扩展里， 因为 render buffer 是由驱动(应用)创建后导出给 X11 的， 所以在驱动创建 buffer 前，需要向 X11 查询现在支持哪些 modifiers, 驱动根据查询到的支持的 modifiers 再去创建 buffer (BO, 也即 resource)。</p>
<pre><code class="highlight mermaid">sequenceDiagram
  participant Mesa
  participant X11
  participant Glamor
  participant DDX
  participant Kernel

  Mesa -&gt;&gt; X11: xcb_dri3_get_supported_modifiers()
  Mesa -&gt;&gt; X11: xcb_dri3_get_supported_modifiers_reply()
  Kernel -&gt;&gt; DDX: drmModeGetPropertyBlob()
  DDX -&gt;&gt; Glamor: get_modifiers_set()
  Glamor -&gt;&gt; X11: glamor_get_drawable_modifiers()
  alt num_window_modifiers
    X11 -&gt;&gt; Mesa: xcb_dri3_get_supported_modifiers_window_modifiers()
  else num_screen_modifiers
    X11 -&gt;&gt; Mesa: xcb_dri3_get_supported_modifiers_screen_modifiers()
  end</code></pre>
<p><strong>modifiers</strong> 集是提前存储在一个 DDX 内部的数据结构中的，例如 xserver 的 <strong>modesetting</strong>，是保存在 <code>drmmode_format_rec</code> 结构体中的(当然它是一组)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> format;</span><br><span class="line">    <span class="type">uint32_t</span> num_modifiers;</span><br><span class="line">    <span class="type">uint64_t</span> *modifiers;</span><br><span class="line">&#125; drmmode_format_rec, *drmmode_format_ptr;</span><br></pre></td></tr></table></figure>
<h2 id="on-xwayland"><a class="markdownIt-Anchor" href="#on-xwayland"></a> On XWayland</h2>
<h1 id="tool-drm_info"><a class="markdownIt-Anchor" href="#tool-drm_info"></a> Tool - <a href="https://gitlab.freedesktop.org/emersion/drm_info">drm_info</a></h1>
<p><strong>drm_info</strong> 可以列举出所有 KMS 支持的 scanout modifiers (<a href="https://pastebin.com/dwhfdVDf">https://pastebin.com/dwhfdVDf</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├───Plane 1</span><br><span class="line">│   ├───Object ID: 44</span><br><span class="line">│   ├───CRTCs: &#123;0&#125;</span><br><span class="line">│   ├───Legacy info</span><br><span class="line">│   │   ├───FB ID: 0</span><br><span class="line">│   │   └───Formats:</span><br><span class="line">│   │       ├───YUYV (0x56595559)</span><br><span class="line">│   │       ├───UYVY (0x59565955)</span><br><span class="line">│   │       ├───XRGB8888 (0x34325258)</span><br><span class="line">│   │       ├───XRGB1555 (0x35315258)</span><br><span class="line">│   │       ├───XBGR2101010 (0x30334258)</span><br><span class="line">│   │       ├───XRGB2101010 (0x30335258)</span><br><span class="line">│   │       └───XBGR16161616F (0x48344258)</span><br><span class="line">│   └───Properties</span><br><span class="line">│       ├───&quot;type&quot; (immutable): enum &#123;Overlay, Primary, Cursor&#125; = Overlay</span><br><span class="line">│       ├───&quot;IN_FORMATS&quot; (immutable): blob = 45</span><br><span class="line">│       │   ├───NVIDIA_BLOCK_LINEAR_2D(h=0, k=254, g=0, s=1, c=0) (0x03000000004fe010)</span><br><span class="line">│       │   │   ├───YUYV (0x56595559)</span><br><span class="line">│       │   │   ├───UYVY (0x59565955)</span><br><span class="line">│       │   │   ├───XRGB8888 (0x34325258)</span><br><span class="line">│       │   │   ├───XRGB1555 (0x35315258)</span><br><span class="line">│       │   │   ├───XBGR2101010 (0x30334258)</span><br><span class="line">│       │   │   ├───XRGB2101010 (0x30335258)</span><br><span class="line">│       │   │   └───XBGR16161616F (0x48344258)</span><br><span class="line">│       │   ├───NVIDIA_BLOCK_LINEAR_2D(h=1, k=254, g=0, s=1, c=0) (0x03000000004fe011)</span><br></pre></td></tr></table></figure>
<h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1>
<ul>
<li><a href="https://www.collabora.com/news-and-blog/news-and-events/implementing-drm-format-modifiers-in-nvk.html">Implementing DRM format modifiers in NVK</a></li>
<li><a href="https://wayland.app/protocols/linux-dmabuf-v1">Linux DMA-BUF</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU Firmware</title>
    <url>/lnx/fw/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UVD feature version: 0, firmware version: 0x40000d00</span><br><span class="line">MC feature version: 0, firmware version: 0x00a777d0</span><br><span class="line">ME feature version: 29, firmware version: 0x00000091</span><br><span class="line">PFP feature version: 29, firmware version: 0x00000054</span><br><span class="line">CE feature version: 29, firmware version: 0x0000003d</span><br><span class="line">RLC feature version: 1, firmware version: 0x00000001</span><br><span class="line">SMC feature version: 0, program: 16, firmware version: 0x10020000 (2.0.0)</span><br><span class="line">VBIOS version: 113-xxx-xxx</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>现代 GPU/NPU 芯片里一般都会搭载多个微处理器(或微控制器)， 像 Intel <a href="https://docs.kernel.org/gpu/i915.html#guc">GuC</a> (uC 指 µC, micro controller), AMD <a href="https://docs.kernel.org/gpu/amdgpu/driver-core.html#graphics-and-compute-microcontrollers">MEC</a>(MicroEngine Compute), NVIDIA <a href="https://download.nvidia.com/XFree86/Linux-x86_64/510.39.01/README/gsp.html">GSP</a> (GPU System Processor)。跑在这些微控制器上的代码一般以<strong>固件(Firmware)</strong> 的形式存在，即使是在 Linux 内核里也是二进制格式，源代码一般是不公开的，Linux 社区有一个专门的 git tree <a href="https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/tree/"><em>linux-firmware</em></a> 来维护各种硬件的固件二进制文件，而这些 bin 文件在 Linux 系统中会存储在文件系统， 路径一般是 <code>/lib/firmware/</code>。</p>
<p>例如，在一个 5.4.18-85-generic 的 Linux 发行版系统中， amdgpu 和 radeon 的 gpu ip 固件 bin 文件就分别有 <strong>469</strong>, <strong>247</strong> 个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> amdgpu radeon; <span class="keyword">do</span> <span class="built_in">ls</span> /lib/firmware/<span class="variable">$dir</span> | <span class="built_in">wc</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>而且 KMD 也提供 sys 文件系统接口允许用户查看固件信息 (需要 root 权限)， 例如，在 AMD R7340 显卡机器上输出本文开头的固件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/dri/0/amdgpu_firmware_info | grep -v <span class="string">&#x27;firmware version: 0x00000000&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>firmware</tag>
      </tags>
  </entry>
  <entry>
    <title>drm_gpu_scheduler</title>
    <url>/lnx/gpu-sched/</url>
    <content><![CDATA[<pre><code class="highlight mermaid">flowchart TD
  subgraph GPU
    slot-0[HW Run Queue]
    slot-1[HW Run Queue]
    slot-2[HW Run Queue]
  end

  sched0[drm_gpu_scheduler]
  sched1[drm_gpu_scheduler]
  sched2[drm_gpu_scheduler]

  runq00[drm_sched_rq&lt;br&gt;KERNEL]
  runq01[drm_sched_rq&lt;br&gt;HIGH]
  runq02[drm_sched_rq&lt;br&gt;NORMAL]
  runq03[drm_sched_rq&lt;br&gt;LOW]

  runq10[drm_sched_rq&lt;br&gt;KERNEL]
  runq11[drm_sched_rq&lt;br&gt;HIGH]

  runq20[drm_sched_rq&lt;br&gt;KERNEL]
  runq21[drm_sched_rq&lt;br&gt;HIGH]
  runq22[drm_sched_rq&lt;br&gt;NORMAL]

  entity00@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity01@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity02@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity03@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;

  entity10@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity11@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity12@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;


  entity20@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity21@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity22@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;

  entity00 --&gt; entity01 --&gt; entity02 --&gt; entity03 --&gt; runq00
  entity10 --&gt; entity11 --&gt; entity12 --&gt; runq10
  entity20 --&gt; entity21 --&gt; entity22 --&gt; runq02

  runq00 --&gt; sched0
  runq01 --&gt; sched0
  runq02 --&gt; sched0
  runq03 --&gt; sched0

  runq10 --&gt; sched1
  runq11 --&gt; sched1

  runq20 --&gt; sched2
  runq21 --&gt; sched2
  runq22 --&gt; sched2

  sched0 --&gt; slot-0
  sched1 --&gt; slot-1
  sched2 --&gt; slot-2</code></pre>
<span id="more"></span>
<p>Notes:</p>
<ul>
<li>每个 hw run queue (hw ring) 对应一个 <a href="https://elixir.bootlin.com/linux/v6.13.4/source/drivers/gpu/drm/panfrost/panfrost_job.c#L36">drm_gpu_scheduler</a></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">DRIVER</th>
<th style="text-align:left">MAX_HW_RINGS</th>
<th style="text-align:left">VALUE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">amdgpu</td>
<td style="text-align:left">AMDGPU_MAX_RINGS</td>
<td style="text-align:left">124</td>
</tr>
<tr>
<td style="text-align:left">etnaviv</td>
<td style="text-align:left">ETNA_MAX_PIPES</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">powervr</td>
<td style="text-align:left"></td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">panfrost</td>
<td style="text-align:left">NUM_JOB_SLOTS</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">v3d</td>
<td style="text-align:left">V3D_MAX_QUEUES</td>
<td style="text-align:left">6</td>
</tr>
</tbody>
</table>
<ul>
<li>每个 scheduler 对应多个不同优先级(<code>enum drm_sched_priority</code>)的 scheduler run queue (sw run queue)</li>
</ul>
<p>但似乎对于未来的硬件，尤其那些通过 FW/HW 调度 job 的 GPU, 更希望的拓扑结构是 <a href="https://patchwork.freedesktop.org/patch/567300/">scheduler : run queue : entity 是 1:1:1</a>. 这样的 <code>drm_gpu_scheduler</code> 已经退化成一个 <strong>dependency tracker/resolver</strong>, 没有了实质的<s>调度</s>的作用。</p>
<pre><code class="highlight mermaid">flowchart TD
  subgraph GPU
    GuC[FW/HW scheduler]
    slot-0[HW Run Queue]
    slot-1[HW Run Queue]
    slot-2[HW Run Queue]
  end

  sched0[drm_gpu_scheduler]
  sched1[drm_gpu_scheduler]
  sched2[drm_gpu_scheduler]

  runq00[drm_sched_rq&lt;br&gt;KERNEL]
  runq10[drm_sched_rq&lt;br&gt;KERNEL]
  runq20[drm_sched_rq&lt;br&gt;KERNEL]

  entity00@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity10@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity20@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;

  entity00 --&gt; runq00 --&gt; sched0 --&gt; GuC --&gt; slot-0
  entity10 --&gt; runq10 --&gt; sched1 --&gt; GuC --&gt; slot-1
  entity20 --&gt; runq20 --&gt; sched2 --&gt; GuC --&gt; slot-2</code></pre>
<ul>
<li>每个 scheduler run queue 是一个将被调度的 entity 队列</li>
<li><code>drm_sched_entity.sched_list</code>, 一个 entity 上的 jobs 可以被调度到这个 <strong>sched_list</strong> 上的任意一个 scheduler 上, 实现这个过程是通过 <a href="https://elixir.bootlin.com/linux/v6.13.5/source/drivers/gpu/drm/scheduler/sched_entity.c#L539"><code>drm_sched_entity_select_rq()</code></a> 完成的。</li>
</ul>
<pre><code class="highlight mermaid">flowchart TD
  subgraph GPU
    slot-0[HW Run Queue]
    slot-1[HW Run Queue]
    slot-2[HW Run Queue]
  end

  sched0[drm_gpu_scheduler]
  sched1[drm_gpu_scheduler]
  sched2[drm_gpu_scheduler]

  runq00[drm_sched_rq&lt;br&gt;KERNEL]
  runq10[drm_sched_rq&lt;br&gt;KERNEL]
  runq20[drm_sched_rq&lt;br&gt;KERNEL]

  entity00@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity10@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;
  entity20@&#123;shape: docs, label: &quot;drm_sched_entity&lt;br&gt;job chain&quot;&#125;

  entity00 --&gt; runq00 --&gt; sched0 --&gt; slot-0
  entity00 -.-&gt; runq10
  entity10 --&gt; runq10 --&gt; sched1 --&gt; slot-1
  entity10 -.-&gt; runq00
  entity20 --&gt; runq20 --&gt; sched2 --&gt; slot-2</code></pre>
<ul>
<li>每个 entity 由包含若干个 gpu job 的链表组成</li>
</ul>
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<p>Linux DRM 子系统的 <code>drm_gpu_scheduler</code> 负责提交和调度 GPU job，以一个单独的内核模块(<code>gpu-sched</code>) 的形式存在。</p>
<h2 id="drm_gpu_scheduler"><a class="markdownIt-Anchor" href="#drm_gpu_scheduler"></a> <code>drm_gpu_scheduler</code></h2>
<p>调度器实例 (instance)，运行时实际上是一个内核线程 (kthread), 这个线程启动是在 <code>drm_sched_init()</code>。</p>
<p>实际上，自从内核 v6.8-rc1 <a href="https://lore.kernel.org/all/20231031032439.1558703-3-matthew.brost@intel.com/">a6149f039369 (“drm/sched: Convert drm scheduler to use a work queue rather than kthread”)</a> <code>drm_gpu_scheduler</code> 的实现已经从 kthread 变成 work queue 了。 这个修改与 Intel Gen9+ 引入的 microcontrollers (μC) 之一 <a href="https://igor-blue.github.io/2021/02/10/graphics-part1.html#the-guc">GuC</a> 有关。</p>
<h2 id="drm_sched_backend_ops"><a class="markdownIt-Anchor" href="#drm_sched_backend_ops"></a> <code>drm_sched_backend_ops</code></h2>
<p>这个结构体定义一组回调函数，一般需要驱动实现， 并在 <code>drm_sched_init()</code> 时传入。</p>
<ul>
<li>struct dma_fence *(*prepare_job)(struct drm_sched_job *job, struct drm_sched_entity *ent);</li>
</ul>
<ul>
<li><code>struct dma_fence *(*run_job)(struct drm_sched_job *job);</code></li>
</ul>
<ul>
<li>enum drm_gpu_sched_stat (*timedout_job)(struct drm_sched_job *job);</li>
</ul>
<ul>
<li><code>void (*free_job)(struct drm_sched_job *job);</code></li>
</ul>
<ul>
<li>void (*cancel_job)(struct drm_sched_job *job);</li>
</ul>
<p><strong>NOTE:</strong></p>
<ul>
<li>run_job() 和 free_job() 驱动必须实现</li>
<li>这两个函数是由 kworker 异步执行的, 也就是在两个 CPU 核心上同时执行，就有发生<strong>死锁</strong>的可能。</li>
</ul>
<h2 id="drm_sched_rq"><a class="markdownIt-Anchor" href="#drm_sched_rq"></a> <code>drm_sched_rq</code></h2>
<p>若干个 <code>drm_sched_entity</code> (list) 的封装。一个 scheduler 实例最多可以有 <code>DRM_SCHED_PRIORITY_COUNT</code> 个 <code>drm_sched_rq</code>。调度器调度的其实就是一个个 entity。 这么多个 entity 按什么顺序提交给 GPU 由具体的 <strong>调度策略 (Scheduling Policy)</strong> 决定，而<strong>调度优先级 (Scheduling Priority)</strong> 由 <code>drm_sched_rq</code> 实现，有多少个优先级，一个 <code>drm_gpu_scheduler</code> 里就有多少个 <code>drm_sched_rq</code>，每个优先级对应一个 <code>drm_sched_rq</code>。</p>
<h2 id="drm_sched_entity"><a class="markdownIt-Anchor" href="#drm_sched_entity"></a> <code>drm_sched_entity</code></h2>
<p>若干个 <code>drm_sched_job</code> (list) 的封装</p>
<h2 id="drm_sched_job"><a class="markdownIt-Anchor" href="#drm_sched_job"></a> <code>drm_sched_job</code></h2>
<p>被 entity 运行的一个 job, 一个 job 总是属于某一个 entity</p>
<h2 id="drm_sched_fence"><a class="markdownIt-Anchor" href="#drm_sched_fence"></a> <a href="https://elixir.bootlin.com/linux/v6.13.5/source/include/drm/gpu_scheduler.h#L267"><code>drm_sched_fence</code></a></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drm_sched_fence</span> &#123;</span></span><br><span class="line">  <span class="comment">// job 一旦被调度了，就 signal 这个 fence</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dma_fence</span> <span class="title">scheduled</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// job 被硬件完成了， 就 signal 这个 fence</span></span><br><span class="line">  <span class="comment">// 当一个 job 完成时，硬件一般会上报一个中断 interrupt</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dma_fence</span> <span class="title">finished</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">ktime_t</span> deadline;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由驱动提供的 run_job() 回调函数返回的 fence,</span></span><br><span class="line">  <span class="comment">// 硬件上 finished/done 中断后，会先 signal 这个 fence</span></span><br><span class="line">  <span class="comment">// scheduler signal @scheduled fence 时，会将 sched-&gt;ops-&gt;run_job() 的</span></span><br><span class="line">  <span class="comment">// 返回值赋给 parent</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dma_fence</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">drm_gpu_scheduler</span> *<span class="title">sched</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">void</span> *owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="gpu-scheduler-中的关键组件"><a class="markdownIt-Anchor" href="#gpu-scheduler-中的关键组件"></a> GPU Scheduler 中的关键组件</h1>
<ul>
<li>Entity</li>
<li>Workqueue</li>
</ul>
<h2 id="drm_sched-初始化"><a class="markdownIt-Anchor" href="#drm_sched-初始化"></a> drm_sched 初始化</h2>
<ul>
<li>v6.8</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">drm_sched_init</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> drm_gpu_scheduler *sched,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 需要由驱动实现的一组回调函数, 有</span></span></span><br><span class="line"><span class="params">  <span class="comment">// prepare_job(), run_job(), timedout_job(), free_job()</span></span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> drm_sched_backend_ops *ops,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 一个 workqueue(6.8 之前是 kthread) 用来向 hw run queue 提交 job</span></span></span><br><span class="line"><span class="params">  <span class="comment">// 如果驱动没有提供，默认是一个 ordered workqueue</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> workqueue_struct *submit_wq, </span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 这个 sched 下的 drm_sched_rq 的个数，最多 4 个，分别对应</span></span></span><br><span class="line"><span class="params">  <span class="comment">// LOW, NORMAL, HIGH, KERNEL 4 个优先级</span></span></span><br><span class="line"><span class="params">  u32 num_rqs,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 用来 job flow control, sched 最多能提交多少个 job(chain) 给 hw,</span></span></span><br><span class="line"><span class="params">  <span class="comment">// 防止 ring buffer overflow</span></span></span><br><span class="line"><span class="params">  <span class="comment">// 这里的每个job 的概念因不同 GPU 而异</span></span></span><br><span class="line"><span class="params">  u32 credit_limit,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 允许一个 job 在被丢弃前 hang 多少次</span></span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">int</span> hang_limit,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// job 超时时长 (jiffies)</span></span></span><br><span class="line"><span class="params">  <span class="type">long</span> timeout,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 另外一个 workqueue 用来执行超时之后的逻辑。驱动可以不指定，</span></span></span><br><span class="line"><span class="params">  <span class="comment">// 默认是 system_wq (让这个 workqueue 执行的任务不要太长)</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> workqueue_struct *timeout_wq,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="type">atomic_t</span> *score, <span class="comment">// 与其它 sched 共享的原子整型的 score</span></span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> *name, <span class="comment">// 用来调试</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> device *dev <span class="comment">// 所属 struct device</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">drm_sched_entity_init</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> drm_sched_entity *entity,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 一个 priority 对应一个 run queue</span></span></span><br><span class="line"><span class="params">  <span class="keyword">enum</span> drm_sched_priority priority,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 这个 entity 上的 jobs 可以在这组 schedulers 中的任意一个 scheduler 上调度</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> drm_gpu_scheduler **sched_list,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">int</span> num_sched_list,</span></span><br><span class="line"><span class="params">  <span class="type">atomic_t</span> *guilty</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">- v5<span class="number">.4</span></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">drm_sched_init</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> drm_gpu_scheduler *sched,</span></span><br><span class="line"><span class="params">  <span class="comment">// 需要由驱动实现的一组回调函数，有</span></span></span><br><span class="line"><span class="params">  <span class="comment">// dependency(), run_job(), timedout_job(), free_job()</span></span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> drm_sched_backend_ops *ops,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> hw_submission, <span class="comment">// 允许有多少个 hw 提交同时存在</span></span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> hang_limit, <span class="comment">// 允许一个 job 在被丢弃前 hang 多少次</span></span></span><br><span class="line"><span class="params">  <span class="type">long</span> timeout, <span class="comment">// job 超时时长 (jiffies)</span></span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> *name <span class="comment">// 用来调试</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>5.4 没有让驱动提供一个 timeout_wq, 而是固定使用 delayable workqueue 去执行 <a href="https://elixir.bootlin.com/linux/v5.19.17/source/drivers/gpu/drm/scheduler/sched_main.c#L1016">drm_sched_job_timedout()</a></li>
<li>参数中的 <code>timeout</code> 是以 jiffies 计算的，如果设置成 <code>MAX_SCHEDULE_TIMEOUT</code>， 表示由驱动自己处理超时</li>
</ul>
<h2 id="entity-gpu-job-的容器"><a class="markdownIt-Anchor" href="#entity-gpu-job-的容器"></a> Entity - GPU job 的容器</h2>
<pre><code class="highlight mermaid">sequenceDiagram
  participant Driver
  participant Scheduler
  participant Kworker

  Driver -&gt;&gt; Scheduler : drm_sched_job_init()
  Driver -&gt;&gt; Scheduler : drm_sched_job_arm(job)
  note right of Scheduler : 给定一个优先级，那么 runqueue 也就确定了&lt;br&gt;那么 sched 实例也就确定了,&lt;br&gt;那么在哪个硬件 slot 上执行也就确定了
  Scheduler -&gt;&gt; Scheduler : drm_sched_entity_select_rq(entity)
  note right of Driver : 一旦把 job push 到 entity queue,&lt;br&gt;这个 job 就可能在任何时间点完成被释放，&lt;br&gt;所以在这个时间点后，&lt;br&gt;驱动就不能再读写 job 的任何字段
  Driver -&gt;&gt; Scheduler : drm_sched_entity_push_job(job)
  Scheduler -&gt;&gt; Scheduler : drm_sched_rq_add_entity(rq, entity)
  opt DRM_SCHED_POLICY_FIFO
    Scheduler -&gt;&gt; Scheduler : drm_sched_rq_update_fifo_locked(entity, rq, submit_timestamp)
  end
  note right of Scheduler : 唤醒 sched kworker 线程&lt;br&gt;queue_work(submit_wq, &amp;work_run_job)
  Scheduler -&gt;&gt; Kworker : drm_sched_wakup()
  rect rgb(200, 150, 255)
    note left of Kworker : drm_sched_run_job_work()
    Kworker -&gt;&gt; Kworker : drm_sched_select_entity(sched)
    Kworker -&gt;&gt; Kworker : drm_sched_entity_pop_job(entity)
    Kworker -&gt;&gt; Kworker : sched-&gt;ops-&gt;run_job()
    Kworker -&gt;&gt; Kworker : complete_all(entity-&gt;idle)
    Kworker -&gt;&gt; Kworker : drm_sched_fence_scheduled(s_fence, fence)
    Kworker -&gt;&gt; Kworker : drm_sched_job_done(job, result)
    Kworker -&gt;&gt; Kworker : wake_up(&amp;sched-&gt;job_scheduled)
    note right of Kworker : 再次唤醒 sched kwoker 线程&lt;br&gt;queue_work(submit_wq, &amp;work_run_job)
    Kworker -&gt;&gt; Kworker : drm_sched_run_job_queue()
  end</code></pre>
<h2 id="workqueue-任务异步执行"><a class="markdownIt-Anchor" href="#workqueue-任务异步执行"></a> Workqueue - 任务异步执行</h2>
<p>一个 <code>drm_gpu_scheduler</code> 里包括两个 workqueues (<a href="https://elixir.bootlin.com/linux/v6.17-rc5/source/kernel/workqueue.c#L335"><code>struct workqueue_struct</code></a>):</p>
<ul>
<li><code>timeout_wq</code></li>
<li><code>submit_wq</code></li>
</ul>
<h1 id="scheduler-如何工作"><a class="markdownIt-Anchor" href="#scheduler-如何工作"></a> Scheduler 如何工作</h1>
<p>Job 提交一般由用户驱动通过 <strong>IOCTL_SUBMIT</strong> 命令触发，将 job 下发给 hw, 所谓下发就是将 64 位的 job(chain) 的起始地址写入 MMIO 寄存器或 ringbuffer, 然后再触发 doorbell, hw 就开始执行</p>
<pre><code class="highlight mermaid">sequenceDiagram
  participant UMD
  participant KMD
  participant Kworker

  KMD -&gt;&gt; KMD : drm_sched_init()
  note right of KMD : 创建一个 work item
  KMD -&gt;&gt; KMD : INIT_WORK(&amp;sched-&gt;work_run_job,&lt;br&gt;drm_sched_run_job_work)
  UMD -&gt;&gt; KMD : ioctl(SUBMIT)
  KMD -&gt;&gt; KMD : drm_sched_job_init()
  KMD -&gt;&gt; KMD : drm_sched_job_arm()
  KMD -&gt;&gt; KMD : drm_sched_entity_push_job()
  KMD -&gt;&gt; KMD : drm_sched_waitup()
  rect rgb(205, 228, 152)
    note left of Kworker : drm_sched_run_job_work&lt;br&gt;即submit_wq 上的 work item&lt;br&gt;每次 queue_work() 入队，&lt;br&gt;执行线程 kworker 都会异步执行这个函数
    note right of Kworker : 根据优先级和调度策略选实体
    Kworker -&gt;&gt; Kworker : drm_sched_select_entity()
    note right of Kworker : 弹出一个 job
    Kworker -&gt;&gt; Kworker : drm_sched_entity_pop_job()
    note right of Kworker : 执行驱动的回调函数
    Kworker -&gt;&gt; Kworker : sched-&gt;ops-&gt;run_job()
    note right of Kworker : 唤醒 drm_sched_entity_flush() 时,&lt;br&gt;被睡眠的那些进程&lt;br&gt;被唤醒的进程重新检测&lt;br&gt;drm_sched_entity_is_idle()&lt;br&gt;如果不idle就继续睡
    Kworker -&gt;&gt; Kworker : wake_up(wait_queue_head_t)
    note right of Kworker : 入队
    Kworker -&gt;&gt; Kworker : drm_sched_run_job_queue()
    note left of Kworker : writel(jc, dev-&gt;iomem + reg)&lt;br&gt;Go!
  end</code></pre>
<p>Note:</p>
<ul>
<li><code>drm_sched_free_job_work()</code> 和 <code>drm_sched_run_job_work()</code> 是分开的两个 work item, 但它俩都会被扔到同一个 workqueue 上 <code>submit_wq</code> (workqueue 的实现很有意思，异步执行的单位是函数 (<code>work_struct</code>)，而这些函数会被加入一个内核工作队列 (<code>workqueue_struct</code>) 里<strong>异步执行</strong> (由 kworker 内核线程执行)，只要队列不为空，后台线程们就把它们拿出来<strong>并发地</strong>执行 (CMWQ). 后台线程是一个由内核自动管理的线程池，唤醒和睡眠不需要使用者干预，使用者(比方 GPU Scheduler)只需要调用 <code>queue_work(&amp;workqueue_struct, &amp;work_struct)</code> 将 work 加到相应的 workqueue 就行了</li>
<li>内核 workqueue API 提供两个 work 入队函数 (enqueue):<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq, <span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>前者是将 workitem 放到用户自定义的 workqueue; 后者是将 workitem 放入一个全局 workqueue <code>system_wq</code>。</li>
<li><code>system_wq</code> 等全局 workqueue 的执行线程 kworker 的命名一般是 <code>kworker/CPU#:POOL#[FLAG]-events</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root          64      64       2  0 Sep02 ?        00:00:00 [kworker/7:0H-events_highpri]</span><br><span class="line">root        3264    3264       2  0 Sep04 ?        00:00:06 [kworker/2:0-events]</span><br></pre></td></tr></table></figure>
</li>
<li>因为 GPU scheduler 的 <code>submit_wq</code> 是一个自定义的 workqueue, 所以它调用的是 <code>queue_work()</code>，而实际上有很多驱动会将一些 workitems 直接放入全局 workqueue <code>system_wq</code></li>
</ul>
</li>
<li><code>drm_sched_&#123;run,free&#125;_job_work()</code> 在哪个 <strong>kworker</strong> 上运行可以<a href="https://www.kernel.org/doc/html/v4.14/core-api/workqueue.html#debugging">通过 debugfs 来查看</a>
<ul>
<li><code>echo workqueue:workqueue_queue_work &gt; /sys/kernel/debug/tracing/set_event</code></li>
<li><code>cat /sys/kernel/debug/tracing/trace_pipe &gt; out.txt</code></li>
</ul>
</li>
<li>如果用户在初始化 <code>drm_gpu_scheduler</code> 时没有传入自己创建的 WQ, 那么内核会默认创建一个 <strong>ordered workqueue</strong> 并将其赋给 <code>drm_gpu_scheduler::submit_wq</code>, ordered workqueue 保证了先入队的函数一定先执行, 通常 <code>drm_sched_run_job_work()</code> 会先入队, 而 <code>drm_sched_free_job_work()</code> 后入队，这也正好符合正常的执行逻辑。</li>
</ul>
<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1>
<ul>
<li><a href="https://patchwork.freedesktop.org/patch/567839/">drm/scheduler: improve GPU scheduler documentation v2</a></li>
<li><a href="https://www.cnblogs.com/yaongtime/p/14305463.html">linux DRM GPU scheduler 笔记</a></li>
<li><a href="https://patchwork.freedesktop.org/patch/297644/">drm/panfrost: Add initial panfrost driver</a></li>
<li><a href="https://pastebin.com/MssJk6Ky">drivers/gpu 下的 <code>drm_sched_backend_ops</code></a></li>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/blob/f8d2b42ae65c2f16f36a43e0ae39d288431e4263/src/imagination/csbgen/rogue_kmd_stream.xml">PowerVR Rogue Command Stream format</a></li>
<li><a href="https://www.cnblogs.com/jimbo17/p/8885814.html">Linux kernel workqueue 机制分析</a></li>
<li><a href="https://cloud.tencent.com/developer/article/2441413">异步处理的强力助手：Linux Workqueue 机制详解</a></li>
<li><a href="http://www.wowotech.net/irq_subsystem/workqueue.html">Concurrency Managed Workqueue之（一）：workqueue的基本概念</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>中断上下文能睡眠吗?</title>
    <url>/lnx/irq/</url>
    <content><![CDATA[<h1 id="没有-task_struct-的-isr"><a class="markdownIt-Anchor" href="#没有-task_struct-的-isr"></a> 没有 task_struct 的 ISR</h1>
<p>众所周知，中断上下文不能睡眠，但是这句话细说起来，还是有很多值得深究的地方。所谓中断上下文，就是中断触发后，执行中断服务例程 (Interrupt Service Routine/Interrupt Handler) 的资源，这些资源有哪些呢？少得可怜，除了执行 ISR 代码的 CPU 核心外，中断上下文甚至都没有<strong>自己的栈</strong>来保存临时变量，所有的资源都是抢占中断触发时那个进程的，显然不能让这种“<strong>抢占</strong>”持续太久，所以 Linux 将 ISR 分成了 <strong>top half</strong> 和 <strong>bottom half</strong> 两部分，也就是<strong>硬件中断上下文</strong>和<strong>软件中断上下文</strong>， 所以严格来说是，在 Linux 内核中，<strong>硬件中断上下文不能睡眠</strong>。</p>
<span id="more"></span>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="http://www.wowotech.net/irq_subsystem/workqueue.html">Concurrency Managed Workqueue之（一）：workqueue的基本概念</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Atomic Mode Setting 设计概要 第一部分 （译）</title>
    <url>/lnx/kms/</url>
    <content><![CDATA[<p>本文翻译 Daniel Vetter 于 2015 年 8 月 5 日发表在 <a href="http://LWN.net">LWN.net</a> 的文章 “Atomic mode setting design overview, part 1”. 文章主要阐述了为什么要引入一个全新的 Kernel Display Driver 接口以及新老实现的一些细节。</p>
<span id="more"></span>
<p>过去几年[1], 两大趋势产生了对一个全新的 Kernel Display Driver 接口的需要。一方面，人们不再欣赏部分重绘和窗口撕裂当他们的图形界面有任何变化的时候。像 Wayland 这样的新的合成器(compositor) 宣称 “every frame is perfect”. 另一方面，出现了很多电池供电的手机和平板, 这些设备虽然有复杂绚丽的图形界面，但也有严重的功耗限制。这导致了一系列特殊用途的显示硬件的爆发，以帮助相对耗电量较高但更通用的GPU在合成屏幕内容时发挥作用。将这些趋势结合起来，需要以一种全或无(all-or-nothing)的原子方式更新大量显示硬件状态，以确保每一帧都是完美的，并尽可能地使用功耗优化的硬件。</p>
<p>经过几年的开发后，DRM 子系统的 atomic display 驱动 ioctl() 终于在黄金时间(prime time)准备好了。</p>
<p><a href="https://lwn.net/Articles/653071/">阅读原文</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel Debugging</title>
    <url>/lnx/kernel-debug/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">Distro</th>
<th style="text-align:left">Ubuntu</th>
<th style="text-align:left">Arch Linux</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">source</td>
<td style="text-align:left"><a href="git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/jammy">git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/jammy</a></td>
<td style="text-align:left"><a href="git@github.com:archlinux/linux.git">git@github.com:archlinux/linux.git</a></td>
</tr>
<tr>
<td style="text-align:left">initrd</td>
<td style="text-align:left"><code>sudo mkinitramfs -o /boot/initrd.img-KERNELVERSION KERNELVERSION</code></td>
<td style="text-align:left"><code>sudo mkinitcpio --generate /boot/initramfs-KERNELVERSION.img --kernel KERNELVERSION</code></td>
</tr>
<tr>
<td style="text-align:left">grub</td>
<td style="text-align:left"><code>sudo update-grub</code></td>
<td style="text-align:left"><code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code></td>
</tr>
</tbody>
</table>
<ul>
<li><code>KERNELVERSION</code> 是 <code>make kernelrelease</code> 的输出，同时也是 <code>sudo make modules_install</code> 时在 <code>/lib/modules</code> 创建的目录名</li>
</ul>
<span id="more"></span>
<h1 id="编译内核"><a class="markdownIt-Anchor" href="#编译内核"></a> 编译内核</h1>
<ul>
<li>配置内核最简单的方法是 <code>make olddefconfig</code></li>
<li>内核配置保存在 .config</li>
<li>内核源码树里包含命令行修改 .config 的脚本 scripts/config</li>
<li>内核构建依赖 flex, bison 词法分析程序</li>
</ul>
<h2 id="ubuntu"><a class="markdownIt-Anchor" href="#ubuntu"></a> Ubuntu</h2>
<ul>
<li>Environment</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">configuration</th>
<th style="text-align:left">version</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">distro</td>
<td style="text-align:left">Ubuntu 22.04 Jammy Jellyfish</td>
</tr>
<tr>
<td style="text-align:left">gcc</td>
<td style="text-align:left">11.2.0</td>
</tr>
<tr>
<td style="text-align:left">original kernel</td>
<td style="text-align:left">5.15.0-43-generic</td>
</tr>
<tr>
<td style="text-align:left">building kernel</td>
<td style="text-align:left">v6.0</td>
</tr>
</tbody>
</table>
<ul>
<li>Compilation Errors</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Errors</th>
<th style="text-align:left">Need to do</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">gelf.h: No such file or directory</td>
<td style="text-align:left">apt install libelf-dev</td>
</tr>
<tr>
<td style="text-align:left">&lt;openssl/opensslv.h&gt;: No such file or directory</td>
<td style="text-align:left">apt install libssl-dev</td>
</tr>
<tr>
<td style="text-align:left">No rule to make target ‘debian/canonical-certs.pem’</td>
<td style="text-align:left">./scripts/config --set-str SYSTEM_TRUSTED_KEYS “”</td>
</tr>
<tr>
<td style="text-align:left">No rule to make target ‘debian/canonical-revoked-certs.pem’</td>
<td style="text-align:left">./scripts/config --set-str SYSTEM_REVOCATION_KEYS “”</td>
</tr>
</tbody>
</table>
<h2 id="windows-subsytem-for-linux"><a class="markdownIt-Anchor" href="#windows-subsytem-for-linux"></a> Windows Subsytem for Linux</h2>
<ul>
<li>.config</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make KCONFIG_CONFIG=Microsoft/config-wsl</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Compilation Errors<br />
<a href="https://blog.csdn.net/qq_36393978/article/details/124274364">这是一个非常常见的依赖问题</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  LD      vmlinux.o</span><br><span class="line">  MODPOST vmlinux.symvers</span><br><span class="line">  MODINFO modules.builtin.modinfo</span><br><span class="line">  GEN     modules.builtin</span><br><span class="line">BTF: .tmp_vmlinux.btf: pahole (pahole) is not available</span><br><span class="line">Failed to generate BTF for vmlinux</span><br><span class="line">Try to disable CONFIG_DEBUG_INFO_BTF</span><br><span class="line">make: *** [Makefile:1218: vmlinux] Error 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="安装内核"><a class="markdownIt-Anchor" href="#安装内核"></a> 安装内核</h1>
<p>安装内核包括 4 部分：</p>
<ul>
<li>安装 vmlinuz, 也就是压缩格式的内核 ELF 镜像 <code>make install</code>
<ul>
<li><code>make install</code> 最终要么调用用户自定义的安装脚本，要么调用内核源码树里的 <code>install.sh</code> 脚本<br />
<img src="/images/kernel-build/install.png" alt="" /></li>
</ul>
</li>
<li>安装 modules, <code>make modules_install</code></li>
<li>制作 initramdisk (或者叫 initramfs) 初始化内存盘，它里面会包含必要的 modules</li>
<li>更新 grub, 以便启动时可以选择新内核</li>
</ul>
<h2 id="ubuntu-2"><a class="markdownIt-Anchor" href="#ubuntu-2"></a> Ubuntu</h2>
<h2 id="windows-subsystem-for-linux"><a class="markdownIt-Anchor" href="#windows-subsystem-for-linux"></a> Windows Subsystem for Linux</h2>
<ul>
<li>
<p><code>mv arch/x86/boot/bzImage /mnt/c/Users/luc/</code></p>
</li>
<li>
<p><a href="https://falco.org/blog/falco-wsl2-custom-kernel/">编辑 /mnt/c/Users/luc/.wslconfig</a>, 添加下面两行</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">kernel=C:\\Users\\luc\\bzImage</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NOTE: 如果<a href="https://devblogs.microsoft.com/commandline/automatically-configuring-wsl/">以上两行添加进 /etc/wsl.conf 文件，不会有任何作用</a>, 因为 <code>/etc/wsl.conf</code> 不支持 <code>wsl2</code> Section</p>
</blockquote>
<ul>
<li>配置完成后，重启 WSL Ubuntu 20.04, 新编译的内核将生效。不要用 <code>wsl --terminate</code>.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --shutdown Ubuntu-20.04</span><br></pre></td></tr></table></figure>
<h1 id="编译工具"><a class="markdownIt-Anchor" href="#编译工具"></a> 编译工具</h1>
<p>内核源码树中 <code>tools</code> 目录下包含了相当有用的工具，像 perf, objtool 等等，可以通过 <code>make tools/help</code> 查看完整工具列表。以构建安装 perf 为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make tools/perf</span><br><span class="line"><span class="built_in">sudo</span> make -C tools/perf install prefix=/usr</span><br></pre></td></tr></table></figure>
<p>对于修改安装路径, <code>prefix</code> 和 <code>DESTDIR</code> 变量都可以，但 PREFIX 不行。</p>
<h1 id="调试内核"><a class="markdownIt-Anchor" href="#调试内核"></a> 调试内核</h1>
<h2 id="与调试相关的内核配置"><a class="markdownIt-Anchor" href="#与调试相关的内核配置"></a> 与调试相关的内核配置</h2>
<h3 id="config_debug_fs"><a class="markdownIt-Anchor" href="#config_debug_fs"></a> CONFIG_DEBUG_FS</h3>
<h4 id="如何在-wsl2-上启用-debugfs"><a class="markdownIt-Anchor" href="#如何在-wsl2-上启用-debugfs"></a> 如何在 WSL2 上启用 debugfs</h4>
<p>确认下内核是否开启了 debugfs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zcat /proc/config.gz | grep CONFIG_DEBUG_FS</span><br></pre></td></tr></table></figure>
<p>要想使用 debugfs，首先要挂载它到 <code>/sys/kernel/debug</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t debugfs none /sys/kernel/debug/</span><br></pre></td></tr></table></figure>
<p>如果想让挂载在系统重启后自动挂载，在 <code>/etc/fstab</code> 加下面一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debugfs     /sys/kernel/debug       debugfs defaults        0 0</span><br></pre></td></tr></table></figure>
<p>在添加后，执行 <code>mount -a</code> 命令将看到 <code>/sys/kernel/debug</code> 文件系统的内容, <code>/sys/kernel/debug</code> 目录的权限是 700, 只有 root 用户才能进入，sudo 也不行</p>
<h3 id="config_tracing"><a class="markdownIt-Anchor" href="#config_tracing"></a> CONFIG_TRACING</h3>
<p>CONFIG_TRACING 是内核 2.6.27 (2008-10-09)* 引入的一个<strong>不可配置的(not configurable)</strong> 内核选项，所谓<strong>不可配置</strong>的意思是这个 CONFIG <strong>不能直接</strong>由用户打开或关闭，它的开启与否只能由其它依赖它的选项的状态决定。</p>
<p>它对应的 <strong>tracefs</strong> 也需要挂载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t tracefs none /sys/kernel/tracing</span><br></pre></td></tr></table></figure>
<p>像 <strong>ftrace</strong>, <strong>trace-cmd</strong> 都需要挂载这个目录。</p>
<h4 id="tracers"><a class="markdownIt-Anchor" href="#tracers"></a> tracers</h4>
<p>要使用 <strong>ftrace</strong>, 不光要挂载 tracefs, 内核相应的追踪器 (tracer) 也要编译进内核，可用的内核追踪器可以通过 <code>cat /sys/kernel/tracing/available_tracers</code> 查看。</p>
<ul>
<li>CONFIG_FUNCTION_TRACER</li>
<li>CONFIG_FUNCTION_GRAPH_TRACER</li>
<li>CONFIG_HWLAT_TRACER</li>
<li>CONFIG_IRQSOFF_TRACER</li>
<li>CONFIG_OSNOISE_TRACER</li>
<li>CONFIG_PREEMPT_TRACER</li>
<li>CONFIG_SCHED_TRACER</li>
<li>CONFIG_STACK_TRACER</li>
<li>CONFIG_CONTEXT_SWITCH_TRACER</li>
<li>CONFIG_NOP_TRACER</li>
</ul>
<h4 id="ftrace"><a class="markdownIt-Anchor" href="#ftrace"></a> ftrace</h4>
<p>ftrace 常用的有两种：<strong>基于 function 的</strong>和<strong>基于 event 的</strong></p>
<ul>
<li>基于 function
<ul>
<li><code>cat available_tracers</code> 查看有哪些 tracers</li>
<li><code>echo function_graph &gt; current_tracer</code> 从 <code>available_tracers</code> 中选择一个 tracer</li>
<li><code>echo xxxxx &gt; set_graph_function</code> 从 <code>available_filter_functions</code> 中选择几个 functions</li>
<li><code>echo 1 &gt; tracing_on</code> 启动 trace</li>
<li><code>cat trace</code> 或 <code>cat trace_pipe</code> 查看结果</li>
</ul>
</li>
<li>基于 event
<ul>
<li><code>cat available_events</code> 查看有哪些 events</li>
<li><code>echo amdgpu:amdgpu_sched_run_job &gt; set_event</code> 添加 event
<ul>
<li><code>echo amdgpu:amdgpu_device_wreg &gt;&gt; set_event</code> 继续追加 event</li>
</ul>
</li>
<li><code>echo 1 &gt; tracing_on</code> 启动 trace</li>
<li><code>cat trace</code> 或 <code>cat trace_pipe</code> 查看结果</li>
</ul>
</li>
</ul>
<p>以上操作均需要 <strong>root 权限</strong>， 在目录 <strong><code>/sys/kernel/debug/tracing</code></strong> 下执行</p>
<h4 id="trace-cmd"><a class="markdownIt-Anchor" href="#trace-cmd"></a> trace-cmd</h4>
<p><strong>trace-cmd</strong> 实际上是为了方便使用 <strong>ftrace</strong>, 比方下面的 trace-cmd 命令与直接 <code>cat /sys/kernel/tracing/available_events</code> 是等价的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trace-cmd list -e</span><br></pre></td></tr></table></figure>
<h3 id="config_ikconfig_proc"><a class="markdownIt-Anchor" href="#config_ikconfig_proc"></a> CONFIG_IKCONFIG_PROC</h3>
<p>这个配置决定 <code>/proc/config.gz</code> 是否存在。Ubuntu 似乎默认关闭此配置，而是将内核 config 保存在 <code>/boot/config-$(uname -r)</code></p>
<h3 id="config_dynamic_debug"><a class="markdownIt-Anchor" href="#config_dynamic_debug"></a> CONFIG_DYNAMIC_DEBUG</h3>
<p>打开 <strong>Dynamic Debug</strong> 有好几种，但前提都是 <code>CONFIG_DYNAMIC_DEBUG=y</code></p>
<h4 id="方法一运行时打开"><a class="markdownIt-Anchor" href="#方法一运行时打开"></a> 方法一：运行时打开</h4>
<p>Dynamic Debug 就通过 <code>/sys/kernel/debug/dynamic_debug/control</code> 文件打开或关闭特定文件的某行或函数里的打印，但它只对使用</p>
<ul>
<li><code>pr_debug()</code></li>
<li><code>dev_dbg()</code></li>
<li><code>print_hex_dump_debug()</code></li>
<li><code>print_hex_dump_bytes()</code></li>
</ul>
<p>这 4 个函数的打印来有用。</p>
<h4 id="方法二内核启动参数"><a class="markdownIt-Anchor" href="#方法二内核启动参数"></a> 方法二：内核启动参数</h4>
<ul>
<li>按 <code>file</code> 打开 dynamic debug</li>
</ul>
<p><span style="background-color: yellow; padding: 4px;">dyndbg=&quot;file arch/x86/pci/* +p&quot;</span></p>
<p>这个启动参数会打开 <code>arch/x86/pci</code> 目录下所有 dynamic debug 打印，如果通过修改 <code>/etc/default/grub</code> 里的 <code>GRUB_CMDLINE_LINUX</code>, 需要对双引号进行转义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX=&quot;dyndbg=\&quot;file arch/x86/pci/* +p\&quot;&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>按 <code>module</code> 打开 dynamic debug</li>
</ul>
<p><span style="background-color: yellow; padding: 4px;">dyndbg=&quot;module i915 +p&quot;</span></p>
<p>如果要同时将 <code>arch/x86/pci/</code> 目录下所有文件和内核模块 <code>i915</code> 的 dynamic debug 都打开</p>
<p><span style="background-color: yellow; padding: 4px;">dyndbg=&quot;file arch/x86/pci/* +p;module i915 +p&quot;</span></p>
<h4 id="方法三etcmodprobedxxxconf"><a class="markdownIt-Anchor" href="#方法三etcmodprobedxxxconf"></a> 方法三：/etc/modprobe.d/xxx.conf</h4>
<p>由于 <code>dyndbg=</code> 内核参数一般在内核模块加载前就解析了，所以对于按模块打开 dynamic debug 来说，在 <code>/etc/modprobe.d/i915-debug.conf</code> 文件中设置更保险</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options i915 dyndbg=+p</span><br></pre></td></tr></table></figure>
<h3 id="config_drm_use_dynamic_debug"><a class="markdownIt-Anchor" href="#config_drm_use_dynamic_debug"></a> <code>CONFIG_DRM_USE_DYNAMIC_DEBUG</code></h3>
<p>这是内核 6.1 (2022-12-11) 才引入的专门控制 <code>drm_dbg()</code> 是否用 <strong>Dynamic Debug</strong> 来实现的可配置选项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_DRM_USE_DYNAMIC_DEBUG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drm_dev_dbg(dev, cat, fmt, ...)				\</span></span><br><span class="line"><span class="meta">	__drm_dev_dbg(NULL, dev, cat, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> drm_dev_dbg(dev, cat, fmt, ...)				\</span></span><br><span class="line"><span class="meta">	_dynamic_func_call_cls(cat, fmt, __drm_dev_dbg,		\</span></span><br><span class="line"><span class="meta">			       dev, cat, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="config_debug_atomic_sleep"><a class="markdownIt-Anchor" href="#config_debug_atomic_sleep"></a> <code>CONFIG_DEBUG_ATOMIC_SLEEP</code></h3>
<p><a href="https://www.kernel.org/doc/html/latest/driver-api/dma-buf.html?highlight=dma_fence_wait_timeout#c.dma_fence_wait_timeout"><code>dma_fence_wait_timeout()</code></a> 会睡眠调用进程直到 fence 被 signaled 或者指定定时器超时。该函数中会调用 <code>might_sleep()</code> 来标识 (annotation) 调用进程可能进入睡眠状态，并打印源文件名和行号，帮助调试。 但只有内核配置了 <code>CONFIG_DEBUG_ATOMIC_SLEEP</code> 才有效，否则 <code>__might_sleep()</code> 是一个空函数。</p>
<h2 id="kernlog"><a class="markdownIt-Anchor" href="#kernlog"></a> kern.log</h2>
<p><code>/var/log/kern.log</code> 的一个主要问题是每行前面的 <code>%HOSTNAME%</code> 太长又没什么用，<code>%timegenerated%</code> 和内核原始打印 <code>%msg%</code> 里的时间戳实际上有一个就可以了。查了一下配置方法，实际上就是要在 <code>/etc/rsyslog.conf</code> 里定义一个 <code>$template</code>, 并指定为默认的模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$template SimpleFormat,&quot;%timegenerated:::date-rfc3339% %msg:::drop-last-lf%\n&quot;</span><br><span class="line">$ActionFileDefaultTemplate SimpleFormat</span><br></pre></td></tr></table></figure>
<p>或在 <code>/etc/rsyslog.d/50-default.conf</code> 里的 <code>kern.*</code> 规则中加上这个 template</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kern.* -/var/log/kern.log;SimpleFormat</span><br></pre></td></tr></table></figure>
<p>注意，不要直接在 <code>/etc/rsyslog.conf</code> 里直接加上面这条规则，要加在 <code>/etc/rsyslog.d/50-default.conf</code>， 否则会输出两遍。</p>
<p>最后，就是要重启 rsyslog 服务生效。</p>
<p>内核的 log 实际上都是写入一个 ring buffer 里的，暴露给用户的接口是 <code>/proc/kmsg</code> 和 <code>/dev/kmsg</code>, rsyslog 服务也是通过这些接口，重新处理 log 后写入 <code>/var/log/kern.log</code> 的。下面的操作可以让 <code>dmesg</code> 多一条 log</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;&lt;3&gt;HELLO&quot; &gt; /dev/kmsg</span><br></pre></td></tr></table></figure>
<h2 id="sysctl-和内核参数"><a class="markdownIt-Anchor" href="#sysctl-和内核参数"></a> <code>sysctl</code> 和内核参数</h2>
<p>运行时内核参数大多在 <code>/proc/sys/</code> 目录下，二进制程序 <code>/usr/sbin/sysctl</code> 可用来查看，修改这些内核参数。</p>
<ul>
<li>查看某个内核参数的值
<ul>
<li><code>sysctl kernel.perf_event_paranoid</code></li>
</ul>
</li>
<li>列出所有内核参数的值 (有些需要 root 权限)
<ul>
<li><code>sysctl -a</code></li>
</ul>
</li>
<li>修改某个内核参数的值
<ul>
<li><code>sysctl kernel.perf_event_paranoid=-1</code></li>
</ul>
</li>
</ul>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://wiki.ubuntu.com/Kernel/SourceCode">https://wiki.ubuntu.com/Kernel/SourceCode</a></li>
<li><a href="https://wiki.archlinux.org/title/Installation_guide">https://wiki.archlinux.org/title/Installation_guide</a></li>
<li><a href="https://access.redhat.com/solutions/5914171">https://access.redhat.com/solutions/5914171</a></li>
<li><a href="https://www.kernel.org/doc/html/v4.14/admin-guide/dynamic-debug-howto.html">Dynamic Debug Howto</a></li>
<li><a href="https://www.rsyslog.com/how-to-bind-a-template/">How to bind a template in rsyslog.conf</a></li>
<li><a href="https://www.rsyslog.com/doc/configuration/properties.html#message-properties">Rsyslog properties</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁是如何发生的？</title>
    <url>/lnx/mpin/</url>
    <content><![CDATA[<h1 id="背景介绍"><a class="markdownIt-Anchor" href="#背景介绍"></a> 背景介绍</h1>
<p>之前一直有一个疑问：<a href="https://www.kernel.org/doc/html/latest/driver-api/dma-buf.html#dma-fence-cross-driver-contract">为什么在 drm_gpu_sheduler 的 run_job 路径里带 GFP_KERNEL 标志的内存申请可以造成死锁?</a>, 直到了解内核内存 <strong>Pin</strong> 和 <strong>Shrink</strong> 的机制后，好像是明白了死锁的过程。</p>
<span id="more"></span>
<h1 id="内存-pin"><a class="markdownIt-Anchor" href="#内存-pin"></a> 内存 Pin</h1>
<p>Linux 是基于页 (page) 来管理内存的，物理内存页和虚拟内存页一般有相同的大小，比较常见的是 4KB 页大小。</p>
<p><img src="/images/mpin/L2PageTables.png" alt="Paging mechanism" /></p>
<h1 id="内存-reclaim"><a class="markdownIt-Anchor" href="#内存-reclaim"></a> 内存 Reclaim</h1>
<p>内存页回收有两种方式：</p>
<ul>
<li>direct reclaim (同步)</li>
</ul>
<p>direct reclaim 是指在内存分配时，如果系统内存不足，直接触发内存回收，这时内存申请调用是会被<strong>阻塞的</strong>。</p>
<ul>
<li>background reclaim (异步)</li>
</ul>
<p>background reclaim 是指 kswapd 线程被唤醒异步地扫描 Zone 回收内存。</p>
<h1 id="内存-shrink"><a class="markdownIt-Anchor" href="#内存-shrink"></a> 内存 Shrink</h1>
<p>为了能够动态的回收内存，内核提供了一套 “shrinker” 接口，通过该机制，内存管理子系统 (mm) 可以通过<strong>回调</strong>的方式回收部分内存页，以减小系统内存压力。</p>
<p>根据文章 <a href="https://blog.csdn.net/weixin_49382066/article/details/130704158">Linux内核页回收</a> 中的描述，无论是 direct reclaim 还是 kswapd, 最终都会调到 <code>shrink_node()</code>， 而 <code>shrink_node()</code> 又是如何调到由其它文件系统或驱动注册的 shrinker 的钩子函数的呢？</p>
<pre><code class="highlight mermaid">flowchart TD
    A[&quot;shrink_node()&quot;]
    B[&quot;lru_gen_shrink_node()&quot;]
    C[&quot;shrink_many()&quot;]
    D[&quot;shrink_one()&quot;]
    E[&quot;shrink_slab()&quot;]
    F[&quot;do_shrink_slab()&quot;]
    G[&quot;`shrinker-&gt;count_objects()
    shrinker-&gt;scan_objects()`&quot;]

    A --&gt; B --&gt; C --&gt; D
    B -- mem_cgroup_disabled() --&gt; D
    D --&gt; E --&gt; F --&gt; G</code></pre>
<h1 id="gfp_kernel"><a class="markdownIt-Anchor" href="#gfp_kernel"></a> GFP_KERNEL</h1>
<p>带有 <code>GFP_KERNEL</code> 标志的内存申请既可以触发 direct reclaim, 也可以触发 background reclaim。如果 direct reclaim 被触发，回调注册的 shrinker 回调函数，而这个回调函数可以实现任何逻辑(取决于实现这个 shrinker 的文件系统或驱动)，如果这个逻辑恰好是在<strong>等待某个 GPU job 的 dma_fence 被 signaled</strong>, 而你又正好是在 kick off 这个 GPU job 时触发的 direct reclaim, 这样是不是就死锁了？</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://weedge.github.io/perf-book-cn/zh/chapters/3-CPU-Microarchitecture/3-7_Virtual_memory_cn.html">Performance Analysis And Tuning On Modern CPUs</a></li>
<li><a href="https://lwn.net/Articles/600502/">Locking and pinning</a></li>
<li><a href="https://tinylab.org/lwn-550463/">Smarter Shrinker</a></li>
<li><a href="https://www.kernel.org/doc/html/next/core-api/memory-allocation.html#gfp-flags-and-reclaim-behavior">GFP flags and reclaim behavior</a></li>
<li><a href="https://blog.csdn.net/weixin_49382066/article/details/130704158">Linux内核页回收</a></li>
<li><a href="https://github.com/freelancer-leon/notes/blob/master/kernel/graphic/Linux-Graphic.md">freelancer-leon’s notes</a></li>
<li><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Graphics_Execution_Manager">GEM wikipedia</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Nouveau</title>
    <url>/lnx/nouveau/</url>
    <content><![CDATA[<pre><code class="highlight mermaid">---
config:
    theme: &#x27;default&#x27;
    themeVariables:
        cScale0: &#x27;#d3d3d3&#x27;
        cScaleLabel0: &#x27;#000000&#x27;
        cScale1: &#x27;#a6a6a6&#x27;
        cScaleLabel1: &#x27;#000000&#x27;
        cScale2: &#x27;#76b900&#x27;
        cScaleLabel2: &#x27;#ffffff&#x27;
---
timeline
    title NVIDIA Desktop GPUs History
    section early NVxx era
        1999 : NV04
        2004 : NV40
        2006 : NV50 : Tesla : Introduction of per context VMA
    section pre-Turing era
        2010 : GF1xx : NVC0 - Fermi
        2012 : GK1xx : NVE0 - Kepler : Vulkan support : nouveau start support reclocking
        2014 : GM1xx : Maxwell
        2014 : GM2xx : Maxwell 2 : Start of signed firmware thus little chance to reclock
        2016 : GP1xx : Pascal
        2017 : GV1xx : Volta
    section New era for open source (GSP)
        2018 : TU1xx : Turing : GPU System Processor support
        2020 : GA1xx : Ampere
        2022 : AD1xx : Ada Lovelace
        2025 : GB2xx : Blackwell</code></pre>
<span id="more"></span>
<p><img src="/images/nouveau/benchmarks-on-gp108.png" alt="" /></p>
<h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1>
<ul>
<li><a href="https://insujang.github.io/2017-04-27/gpu-architecture-overview/">GPU Architecture Overview</a></li>
<li><a href="https://blog.csdn.net/Linux_Everything/article/details/127780944">LWN: NVIDIA GPU 和 Nouveau</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units">List of Nvidia GPUs</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Submitting My First Linux Kernel Patch</title>
    <url>/lnx/patch-submit/</url>
    <content><![CDATA[<p>Linux 内核的 patch 是以纯文本的邮件形式进行提交和代码走查的，而且 patch 是先到内核子系统 maintainer 维护的 git tree, 再到 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/">Linus Torvalds 的 main tree</a>。本文主要是以一个 patch 提交的实例来记录一下整个过程中的一些具体操作要点，至于 kernel patch 提交的规范和操作细节<a href="https://www.kernel.org/doc/html/latest/process/submitting-patches.html">内核文档</a> 和各种博客文章有很多，这里不再赘述。</p>
<span id="more"></span>
<h1 id="用到的平台软件工具"><a class="markdownIt-Anchor" href="#用到的平台软件工具"></a> 用到的平台，软件，工具</h1>
<ul>
<li>Windows Subsystem for Linux, Ubuntu 20.04 LTS (Focal Fossa)</li>
<li>邮件客户端 mutt 1.13.2 (<code>apt install mutt</code>)</li>
<li>git 2.25.1</li>
<li>kernel git tree (mainly DRM) <a href="https://gitlab.freedesktop.org/drm">https://gitlab.freedesktop.org/drm</a></li>
</ul>
<h1 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h1>
<h2 id="准备-patch"><a class="markdownIt-Anchor" href="#准备-patch"></a> 准备 patch</h2>
<ul>
<li>当你的 commit 已经在源码树上提交好后，只需使用 <code>git format-patch</code> 命令即可轻松生成一个内核 patch (假设 patch 里只包含一个 commit)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git format-patch HEAD^ -o /tmp/   # 将生成的 patch 文件保存在 /tmp 目录</span><br></pre></td></tr></table></figure>
<ul>
<li>当你的 patch 被开发者 review 后，如果需要修改，修改后可通过增加 <code>-v N</code> 选项生成下一个版本的 patch</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git format-patch HEAD^ -v 2 -o /tmp/</span><br></pre></td></tr></table></figure>
<h2 id="检查-patch"><a class="markdownIt-Anchor" href="#检查-patch"></a> 检查 patch</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./scripts/checkpatch.pl /path/to/patch</span><br></pre></td></tr></table></figure>
<p><code>checkpatch.pl</code> 工具执行各种 codestyle, patch 格式, 社区提交补丁规范的检查，它和测试一样，都是提交补丁前不可缺少的步骤</p>
<h2 id="提交-patch"><a class="markdownIt-Anchor" href="#提交-patch"></a> 提交 patch</h2>
<p>个人觉得提交补丁比较简单的方式是使用 <code>git send-email</code>, 因为内核补丁或补丁集都是以纯文本(plain text)电子邮件形式提交的, 所以提交前需要</p>
<ul>
<li>配置好你的 SMTP (Simple Mail Transfer Protocol)邮件发送服务器</li>
<li>确定好收件人和抄送人(Carbon Copy)
<ul>
<li>收件人一般是 subsystem maintainer 或邮件列表，如 <a href="mailto:dri-devel@lists.freedesktop.org">dri-devel@lists.freedesktop.org</a></li>
<li>抄送人一般使用脚本 <code>./scripts/get_maintainer.pl /path/to/patch</code> 来自动获取
<ul>
<li><code>./scripts/get_maintainer.pl</code> 不加任何选项时输出格式是这样子的(具体内容随补丁而定)  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Maarten Lankhorst &lt;maarten.lankhorst@linux.intel.com&gt; (maintainer:DRM DRIVERS AND MISC GPU PATCHES)</span><br><span class="line">Maxime Ripard &lt;mripard@kernel.org&gt; (maintainer:DRM DRIVERS AND MISC GPU PATCHES)</span><br><span class="line">Thomas Zimmermann &lt;tzimmermann@suse.de&gt; (maintainer:DRM DRIVERS AND MISC GPU PATCHES)</span><br><span class="line">David Airlie &lt;airlied@gmail.com&gt; (maintainer:DRM DRIVERS)</span><br><span class="line">Simona Vetter &lt;simona@ffwll.ch&gt; (maintainer:DRM DRIVERS)</span><br><span class="line">dri-devel@lists.freedesktop.org (open list:DRM DRIVERS)</span><br><span class="line">linux-kernel@vger.kernel.org (open list)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用-mutt"><a class="markdownIt-Anchor" href="#使用-mutt"></a> 使用 mutt</h3>
<p>提交 Linux kernel patch 实际上就是用邮件客户端将生成好的 patch 文件发送给相关的 maintainers 和 maillists. <code>git send-email</code> 也可以做同样的事，这里使用的是 mutt. mutt 的基本命令行格式是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutt [-Enx] [-e cmd] [-F file] [-H file] [-i file] [-s subj] [-b addr] [-c addr] [-a file [...] --] addr|mailto_url [...]</span><br></pre></td></tr></table></figure>
<p>本例中只使用到了 <code>-H file</code> 选项，它将包含有邮件头和邮件主体的 patch 文件作为参数创建邮件草稿 (意思是该命令执行后还会让你再编辑邮件，包括收件人，邮件内容增删改等）。本例中 mutt 的唯一参数是后面的收件人列表，它是通过内核源码树里的一个<a href="https://elixir.bootlin.com/linux/latest/source/scripts/get_maintainer.pl">脚本工具</a>自动获取的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mutt -H /tmp/v2-0001-drm-vram-helper-fix-function-names-in-vram-helper.patch \</span><br><span class="line">    &quot;`./scripts/get_maintainer.pl --separator , --norolestats \</span><br><span class="line">    /tmp/v2-0001-drm-vram-helper-fix-function-names-in-vram-helper.patch`&quot;</span><br></pre></td></tr></table></figure>
<p>带有 <code>Fixes:</code> tag 的patch 应该会被 backport 到以前必要 -stable tree.</p>
<p><img src="/images/patch-submit/patch-backport.png" alt="patch-backport" /></p>
<h3 id="使用-git-send-email"><a class="markdownIt-Anchor" href="#使用-git-send-email"></a> 使用 git send-email</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git send-email --to dri-devel@lists.freedesktop.org --cc-cmd &quot;./scripts/get_maintainer.pl --nogit-fallback --norolestats&quot; /tmp/0001-drm-doc-Fix-doc-in-drm_file.patch</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<p><code>git send-email</code> 同样需要配置发送邮件服务器 stmp</p>
<ul>
<li>
<p>将 <a href="mailto:user@stmp.gmail.com">user@stmp.gmail.com</a> 的密码配置在 ~/.gitconfig 的 sendemail 段</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[sendemail]</span><br><span class="line">    smtpserver = smtp.gmail.com</span><br><span class="line">    smtpencryption = tls</span><br><span class="line">    smtpserverport = 587</span><br><span class="line">    smtpuser = onion0709@gmail.com</span><br><span class="line">    smtppass = &lt;16 characters Google App Password&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>mutt 需要配置 IMAP/SMTP, 即邮件收发协议配置 (这是整个过程中最费劲的)<br />
mutt 的配置文件默认路径是 <code>$HOME/.mutt/muttrc</code></p>
</li>
<li>
<p>git 需要配置完整的 <code>user.name</code>, <code>user.email</code>.</p>
</li>
<li>
<p><code>git commit</code> 时需要加 <code>-s</code> (<code>--signoff</code>) 来自动增加 Signed-off-by 标签 (如果你 Signed-off-by 标签的邮件地址和发送 patch 的邮箱地址不同的话，还需要在邮件主体的第一行手动添加 <code>From: Zhang San &lt;xxx@yourmail.com&gt;</code>, <a href="mailto:xxx@yourmail.com">xxx@yourmail.com</a> 是你的 Signed-off-by 邮件地址)</p>
</li>
<li>
<p>如果 patch 邮件发出后2,3周，甚至一个月都没有收到任何回应，在确认收件地址没问题的情况下，可以再次 <code>git send-email</code> 原来的patch, 同时<strong>在邮件主题手动加上 RESEND</strong> 标识</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[PATCH RESEND] sub/sys: Condensed patch summary</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>git send-email -v 2 --in-reply-to=&quot;&lt;v1-message-id&gt; ...&quot;</code> 避免因提供补丁的下一个版本而中断线程。</p>
</li>
<li>
<p>对于补丁集 (Patch Series), 一般 Changelog 会写在补丁集的 cover letter 里。对于单个补丁，如果不想让 Changelog 出现在 commit message 里，但又想给 Maintainer 提供补丁迭代的信息，可以在 <code>Signed-off-by</code> 后面<strong>手动加上 <code>---</code></strong>, 然后开始写 Changelog(如下), 这样 Changelog 就不会出现在最终的 Commit message 里， <strong>修改的时机</strong>可以在 <code>git commit -s</code> 写提交日志时，也可以在 <code>git send-email --to ...</code> 发送邮件时选择 <code>[e]dit</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">Signed-off-by: Zhang San &lt;zhang.san@gmail.com&gt;</span><br><span class="line">---</span><br><span class="line">v3:</span><br><span class="line">- blablabla</span><br><span class="line">- asdfasdfasdf</span><br><span class="line">v2:</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://www.kernel.org/doc/html/latest/process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>perf 和火焰图</title>
    <url>/lnx/perf/</url>
    <content><![CDATA[<p><img src="/images/perf/radeon.svg" alt="RedEclipse on R7340" /></p>
<span id="more"></span>
<h1 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h1>
<p>perf 使用的是采样(Sampling)技术</p>
<h1 id="环境-版本"><a class="markdownIt-Anchor" href="#环境-版本"></a> 环境 &amp; 版本</h1>
<ul>
<li>Linux 5.10.16.3-microsoft-standard-WSL2 x86_64 x86_64</li>
<li>Ubuntu 20.04.2 LTS</li>
<li>perf version 5.10.16.3</li>
</ul>
<p>NOTE: 如果没有特别说明，以下<code>perf</code>命令都在<code>root</code>权限下执行</p>
<h1 id="查询-罗列"><a class="markdownIt-Anchor" href="#查询-罗列"></a> 查询 &amp; 罗列</h1>
<p>列出Virtual Memory相关的<code>static tracepoint</code></p>
<ul>
<li>
<p><code>perf list 'vmscan:*'</code><br />
<img src="/images/perf/perf_list-vmscan.png" alt="" /></p>
</li>
<li>
<p>`perf list ‘kmem:*’<br />
k</p>
</li>
<li>
<p><code>perf stat -a sleep</code><br />
<img src="/images/perf/perf_stat.png" alt="" /></p>
</li>
</ul>
<h1 id="tracepoint-使能"><a class="markdownIt-Anchor" href="#tracepoint-使能"></a> tracepoint 使能</h1>
<p>通过 debugfs 中的相应文件使能 tracepoint</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@sie-luc:~# find /sys/kernel/debug/tracing/events/ -type d| grep -E &#x27;dma|gpu&#x27;</span><br><span class="line">/sys/kernel/debug/tracing/events/dma_fence</span><br><span class="line">/sys/kernel/debug/tracing/events/dma_fence/dma_fence_emit</span><br><span class="line">/sys/kernel/debug/tracing/events/dma_fence/dma_fence_init</span><br><span class="line">/sys/kernel/debug/tracing/events/dma_fence/dma_fence_destroy</span><br><span class="line">/sys/kernel/debug/tracing/events/dma_fence/dma_fence_enable_signal</span><br><span class="line">/sys/kernel/debug/tracing/events/dma_fence/dma_fence_signaled</span><br><span class="line">/sys/kernel/debug/tracing/events/dma_fence/dma_fence_wait_start</span><br><span class="line">/sys/kernel/debug/tracing/events/dma_fence/dma_fence_wait_end</span><br><span class="line">root@sie-luc:~# cat /sys/kernel/debug/tracing/events/dma_fence/dma_fence_enable_signal/</span><br><span class="line">cat: /sys/kernel/debug/tracing/events/dma_fence/dma_fence_enable_signal/: Is a directory</span><br><span class="line">root@sie-luc:~# cat /sys/kernel/debug/tracing/events/dma_fence/dma_fence_enable_signal/</span><br><span class="line">enable   filter   format   id       trigger</span><br><span class="line">root@sie-luc:~# cat /sys/kernel/debug/tracing/events/dma_fence/dma_fence_enable_signal/enable</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h1 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h1>
<ul>
<li><code>perf top -e cycles</code></li>
</ul>
<p><img src="/images/perf/perf_top-cycles.png" alt="perf top" /></p>
<ul>
<li>
<p><code>perf record -F 999 -p PID -g</code></p>
<ul>
<li>默认会在当前目录下生成 perf.data, 后面如果再执行之前的 perf.data 会自动重命名 perf.data.old</li>
</ul>
</li>
<li>
<p><code>perf script | /path/to/FlameGraph/stackcollapse-perf.pl | /path/to/FlameGraph/framegraph.pl &gt; result.svg</code></p>
<ul>
<li>
<p>生成火焰图需要这个脚本工具 <a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a>，而且如果想看到详细的调用栈需要编译跟踪对象为 <strong>Debug</strong> 版本</p>
</li>
<li>
<p>最近有一个 Rust 写的 <a href="https://github.com/flamegraph-rs/flamegraph">flamegraph-rs/flamegraph</a> 项目，用 <code>flamegraph</code> 二进制可执行程序代替了原来的 Perl 脚本，而且把原来分别执行 <code>perf record</code> 和 <code>perf script</code> 这两步合成一步，即可生成火焰图</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flamegraph -- vkgears</span><br></pre></td></tr></table></figure>
<p><img src="/images/perf/flamegraph.svg" alt="flamegraph-rs/flamegraph" /></p>
</li>
</ul>
</li>
</ul>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>perf</tag>
      </tags>
  </entry>
  <entry>
    <title>openKylin 2.0</title>
    <url>/lnx/ok/</url>
    <content><![CDATA[<h1 id="openkylin-20"><a class="markdownIt-Anchor" href="#openkylin-20"></a> <a href="https://www.openkylin.top/">OpenKylin 2.0</a></h1>
<p><img src="/images/ok/ok2.0.png" alt="ok2.0" /></p>
<span id="more"></span>
<h1 id="realtek-rtl8188gu-80211n-wlan-adapter"><a class="markdownIt-Anchor" href="#realtek-rtl8188gu-80211n-wlan-adapter"></a> Realtek RTL8188GU 802.11n WLAN Adapter</h1>
<p>系统安转好后第一件事就是联 WiFi, 为此购买了瑞昱的一款无线网卡。但是这款无线网卡在 Linux 上没有得到瑞昱官方的支持(没驱动)， 所以在 Github 上找到了一个<a href="https://github.com/fastoe/RTL8811CU">驱动仓库</a>，(由于内核版本的问题，稍加改动后) 编译成功，居然可以用</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/os_dep/linux/usb_intf.c b/os_dep/linux/usb_intf.c</span></span><br><span class="line"><span class="comment">index b8eea5b..1d5d52d 100644</span></span><br><span class="line"><span class="comment">--- a/os_dep/linux/usb_intf.c</span></span><br><span class="line"><span class="comment">+++ b/os_dep/linux/usb_intf.c</span></span><br><span class="line"><span class="meta">@@ -281,11 +281,7 @@</span> struct rtw_usb_drv usb_drv = &#123;</span><br><span class="line"> 	.usbdrv.supports_autosuspend = 1,</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 19))</span></span><br><span class="line"><span class="deletion">-	.usbdrv.drvwrap.driver.shutdown = rtw_dev_shutdown,</span></span><br><span class="line"><span class="deletion">-#else</span></span><br><span class="line"> 	.usbdrv.driver.shutdown = rtw_dev_shutdown,</span><br><span class="line"><span class="deletion">-#endif</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> static inline int RT_usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)</span><br></pre></td></tr></table></figure>
<p>但是驱动安装后，还是无法连接 Wifi, 看到设备信息后面有 <strong>Driver CDROM Mode</strong>, 就想用 <a href="https://www.draisberghof.de/usb_modeswitch/">usb_modeswitch</a> 改一下 USB Mode 试试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line">Bus 001 Device 002: ID 046d:c534 Logitech, Inc. Unifying Receiver</span><br><span class="line">Bus 001 Device 008: ID 0bda:1a2b Realtek Semiconductor Corp. RTL8188GU 802.11n WLAN Adapter (Driver CDROM Mode)</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br></pre></td></tr></table></figure>
<p><code>sudo ./usb_modeswitch -KW -v 0bda -p 1a2b</code> 后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line">Bus 001 Device 002: ID 046d:c534 Logitech, Inc. Unifying Receiver</span><br><span class="line">Bus 001 Device 009: ID 0bda:c811 Realtek Semiconductor Corp. 802.11ac NIC</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br></pre></td></tr></table></figure>
<p>从内核日志可以看到，在执行 <code>usb_modeswitch</code> 命令时，内核重新连接了该无线网卡, 之后无线网卡可以正常工作了， Nice!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usb 1-5: USB disconnect, device number 8</span><br><span class="line">usb 1-5: new high-speed USB device number 9 using xhci_hcd</span><br><span class="line">usb 1-5: New USB device found, idVendor=0bda, idProduct=c811, bcdDevice= 2.00</span><br><span class="line">usb 1-5: New USB device strings: Mfr=1, Product=2, SerialNumber=3</span><br><span class="line">usb 1-5: Product: 802.11ac NIC</span><br><span class="line">usb 1-5: Manufacturer: Realtek</span><br><span class="line">usb 1-5: SerialNumber: 123456</span><br></pre></td></tr></table></figure>
<h1 id="openssh"><a class="markdownIt-Anchor" href="#openssh"></a> OpenSSH</h1>
<p>安装 <strong>openssh-server</strong> 后 <code>sudo systemctl start sshd</code> 启动失败</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unpacking openssh-server (1:8.2p1-ok3) ...</span><br><span class="line">Setting up openssh-sftp-server (1:8.2p1-ok3) ...</span><br><span class="line">Setting up openssh-server (1:8.2p1-ok3) ...</span><br><span class="line">WARNING: tempfile is deprecated; consider using mktemp instead.</span><br><span class="line">rescue-ssh.target is a disabled or a static unit, not starting it.</span><br><span class="line">Job for ssh.service failed because the control process exited with error code.</span><br><span class="line">See &quot;systemctl status ssh.service&quot; and &quot;journalctl -xeu ssh.service&quot; for details.</span><br><span class="line">invoke-rc.d: initscript ssh, action &quot;start&quot; failed.</span><br><span class="line">● ssh.service - OpenBSD Secure Shell server</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/system/ssh.service; enabled; preset: enabled)</span><br><span class="line">     Active: activating (auto-restart) (Result: exit-code) since Sun 2025-06-22 13:51:52 CST; 8ms ago</span><br><span class="line">       Docs: man:sshd(8)</span><br><span class="line">             man:sshd_config(5)</span><br><span class="line">    Process: 8103 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=255/EXCEPTION)</span><br><span class="line">        CPU: 5ms</span><br><span class="line">dpkg: error processing package openssh-server (--configure):</span><br><span class="line"> installed openssh-server package post-installation script subprocess returned error exit status 1</span><br><span class="line">Processing triggers for man-db (2.9.1-ok3) ...</span><br><span class="line">Errors were encountered while processing:</span><br><span class="line"> openssh-server</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br><span class="line">➜  ~ /usr/sbin/sshd -t</span><br><span class="line">OpenSSL version mismatch. Built against 30000080, you have 30200010</span><br><span class="line">➜  ~ openssl --version</span><br><span class="line">OpenSSL 3.2.1 30 Jan 2024 (Library: OpenSSL 3.2.1 30 Jan 2024)</span><br></pre></td></tr></table></figure>
<p>这个报错好像是说 <code>openssh-server/sshd</code> 编译时链接的 OpenSSL 版本是 <strong>3.0.8</strong>, 而现在运行时环境上的 OpenSSL 版本是 <strong>3.2.1</strong>。然后查了一下 OpenSSL 的包情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  Secure Sockets Layer toolkit - shared libraries</span><br><span class="line"></span><br><span class="line">libssl1.1/yangtze,now 1.1.1f-ok3 amd64 [installed,automatic]</span><br><span class="line">  Secure Sockets Layer toolkit - shared libraries</span><br><span class="line"></span><br><span class="line">libssl3/yangtze 3.0.8-ok4.1 amd64 [residual-config]</span><br><span class="line">  Secure Sockets Layer toolkit - shared libraries</span><br><span class="line"></span><br><span class="line">libssl3t64/now 3.2.1-ok5 amd64 [installed,local]</span><br><span class="line">  Secure Sockets Layer toolkit - shared libraries</span><br></pre></td></tr></table></figure>
<p>OpenSSL 按照官方文档，轻松可以编译安装，但切记<strong>不要覆盖系统原来的 OpenSSL, 否则桌面可能进不去</strong>。OpenSSL 安装好后可以</p>
<ul>
<li>将安装目录 <code>/usr/local/ssl/lib64</code> 写入 <code>/etc/ld.so.conf.d/x86_64-linux-gnu.conf</code>。</li>
<li>将 bin 目录 <code>/usr/local/ssl/bin</code> 加入 <strong>PATH</strong></li>
<li>在编译 OpenSSH 之前 <code>export PKG_CONFIG_PATH=/usr/local/ssl/lib64/pkgconfig</code></li>
</ul>
<p>OK 2.0 源里的 openssh-server 版本是 8.2p1， 实际上编译时发现这个版本和 OpenSSL 3.2.1 是<strong>不兼容</strong>的， 所以随便把 openssh-server 的版本升了升， 选择了 <strong>V_9_2_P1</strong> 这个版本，可以编译成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr --without-zlib-version-check --with-ssl-dir=/usr/local/ssl</span><br></pre></td></tr></table></figure>
<p>现在运行 <code>/usr/sbin/sshd</code> 不会再报 <strong>OpenSSL version mismatch</strong> 的错误了。Nice</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  openssh-portable git:(9.2p1) ✗ /usr/sbin/sshd</span><br><span class="line">sshd: no hostkeys available -- exiting.</span><br><span class="line">➜  openssh-portable git:(9.2p1) ✗ openssl version</span><br><span class="line">OpenSSL 3.2.1 30 Jan 2024 (Library: OpenSSL 3.2.1 30 Jan 2024)</span><br></pre></td></tr></table></figure>
<h1 id="install-trace-cmd"><a class="markdownIt-Anchor" href="#install-trace-cmd"></a> Install trace-cmd</h1>
<p>还算顺利，大部分依赖包从系统 apt 源里都能安装，但也有一些问题</p>
<ul>
<li><code>/usr/lib64/pkgconfig</code> 没有在 <code>pkg-config</code> 默认的 search paths 里
<ul>
<li><code>export PKG_CONFIG_PTH=/usr/lib64/pkgconfig</code> 可解决构建问题</li>
</ul>
</li>
<li><code>/usr/lib64</code> 没有在 <code>ld.so</code> 的默认的 search paths 里
<ul>
<li><code>/etc/ld.so.conf.d/x86_64-linux-gnu.conf</code> 里增加 <code>/usr/lib64</code> 可解决运行时找不到 shared library 的问题</li>
</ul>
</li>
<li>因为 xmlto 的依赖问题无法安装，幸好它只是用来构建 Documentation, 通过 <code>-Ddoc=false</code> 不构建就可以继续下去</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Dependency</th>
<th style="text-align:center">Apt Install</th>
<th style="text-align:left">Problem</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">meson</td>
<td style="text-align:center">√</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">cmake</td>
<td style="text-align:center">√</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">asciidoc</td>
<td style="text-align:center">√</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">xmlto</td>
<td style="text-align:center">∅</td>
<td style="text-align:left">docbook unmet</td>
</tr>
<tr>
<td style="text-align:left">flex</td>
<td style="text-align:center">√</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">bison</td>
<td style="text-align:center">√</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">libaudit-dev</td>
<td style="text-align:center">√</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h1 id="install-apitrace"><a class="markdownIt-Anchor" href="#install-apitrace"></a> Install apitrace</h1>
<p>apitrace 不带 GUI 的话可以非常顺利的安装，带 GUI 的话因为依赖 Qt5/6, 稍微麻烦一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (ENABLE_GUI)</span><br><span class="line">    if (NOT (ENABLE_GUI STREQUAL &quot;AUTO&quot;))</span><br><span class="line">        set (REQUIRE_GUI REQUIRED)</span><br><span class="line">    endif ()</span><br><span class="line">    if (POLICY CMP0020)</span><br><span class="line">        cmake_policy (SET CMP0020 NEW)</span><br><span class="line">    endif()</span><br><span class="line">    if (ENABLE_QT6)</span><br><span class="line">        find_package (Qt6 COMPONENTS Widgets Network $&#123;REQUIRE_GUI&#125;)</span><br><span class="line">    else ()</span><br><span class="line">        find_package (Qt5 5.15 COMPONENTS Widgets Network $&#123;REQUIRE_GUI&#125;)</span><br><span class="line">    endif ()</span><br><span class="line">endif ()</span><br></pre></td></tr></table></figure>
<h2 id="install-qt"><a class="markdownIt-Anchor" href="#install-qt"></a> Install Qt</h2>
<p>一开始通过 <a href="https://www.qt.io/download-qt-installer-oss">qt-online-installer-linux-x64-4.8.1.run</a> 安装 Qt 6.8, 安装后 cmake <code>find_package</code> 还是有问题，就只能源码安装 <a href="https://download.qt.io/archive/qt/5.15/">qt 5.15.16</a></p>
<ul>
<li><code>mkdir -p /opt/Qt5.15</code></li>
<li><code>mkdir -p ~/qt-build</code></li>
<li><code>cd ~/qt-build</code></li>
<li><code>~/qt-everywhere-src-5.15.16/configure -prefix /opt/Qt5.15</code></li>
<li><code>make -j $(nproc)</code></li>
<li><code>sudo make install</code></li>
</ul>
<p>Qt 5.15.16 安装完成后就可以继续安装 qapitrace 了</p>
<ul>
<li><code>cd ~/apitrace</code></li>
<li><code>cmake -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_MODULE_PATH=/opt/Qt5.15/lib/pkgconfig</code></li>
<li><code>sudo cmake --install build</code></li>
</ul>
<p>可惜安装后运行 <code>qapitrace glxgears.trace</code> 报段错误，难道是 Qt 的版本太高了?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UKUIStylePlugin.........</span><br><span class="line">QObject::connect: No such slot UKUIStylePlugin::tableModeChanged(bool)</span><br><span class="line">BlurHelper00000.............</span><br><span class="line">m_cfgPath... &quot;/usr/share/qt5-ukui-platformtheme/themeconfig/default.json&quot;</span><br><span class="line">段错误</span><br></pre></td></tr></table></figure>
<p>将 <code>/opt/Qt5.15/lib</code> 添加到 ld.so.conf 后又报出下面的错误, 提示 Qt 缺少 <strong>wayland, xcb platform plugin</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qt.qpa.plugin: Could not find the Qt platform plugin &quot;wayland&quot; in &quot;&quot;</span><br><span class="line">qt.qpa.plugin: Could not find the Qt platform plugin &quot;xcb&quot; in &quot;&quot;</span><br><span class="line">This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.</span><br><span class="line"></span><br><span class="line">Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, webgl.</span><br><span class="line"></span><br><span class="line">已放弃</span><br></pre></td></tr></table></figure>
<p>所以检查编译配置，发现 <strong>QPA backends</strong> 中的 EGLFS 虽然打开了，但 EGLFS details 里所有的后端一个也没有打开， 阅读 <a href="https://doc.qt.io/qt-6/embedded-linux.html#eglfs">EGLFS 的文档</a> 后了解到 EGLFS 似乎是运行在 EGL 和 OpenGL ES 2.0 之上， 但 <strong>Qt Gui</strong> 里的 OpenGL ES 2.0/3.0/3.1/3.2 都没有开启， 还有 <strong>XCB Xlib</strong> 也没有开启。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Qt Gui:</span><br><span class="line">  Accessibility .......................... yes</span><br><span class="line">  FreeType ............................... yes</span><br><span class="line">    Using system FreeType ................ yes</span><br><span class="line">  HarfBuzz ............................... yes</span><br><span class="line">    Using system HarfBuzz ................ no</span><br><span class="line">  Fontconfig ............................. yes</span><br><span class="line">  Image formats:</span><br><span class="line">    GIF .................................. yes</span><br><span class="line">    ICO .................................. yes</span><br><span class="line">    JPEG ................................. yes</span><br><span class="line">      Using system libjpeg ............... yes</span><br><span class="line">    PNG .................................. yes</span><br><span class="line">      Using system libpng ................ yes</span><br><span class="line">  Text formats:</span><br><span class="line">    HtmlParser ........................... yes</span><br><span class="line">    CssParser ............................ yes</span><br><span class="line">    OdfWriter ............................ yes</span><br><span class="line">    MarkdownReader ....................... yes</span><br><span class="line">      Using system libmd4c ............... no</span><br><span class="line">    MarkdownWriter ....................... yes</span><br><span class="line">  EGL .................................... yes</span><br><span class="line">  OpenVG ................................. no</span><br><span class="line">  OpenGL:</span><br><span class="line">    Desktop OpenGL ....................... yes</span><br><span class="line">    OpenGL ES 2.0 ........................ no</span><br><span class="line">    OpenGL ES 3.0 ........................ no</span><br><span class="line">    OpenGL ES 3.1 ........................ no</span><br><span class="line">    OpenGL ES 3.2 ........................ no</span><br><span class="line">  Vulkan ................................. no</span><br><span class="line">  Session Management ..................... yes</span><br><span class="line">Features used by QPA backends:</span><br><span class="line">  evdev .................................. yes</span><br><span class="line">  libinput ............................... no</span><br><span class="line">  INTEGRITY HID .......................... no</span><br><span class="line">  mtdev .................................. no</span><br><span class="line">  tslib .................................. no</span><br><span class="line">  xkbcommon .............................. no</span><br><span class="line">  X11 specific:</span><br><span class="line">    XLib ................................. yes</span><br><span class="line">    XCB Xlib ............................. no</span><br><span class="line">    EGL on X11 ........................... no</span><br><span class="line">    xkbcommon-x11 ........................ no</span><br><span class="line">QPA backends:</span><br><span class="line">  DirectFB ............................... no</span><br><span class="line">  EGLFS .................................. yes</span><br><span class="line">  EGLFS details:</span><br><span class="line">    EGLFS OpenWFD ........................ no</span><br><span class="line">    EGLFS i.Mx6 .......................... no</span><br><span class="line">    EGLFS i.Mx6 Wayland .................. no</span><br><span class="line">    EGLFS RCAR ........................... no</span><br><span class="line">    EGLFS EGLDevice ...................... no</span><br><span class="line">    EGLFS GBM ............................ no</span><br><span class="line">    EGLFS VSP2 ........................... no</span><br><span class="line">    EGLFS Mali ........................... no</span><br><span class="line">    EGLFS Raspberry Pi ................... no</span><br><span class="line">    EGLFS X11 ............................ no</span><br><span class="line">  LinuxFB ................................ yes</span><br><span class="line">  VNC .................................... yes</span><br></pre></td></tr></table></figure>
<p>所以继续阅读 <a href="https://doc.qt.io/qt-6/linux-requirements.html">Qt for X11 requirements</a> 文档, 安装文档中所有列出的依赖软件包后， 重新编译 Qt 5.15.16, 这次 qapitrace 运行正常，而且之前报出的缺少 <strong>Qt Platform plugin “xcb” in “”</strong> 也消失了</p>
<p><img src="/images/ok/apitrace.png" alt="qapitrace" /></p>
<h2 id="pal"><a class="markdownIt-Anchor" href="#pal"></a> PAL</h2>
<p>Qt Platform Abstraction (QPA) 是 Qt 中主要的<strong>平台抽象层 (Platform Abstraction Layer)</strong>, PAL 这个概念在 <a href="https://github.com/GPUOpen-Drivers/pal">AMD GPU 驱动</a>中也有， 在 Android 里也有类似的 HAL (Hardware Abstraction Layer) 的概念，在系统软件设计中， PAL 的作用可谓是&quot;承上启下&quot;， 设计一个<strong>接口稳定，易于扩展</strong>的 PAL API 是整个用户态系统软件实现效率的关键。通过这次安装 Qt, 又多了一个学习的例子。</p>
<h1 id="openkylinlinux-66-next"><a class="markdownIt-Anchor" href="#openkylinlinux-66-next"></a> <a href="https://gitee.com/openkylin/linux/tree/linux-6.6-next">openKylin:linux-6.6-next</a></h1>
<p>主要关注了一下国产 GPU/DRM 驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./omapdrm</span><br><span class="line">./nouveau</span><br><span class="line">./mxsfb</span><br><span class="line">./mwv207 # 景嘉微 0x0731</span><br><span class="line">./msm</span><br><span class="line">./mgag200</span><br><span class="line">./meson</span><br><span class="line">./mediatek</span><br><span class="line">./mcde</span><br><span class="line">./loongson # 龙芯 0x0014</span><br><span class="line">./logicvc</span><br><span class="line">./lima</span><br><span class="line">./lib</span><br><span class="line">./kmb</span><br><span class="line">./ingenic</span><br><span class="line">./imx</span><br><span class="line">./i915</span><br><span class="line">./i2c</span><br><span class="line">./hyperv</span><br><span class="line">./hisilicon</span><br><span class="line">./gud</span><br><span class="line">./gma500</span><br><span class="line">./fsl-dcu</span><br><span class="line">./exynos</span><br><span class="line">./etnaviv</span><br><span class="line">./display</span><br><span class="line">./ci</span><br><span class="line">./bridge</span><br><span class="line">./atmel-hlcdc</span><br><span class="line">./ast</span><br><span class="line">./aspeed</span><br><span class="line">./armada</span><br><span class="line">./arm</span><br><span class="line">./arise  # 格兰菲 0x6766</span><br><span class="line">./amd</span><br><span class="line">.</span><br><span class="line">➜  drm git:(linux-6.6-next)</span><br></pre></td></tr></table></figure>
<h1 id="redeclipse"><a class="markdownIt-Anchor" href="#redeclipse"></a> <a href="https://github.com/redeclipse/base">RedEclipse</a></h1>
<p><img src="/images/ok/nv137-redeclipse.png" alt="RedEclipse on NV137" /></p>
<h1 id="kylin-wayland-compositor"><a class="markdownIt-Anchor" href="#kylin-wayland-compositor"></a> <a href="https://gitee.com/openkylin/kylin-wayland-compositor">kylin-wayland-compositor</a></h1>
<p>kylin-wayland-compositor 的二进制程序是 <code>kylin-wlcom</code>, 它的启动配置在</p>
<figure class="highlight txt"><figcaption><span>/usr/share/wayland-sessions/kylin-wlcom.desktop</span></figcaption><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Kylin Wlcom</span><br><span class="line">Comment=The Kylin Wayland Compositor</span><br><span class="line">Exec=kylin-wlcom -s ukui-session</span><br><span class="line">Type=Application</span><br></pre></td></tr></table></figure>
<p><code>/usr/bin/ukui-session</code> 这个二进制程序会拉起很多应用程序</p>
<figure class="highlight bash"><figcaption><span>pstree -p -t 3768</span></figcaption><table><tr><td class="code"><pre><span class="line">ukui-session(3768)-+-KylinTreasureBo(4259)-+-&#123;KylinTreasureBo&#125;(4279)</span><br><span class="line">                   |                       `-&#123;QDBusConnection&#125;(5164)</span><br><span class="line">                   |-NotifySend(4790)-+-&#123;QDBusConnection&#125;(4955)</span><br><span class="line">                   |                  |-&#123;QThread&#125;(5270)</span><br><span class="line">                   |                  |-&#123;WaylandEventThr&#125;(5190)</span><br><span class="line">                   |                  |-&#123;WaylandEventThr&#125;(5191)</span><br><span class="line">                   |                  |-&#123;dconf worker&#125;(5187)</span><br><span class="line">                   |                  |-&#123;gdbus&#125;(5194)</span><br><span class="line">                   |                  |-&#123;gmain&#125;(5186)</span><br><span class="line">                   |                  `-&#123;pool-spawner&#125;(5176)</span><br><span class="line">                   |-conf2-session-s(3976)</span><br><span class="line">                   |-fcitx5(4137)-+-&#123;fcitx5&#125;(4214)</span><br><span class="line">                   |              |-&#123;fcitx5&#125;(4223)</span><br><span class="line">                   |              |-&#123;fcitx5&#125;(4939)</span><br><span class="line">                   |              |-&#123;fcitx5&#125;(5105)</span><br><span class="line">                   |              `-&#123;fcitx5&#125;(5106)</span><br><span class="line">                   |-ksc-virus-dialo(4180)-+-&#123;CAuthDialogThre&#125;(5750)</span><br><span class="line">                   |                       |-&#123;QDBusConnection&#125;(4219)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4269)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4270)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4268)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4274)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4267)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4266)</span><br><span class="line">                   |-kylin-activatio(4782)-+-&#123;QDBusConnection&#125;(10066)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(10065)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(10067)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(10064)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(10063)</span><br><span class="line">                   |-kylin-calendar(4131)-+-&#123;QDBusConnection&#125;(4184)</span><br><span class="line">                   |                      |-&#123;WaylandEventThr&#125;(4296)</span><br><span class="line">                   |                      |-&#123;WaylandEventThr&#125;(4297)</span><br><span class="line">                   |                      |-&#123;gdbus&#125;(4305)</span><br><span class="line">                   |                      |-&#123;gmain&#125;(4293)</span><br><span class="line">                   |                      `-&#123;pool-spawner&#125;(4292)</span><br><span class="line">                   |-kylin-device-da(4233)-+-&#123;QDBusConnection&#125;(5060)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(4987)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5324)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5325)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4985)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4344)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4341)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4340)</span><br><span class="line">                   |-kylin-nm(4237)-+-&#123;QDBusConnection&#125;(4638)</span><br><span class="line">                   |                |-&#123;QThread&#125;(4584)</span><br><span class="line">                   |                |-&#123;QThread&#125;(5167)</span><br><span class="line">                   |                |-&#123;WaylandEventThr&#125;(5012)</span><br><span class="line">                   |                |-&#123;WaylandEventThr&#125;(5013)</span><br><span class="line">                   |                |-&#123;dconf worker&#125;(4583)</span><br><span class="line">                   |                |-&#123;gdbus&#125;(4622)</span><br><span class="line">                   |                |-&#123;gmain&#125;(4582)</span><br><span class="line">                   |                `-&#123;pool-spawner&#125;(4581)</span><br><span class="line">                   |-kylin-os-manage(4371)---&#123;QDBusConnection&#125;(4442)</span><br><span class="line">                   |-kylin-printer-a(4242)-+-&#123;DeviceMonitorBa&#125;(5236)</span><br><span class="line">                   |                       |-&#123;LaunchPrinter&#125;(5235)</span><br><span class="line">                   |                       |-&#123;PopWindowManage&#125;(5237)</span><br><span class="line">                   |                       |-&#123;QDBusConnection&#125;(4496)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(5230)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(5231)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(5250)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(5701)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4881)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4882)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4875)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4895)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4873)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4867)</span><br><span class="line">                   |-kylin-updatefin(4282)</span><br><span class="line">                   |-kylin-virtual-k(4308)-+-&#123;QDBusConnection&#125;(4543)</span><br><span class="line">                   |                       |-&#123;QXcbEventQueue&#125;(4462)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4542)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4545)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4541)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4540)</span><br><span class="line">                   |-kylin-vpn(4313)-+-&#123;QDBusConnection&#125;(4710)</span><br><span class="line">                   |                 |-&#123;QThread&#125;(4664)</span><br><span class="line">                   |                 |-&#123;QThread&#125;(5142)</span><br><span class="line">                   |                 |-&#123;WaylandEventThr&#125;(5024)</span><br><span class="line">                   |                 |-&#123;WaylandEventThr&#125;(5025)</span><br><span class="line">                   |                 |-&#123;dconf worker&#125;(4663)</span><br><span class="line">                   |                 |-&#123;gdbus&#125;(4701)</span><br><span class="line">                   |                 |-&#123;gmain&#125;(4662)</span><br><span class="line">                   |                 `-&#123;pool-spawner&#125;(4661)</span><br><span class="line">                   |-kylin-weather-c(4316)-+-&#123;QDBusConnection&#125;(4463)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4651)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4652)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4650)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4660)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4649)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4648)</span><br><span class="line">                   |-mm-notify(4329)</span><br><span class="line">                   |-peony-qt-deskto(4014)-+-&#123;QDBusConnection&#125;(4141)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(4126)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(5152)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4339)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4347)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4124)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4136)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4123)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4122)</span><br><span class="line">                   |-polkit-ukui-aut(4338)-+-&#123;QDBusConnection&#125;(5389)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(5377)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5519)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5520)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(5375)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(5387)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(5374)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(5373)</span><br><span class="line">                   |-sdk-date(4326)---&#123;sdk-date&#125;(4368)</span><br><span class="line">                   |-sdk-powermanage(4322)-+-&#123;dconf worker&#125;(4422)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4441)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4421)</span><br><span class="line">                   |                       |-&#123;pool-spawner&#125;(4420)</span><br><span class="line">                   |                       `-&#123;sdk-powermanage&#125;(4389)</span><br><span class="line">                   |-secRiskBox(4362)-+-&#123;QDBusConnection&#125;(4508)</span><br><span class="line">                   |                  |-&#123;WaylandEventThr&#125;(4815)</span><br><span class="line">                   |                  |-&#123;WaylandEventThr&#125;(4816)</span><br><span class="line">                   |                  |-&#123;dconf worker&#125;(4814)</span><br><span class="line">                   |                  |-&#123;gdbus&#125;(4824)</span><br><span class="line">                   |                  |-&#123;gmain&#125;(4813)</span><br><span class="line">                   |                  `-&#123;pool-spawner&#125;(4812)</span><br><span class="line">                   |-sound-theme-pla(4390)-+-&#123;QDBusConnection&#125;(4440)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(4439)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4438)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4461)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4437)</span><br><span class="line">                   |                       |-&#123;pool-spawner&#125;(4436)</span><br><span class="line">                   |                       `-&#123;threaded-ml&#125;(10096)</span><br><span class="line">                   |-sync-config-ses(4132)-+-&#123;dconf worker&#125;(4149)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4153)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4148)</span><br><span class="line">                   |                       |-&#123;pool-spawner&#125;(4147)</span><br><span class="line">                   |                       `-&#123;sync-config-ses&#125;(4158)</span><br><span class="line">                   |-ukui-appwidget-(3985)-+-&#123;QDBusConnection&#125;(3998)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4027)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4028)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4026)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4030)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4025)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4024)</span><br><span class="line">                   |-ukui-bluetooth(4464)-+-&#123;QDBusConnection&#125;(5251)</span><br><span class="line">                   |                      |-&#123;QThread&#125;(5184)</span><br><span class="line">                   |                      |-&#123;WaylandEventThr&#125;(5337)</span><br><span class="line">                   |                      |-&#123;WaylandEventThr&#125;(5338)</span><br><span class="line">                   |                      |-&#123;dconf worker&#125;(5170)</span><br><span class="line">                   |                      |-&#123;gdbus&#125;(5173)</span><br><span class="line">                   |                      |-&#123;gmain&#125;(5169)</span><br><span class="line">                   |                      `-&#123;pool-spawner&#125;(5168)</span><br><span class="line">                   |-ukui-menu(17330)-+-&#123;BatchProcess&#125;(17365)</span><br><span class="line">                   |                  |-&#123;BatchProcess&#125;(17366)</span><br><span class="line">                   |                  |-&#123;BatchProcess&#125;(17368)</span><br><span class="line">                   |                  |-&#123;BatchProcess&#125;(17369)</span><br><span class="line">                   |                  |-&#123;QDBusConnection&#125;(17331)</span><br><span class="line">                   |                  |-&#123;QQmlThread&#125;(17341)</span><br><span class="line">                   |                  |-&#123;QSGRenderThread&#125;(17371)</span><br><span class="line">                   |                  |-&#123;QThread&#125;(17342)</span><br><span class="line">                   |                  |-&#123;QThread&#125;(271464)</span><br><span class="line">                   |                  |-&#123;WaylandEventThr&#125;(17335)</span><br><span class="line">                   |                  |-&#123;WaylandEventThr&#125;(17337)</span><br><span class="line">                   |                  |-&#123;dconf worker&#125;(17334)</span><br><span class="line">                   |                  |-&#123;gdbus&#125;(17336)</span><br><span class="line">                   |                  |-&#123;gmain&#125;(17333)</span><br><span class="line">                   |                  |-&#123;pool-spawner&#125;(17332)</span><br><span class="line">                   |                  |-&#123;ukui-menu&#125;(17367)</span><br><span class="line">                   |                  `-&#123;ukui-menu&#125;(17370)</span><br><span class="line">                   |-ukui-panel(271872)-+-&#123;BatchProcess&#125;(271903)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(271904)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(271906)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(271907)</span><br><span class="line">                   |                    |-&#123;QDBusConnection&#125;(271873)</span><br><span class="line">                   |                    |-&#123;QQmlThread&#125;(271882)</span><br><span class="line">                   |                    |-&#123;QSGRenderThread&#125;(271909)</span><br><span class="line">                   |                    |-&#123;WaylandEventThr&#125;(271877)</span><br><span class="line">                   |                    |-&#123;WaylandEventThr&#125;(271878)</span><br><span class="line">                   |                    |-&#123;dconf worker&#125;(271876)</span><br><span class="line">                   |                    |-&#123;gdbus&#125;(271879)</span><br><span class="line">                   |                    |-&#123;gmain&#125;(271875)</span><br><span class="line">                   |                    |-&#123;pool-spawner&#125;(271874)</span><br><span class="line">                   |                    |-&#123;ukui-panel&#125;(271905)</span><br><span class="line">                   |                    `-&#123;ukui-panel&#125;(271908)</span><br><span class="line">                   |-ukui-powermanag(4520)-+-&#123;QDBusConnection&#125;(4872)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(4721)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5053)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5054)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4720)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4743)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4719)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4718)</span><br><span class="line">                   |-ukui-screensave(3992)-+-ukui-screensave(14606)-+-&#123;QDBusConnection&#125;(14617)</span><br><span class="line">                   |                       |                        |-&#123;QThread&#125;(14614)</span><br><span class="line">                   |                       |                        |-&#123;QThread&#125;(14635)</span><br><span class="line">                   |                       |                        |-&#123;WaylandEventThr&#125;(14621)</span><br><span class="line">                   |                       |                        |-&#123;WaylandEventThr&#125;(14622)</span><br><span class="line">                   |                       |                        |-&#123;dconf worker&#125;(14612)</span><br><span class="line">                   |                       |                        |-&#123;gdbus&#125;(14613)</span><br><span class="line">                   |                       |                        |-&#123;gmain&#125;(14611)</span><br><span class="line">                   |                       |                        `-&#123;pool-spawner&#125;(14610)</span><br><span class="line">                   |                       |-&#123;QDBusConnection&#125;(4019)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(4018)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4017)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4016)</span><br><span class="line">                   |                       |-&#123;pool-spawner&#125;(4015)</span><br><span class="line">                   |                       `-&#123;ukui-screensave&#125;(5094)</span><br><span class="line">                   |-ukui-search(4573)-+-&#123;QDBusConnection&#125;(5395)</span><br><span class="line">                   |                   |-&#123;WaylandEventThr&#125;(5450)</span><br><span class="line">                   |                   |-&#123;WaylandEventThr&#125;(5451)</span><br><span class="line">                   |                   |-&#123;dconf worker&#125;(5449)</span><br><span class="line">                   |                   |-&#123;gdbus&#125;(5454)</span><br><span class="line">                   |                   |-&#123;gmain&#125;(5448)</span><br><span class="line">                   |                   `-&#123;pool-spawner&#125;(5447)</span><br><span class="line">                   |-ukui-search-app(4539)-+-&#123;QDBusConnection&#125;(4838)</span><br><span class="line">                   |                       |-&#123;UkuiSearch::Pen&#125;(5380)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5082)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5083)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(5079)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(5086)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(5068)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(5066)</span><br><span class="line">                   |-ukui-search-ser(4549)-+-&#123;QDBusConnection&#125;(5317)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5393)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5394)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(5391)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(5396)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(5390)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(5388)</span><br><span class="line">                   |-ukui-search-ser(4562)-+-&#123;QDBusConnection&#125;(5331)</span><br><span class="line">                   |                       |-&#123;UkuiSearch::Pen&#125;(5626)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5594)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5595)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(5593)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(5597)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(5592)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(5590)</span><br><span class="line">                   |-ukui-settings-d(3993)-+-&#123;QDBusConnection&#125;(4023)</span><br><span class="line">                   |                       |-&#123;QNetworkAccessM&#125;(5951)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(5421)</span><br><span class="line">                   |                       |-&#123;Qt bearer threa&#125;(5860)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4072)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4073)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4071)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4606)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4074)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4070)</span><br><span class="line">                   |                       |-&#123;pool-spawner&#125;(4069)</span><br><span class="line">                   |                       `-&#123;threaded-ml&#125;(4351)</span><br><span class="line">                   |-ukui-sidebar(4586)-+-&#123;BatchProcess&#125;(6392)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(6393)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(6395)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(6396)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(6417)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(6419)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(6421)</span><br><span class="line">                   |                    |-&#123;BatchProcess&#125;(6422)</span><br><span class="line">                   |                    |-&#123;QDBusConnection&#125;(5047)</span><br><span class="line">                   |                    |-&#123;QQmlThread&#125;(5983)</span><br><span class="line">                   |                    |-&#123;QSGRenderThread&#125;(6398)</span><br><span class="line">                   |                    |-&#123;QSGRenderThread&#125;(6425)</span><br><span class="line">                   |                    |-&#123;QThread&#125;(6034)</span><br><span class="line">                   |                    |-&#123;WaylandEventThr&#125;(5610)</span><br><span class="line">                   |                    |-&#123;WaylandEventThr&#125;(5611)</span><br><span class="line">                   |                    |-&#123;dconf worker&#125;(5609)</span><br><span class="line">                   |                    |-&#123;gdbus&#125;(5619)</span><br><span class="line">                   |                    |-&#123;gmain&#125;(5608)</span><br><span class="line">                   |                    |-&#123;pool-spawner&#125;(5607)</span><br><span class="line">                   |                    |-&#123;ukui-sidebar&#125;(6394)</span><br><span class="line">                   |                    |-&#123;ukui-sidebar&#125;(6397)</span><br><span class="line">                   |                    |-&#123;ukui-sidebar&#125;(6420)</span><br><span class="line">                   |                    `-&#123;ukui-sidebar&#125;(6423)</span><br><span class="line">                   |-ukui-sni-watche(3997)---&#123;QDBusConnection&#125;(3999)</span><br><span class="line">                   |-ukui-volume-con(4609)-+-&#123;QDBusConnection&#125;(5137)</span><br><span class="line">                   |                       |-&#123;QThread&#125;(5065)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5329)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(5330)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(5064)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(5067)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(5063)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(5062)</span><br><span class="line">                   |-ukui-window-swi(4635)---ukui-window-swi(4796)-+-&#123;QDBusConnection&#125;(5030)</span><br><span class="line">                   |                                               |-&#123;WaylandEventThr&#125;(5221)</span><br><span class="line">                   |                                               |-&#123;WaylandEventThr&#125;(5222)</span><br><span class="line">                   |                                               |-&#123;dconf worker&#125;(5217)</span><br><span class="line">                   |                                               |-&#123;gdbus&#125;(5225)</span><br><span class="line">                   |                                               |-&#123;gmain&#125;(5216)</span><br><span class="line">                   |                                               `-&#123;pool-spawner&#125;(5215)</span><br><span class="line">                   |-ukuismserver(3914)-+-&#123;QDBusConnection&#125;(3945)</span><br><span class="line">                   |                    |-&#123;WaylandEventThr&#125;(3968)</span><br><span class="line">                   |                    |-&#123;WaylandEventThr&#125;(3970)</span><br><span class="line">                   |                    |-&#123;dconf worker&#125;(3962)</span><br><span class="line">                   |                    |-&#123;gdbus&#125;(3963)</span><br><span class="line">                   |                    |-&#123;gmain&#125;(3961)</span><br><span class="line">                   |                    `-&#123;pool-spawner&#125;(3960)</span><br><span class="line">                   |-user-guide-daem(4304)-+-&#123;QDBusConnection&#125;(4470)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4731)</span><br><span class="line">                   |                       |-&#123;WaylandEventThr&#125;(4732)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4730)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4757)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4729)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4728)</span><br><span class="line">                   |-user_cmd(4659)</span><br><span class="line">                   |-xembed-sni-prox(4004)-+-&#123;QDBusConnection&#125;(4231)</span><br><span class="line">                   |                       |-&#123;QXcbEventQueue&#125;(4174)</span><br><span class="line">                   |                       |-&#123;dconf worker&#125;(4229)</span><br><span class="line">                   |                       |-&#123;gdbus&#125;(4232)</span><br><span class="line">                   |                       |-&#123;gmain&#125;(4228)</span><br><span class="line">                   |                       `-&#123;pool-spawner&#125;(4227)</span><br><span class="line">                   |-&#123;QDBusConnection&#125;(3791)</span><br><span class="line">                   |-&#123;WaylandEventThr&#125;(3806)</span><br><span class="line">                   |-&#123;WaylandEventThr&#125;(3807)</span><br><span class="line">                   |-&#123;dconf worker&#125;(3812)</span><br><span class="line">                   |-&#123;gdbus&#125;(3814)</span><br><span class="line">                   |-&#123;gmain&#125;(3811)</span><br><span class="line">                   `-&#123;pool-spawner&#125;(3810)</span><br></pre></td></tr></table></figure>
<h1 id="hyprland"><a class="markdownIt-Anchor" href="#hyprland"></a> <a href="git@github.com:hyprwm/Hyprland.git">Hyprland</a></h1>
<h2 id="dependencies"><a class="markdownIt-Anchor" href="#dependencies"></a> Dependencies</h2>
<table>
<thead>
<tr>
<th style="text-align:left">dep</th>
<th style="text-align:left">apt-get</th>
<th style="text-align:left">version required</th>
<th style="text-align:left">yet another install</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">wayland-protocols</td>
<td style="text-align:left">wayland-protocols</td>
<td style="text-align:left">1.38-ok1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">libseat</td>
<td style="text-align:left">libseat-dev</td>
<td style="text-align:left">0.8.0-ok2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">libinput</td>
<td style="text-align:left">libinput-dev</td>
<td style="text-align:left">1.26.0(1.25.0-ok1.2)</td>
<td style="text-align:left"><a href="https://gitlab.freedesktop.org/libinput/libinput">https://gitlab.freedesktop.org/libinput/libinput</a></td>
</tr>
<tr>
<td style="text-align:left">wayland</td>
<td style="text-align:left">libwayland-dev</td>
<td style="text-align:left">1.23.0-1ok3</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">libdisplay-info</td>
<td style="text-align:left">libdisplay-info-dev</td>
<td style="text-align:left">0.1.1-ok1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">aquamarine</td>
<td style="text-align:left"></td>
<td style="text-align:left">&gt;=0.4.5</td>
<td style="text-align:left"><a href="https://github.com/hyprwm/aquamarine">https://github.com/hyprwm/aquamarine</a></td>
</tr>
<tr>
<td style="text-align:left">hyprwayland-scanner</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://github.com/hyprwm/hyprwayland-scanner">https://github.com/hyprwm/hyprwayland-scanner</a></td>
</tr>
<tr>
<td style="text-align:left">pugixml</td>
<td style="text-align:left">libpugixml-dev</td>
<td style="text-align:left">1.14-ok1</td>
<td style="text-align:left">required by hyprwayland-scanner</td>
</tr>
<tr>
<td style="text-align:left">hyprutils</td>
<td style="text-align:left"></td>
<td style="text-align:left">&gt;=0.2.3</td>
<td style="text-align:left"><a href="https://github.com/hyprwm/hyprutils">https://github.com/hyprwm/hyprutils</a></td>
</tr>
</tbody>
</table>
<pre><code class="highlight mermaid">mindmap
  root(hyprland)
    aquamarine=0.4.5
      libseat=0.8.0
      libinput10 1.26.0&lt;br&gt;1.25.0-ok1
        libudev&lt;br&gt;255.2
          systemd
            libcap-dev
            gperf
        libmtdev1 1.1.6&lt;br&gt;1.1.5
        libevdev 1.13.1&lt;br&gt;1.12.1
      hyprwayland-scanner=0.4.0
      hyprutils=0.2.3
      wayland-protocols
      wayland-client
      libdisplay-info
        pugixml
      libdrm
      gbm
      pixman-1
      hwdata</code></pre>
<p>在 openKylin 2.0 上折腾(编译) Hyprland 遇到的两个问题是：</p>
<ul>
<li>openKylin 的 APT 源里 development files 包和 library 包有很多版本不匹配的，导致 <a href="https://gitee.com/openkylin/release-management/issues/IBLF9O"><strong>apt-get install libxxx-dev</strong></a> 失败</li>
<li>hyprland 对 C++ 版本的要求太高了 (<strong>c++26</strong>), 这导致很多问题， 不仅需要升级编译器 (llvm 19.1.7), 甚至连 meson 都有刚刚不久才修复的跟 c++26 有关的 <a href="https://github.com/mesonbuild/meson/pull/14139">Bug</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  aquamarine git:(0.7.1) ✗ CC=clang CXX=clang++ cmake -B build -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_INSTALL_LIBDIR=lib/x86_64-linux-gnu -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=<span class="string">&quot;-stdlib=libc++&quot;</span></span><br><span class="line">-- Checking <span class="keyword">for</span> modules <span class="string">&#x27;libseat&gt;=0.8.0;libinput&gt;=1.26.0;wayland-client;wayland-protocols;hyprutils&gt;=0.2.3;pixman-1;libdrm;gbm;libudev;libdisplay-info;hwdata&#x27;</span></span><br><span class="line">--   Package <span class="string">&#x27;libseat&#x27;</span>, required by <span class="string">&#x27;virtual:world&#x27;</span>, not found</span><br><span class="line">--   Package <span class="string">&#x27;libinput&#x27;</span>, required by <span class="string">&#x27;virtual:world&#x27;</span>, not found</span><br><span class="line">--   Package <span class="string">&#x27;wayland-client&#x27;</span>, required by <span class="string">&#x27;virtual:world&#x27;</span>, not found</span><br><span class="line">--   Package <span class="string">&#x27;wayland-protocols&#x27;</span>, required by <span class="string">&#x27;virtual:world&#x27;</span>, not found</span><br><span class="line">--   Package <span class="string">&#x27;libdrm&#x27;</span>, required by <span class="string">&#x27;virtual:world&#x27;</span>, not found</span><br><span class="line">--   Package <span class="string">&#x27;gbm&#x27;</span>, required by <span class="string">&#x27;virtual:world&#x27;</span>, not found</span><br><span class="line">--   Package <span class="string">&#x27;libdisplay-info&#x27;</span>, required by <span class="string">&#x27;virtual:world&#x27;</span>, not found</span><br></pre></td></tr></table></figure>
<h1 id="kernel-linux-660-150ok9"><a class="markdownIt-Anchor" href="#kernel-linux-660-150ok9"></a> Kernel (linux-6.6.0-15.0ok9)</h1>
<p><a href="https://build.openkylin.top/openkylin/+source/linux/6.6.0-15.0ok9">下载</a> 以下源码包</p>
<ul>
<li><a href="https://build.openkylin.top/openkylin/+archive/primary/+sourcefiles/linux/6.6.0-15.0ok9/linux_6.6.0.orig.tar.gz">linux_6.6.0.orig.tar.gz</a></li>
<li><a href="https://build.openkylin.top/openkylin/+archive/primary/+sourcefiles/linux/6.6.0-15.0ok9/linux_6.6.0-15.0ok9.debian.tar.xz">linux_6.6.0-15.0ok9.debian.tar.xz</a></li>
<li><a href="https://build.openkylin.top/openkylin/+archive/primary/+sourcefiles/linux/6.6.0-15.0ok9/linux_6.6.0-15.0ok9.dsc">linux_6.6.0-15.0ok9.dsc</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg-source -x linux_6.6.0-15.0ok9.dsc</span><br><span class="line"><span class="built_in">cd</span> linux-6.6.0</span><br><span class="line">fakeroot debian/rules binary</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  LD      .tmp_vmlinux.btf</span><br><span class="line">  BTF     .btf.vmlinux.bin.o</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">Reached the limit of per-CPU variables: 4096</span><br><span class="line">  LD      .tmp_vmlinux.kallsyms1</span><br><span class="line">  NM      .tmp_vmlinux.kallsyms1.syms</span><br><span class="line">  KSYMS   .tmp_vmlinux.kallsyms1.S</span><br><span class="line">  AS      .tmp_vmlinux.kallsyms1.o</span><br><span class="line">  LD      .tmp_vmlinux.kallsyms2</span><br><span class="line">  NM      .tmp_vmlinux.kallsyms2.syms</span><br><span class="line">  KSYMS   .tmp_vmlinux.kallsyms2.S</span><br><span class="line">  AS      .tmp_vmlinux.kallsyms2.o</span><br><span class="line">  LD      vmlinux</span><br><span class="line">  BTFIDS  vmlinux</span><br><span class="line">libbpf: failed to find &#x27;.BTF&#x27; ELF section in vmlinux</span><br><span class="line">FAILED: load BTF from vmlinux: No data available</span><br><span class="line">make[4]: *** [/home/luc/linux-6.6.0/scripts/Makefile.vmlinux:37: vmlinux] Error 255</span><br><span class="line">make[4]: *** Deleting file &#x27;vmlinux&#x27;</span><br><span class="line">make[3]: *** [/home/luc/linux-6.6.0/Makefile:1178: vmlinux] Error 2</span><br><span class="line">make[2]: *** [/home/luc/linux-6.6.0/Makefile:236: __sub-make] Error 2</span><br><span class="line">make[2]: Leaving directory &#x27;/home/luc/linux-6.6.0/debian/build/build-generic&#x27;</span><br><span class="line">make[1]: *** [Makefile:236: __sub-make] Error 2</span><br><span class="line">make[1]: Leaving directory &#x27;/home/luc/linux-6.6.0&#x27;</span><br><span class="line">make: *** [debian/rules.d/2-binary-arch.mk:46: /home/luc/linux-6.6.0/debian/stamps/stamp-build-generic] Error 2</span><br></pre></td></tr></table></figure>
<p>报错的原因是 <a href="https://lore.kernel.org/lkml/20240228032142.396719-1-jhubbard@nvidia.com/T/"><code>.config</code> 文件里打开的模块太多了</a>(因为是试验性编译, 没有 <code>zcat /proc/config.gz &gt; .config</code>)</p>
<h1 id="resources"><a class="markdownIt-Anchor" href="#resources"></a> Resources</h1>
<ul>
<li><a href="https://archive.kylinos.cn/kylin/KYLIN-ALL/">KylinOS 的软件包 OpenKylin 基本都能用</a></li>
<li><a href="https://trace-cmd.org/">trace-cmd</a></li>
<li><a href="https://doc.qt.io/qt-6/embedded-linux.html#embedded-eglfs">Platform plugins for Embedded Linux devices - EGLFS</a></li>
<li><a href="https://doc.qt.io/qt-6/linux-requirements.html">Qt for X11 Requirements</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>distro</tag>
      </tags>
  </entry>
  <entry>
    <title>perfetto</title>
    <url>/lnx/perfetto/</url>
    <content><![CDATA[<h1 id="perfetto"><a class="markdownIt-Anchor" href="#perfetto"></a> <a href="https://perfetto.dev/">Perfetto</a></h1>
<p>Perfetto 是一个用于 Linux 和 Android 系统上进行系统级和应用级的跟踪和性能分析的开源工具。Perfetto 捆绑了许多数据源，这些数据源能够从不同的系统接口收集详细的性能数据，包括 ftrace, /proc, /sys, native heap profiling 等。Perfetto 还提供了一个基于 Web 的用户界面，用于跟踪数据的可视化和分析。这里主要是对第一次使用 perfetto 做一下记录，方便以后继续学习和整理。</p>
<p><img src="/images/perfetto/perfetto.png" alt="perfetto" /></p>
<span id="more"></span>
<h1 id="perfetto-in-mesa"><a class="markdownIt-Anchor" href="#perfetto-in-mesa"></a> Perfetto in Mesa</h1>
<p>第一次使用 Perfetto 是从 Mesa 开始的，自从 Mesa 有了 Perfetto 的支持，就一直想看看 Perfetto 是怎么玩的，正好最近想比较一下 Zink + LAVAPIPE 和直接的 LLVMPIPE 两者的性能差异，就在我的 WSL2 Ubuntu 23.04 上折腾了一番。下面有几点基本情况下说明一下:</p>
<ul>
<li>Perfetto 在 Mesa 仓库里是以一个 submodule 存在的，而且构建选项默认是关闭的 (-Dperfetto=false)</li>
<li>启动 perfetto 时需要配置文件，Mesa 仓库也有好几个<a href="https://gitlab.freedesktop.org/mesa/mesa/-/tree/main/src/tool/pps/cfg">配置文件</a></li>
<li>perfetto 在 Linux 的主要数据源是 ftrace, /proc, /sys 这些，因为我是在 WSL2 上， 所以 tracefs 默认是没有挂载的，需要手动挂载一下
<ul>
<li><code>sudo mount -t tracefs tracefs /sys/kernel/tracing</code></li>
<li>WSL2 的内核有些东西是不启用的，还好 <code>CONFIG_FTRACE=y</code>, <code>CONFIG_TRACING=y</code>, 这就省得重新编译内核了</li>
</ul>
</li>
<li>perfetto 仓库自己提供了一些用于构建的 Python 脚本，只需按照它的 <a href="https://perfetto.dev/docs/quickstart/linux-tracing">quickstart guide</a> 构建就行了，但有一点很怪，perfetto 要用 google 自己的 clang 工具链(它的构建脚本里并没有给用户提供使用系统已有的 Clang 工具链的选项)</li>
</ul>
<p>实际上从构建到生成 <code>/tmp/trace.perfetto-trace</code> (上传到<a href="https://ui.perfetto.dev/">ui.perfetto.dev</a> 即可)，关键步骤有以下几个:</p>
<ul>
<li><code>cd mesa/subproject/perfetto &amp;&amp; ./tools/install-build-deps</code>
<ul>
<li>不要带 --no-toolchain, 一开始下载慢，环境上也有 clang, 就想不下载 clang, 结果发现不行</li>
</ul>
</li>
<li><code>./tools/setup_all_configs.py --host-only</code>
<ul>
<li>会在当前目录的 out 目录下生成多个目录，下一步指定给 <code>ninja -C</code></li>
</ul>
</li>
<li><code>ninja -C out/linux_clang_release</code>
<ul>
<li>如果顺利的话，perfetto 就构建完成了</li>
</ul>
</li>
<li><code>CONFIG=../../src/tool/pps/cfg/system.cfg OUT=out/linux_clang_release ./tools/tmux -n </code>
<ul>
<li>配置文件可以通过 CONFIG 环境变量指定, 这里的我用 Mesa 自带的 system.cfg。这里的 tmux 是一个 shell 脚本，它会启一个 tmux 会话，你在另外一个终端启动你的应用程序后，切回这个会话 Enter, perfetto 就开始记录数据了，一般有一个默认时长，当记录结束后，你只需 <code>Ctrl-B D</code> 关闭这个会话，记录的数据会自动保存在 <code>/tmp/trace.perfetto-trace</code> 文件中。</li>
</ul>
</li>
</ul>
<p>从第一次使用 perfetto 的情况，感觉它比较依赖 KMD 的实现，像 GPU 的性能计数器，只有内核驱动实现了，才能通过 perfetto 收集到，不过 perfetto 提供的库和 UI 确实简化了性能数据采集的过程和分析的难度。</p>
<h1 id="perfetto-in-android"><a class="markdownIt-Anchor" href="#perfetto-in-android"></a> Perfetto in Android</h1>
<p>Perfetto 在 Android 上主要是和 <a href="https://source.android.google.cn/devices/tech/debug/systrace?hl=zh-cn">systrace</a> 配合使用，开发者可以在 Android 设备上打开 <strong>System Tracing</strong>, 将追踪的 trace 文件通过 Chrome 浏览器打开网页 <a href="https://ui.perfetto.dev/">ui.perfetto.dev</a> 加载进行查看分析。</p>
<p><img src="/images/perfetto/xiaomi-system-tracing.png" alt="xiaomi-system-tracing" /><br />
<img src="/images/perfetto/xiaomi-system-tracing-2.png" alt="xiaomi-system-tracing-2" /></p>
<p>NOTE: 上面的跟踪日志文件来自我的红米手机，需要先让<strong>开发者选项</strong>在<strong>设置</strong>界面出现，才能打开 System Tracing</p>
<ul>
<li>调出<strong>开发者选项</strong></li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	Step_1@&#123; img: &quot;/images/perfetto/activate-system-tracing-1.png&quot;, w: 360, h: 720, constraint: &quot;on&quot; &#125;
	Step_2@&#123; img: &quot;/images/perfetto/activate-system-tracing-2.png&quot;, w: 360, h: 720, constraint: &quot;on&quot; &#125;
	Step_3@&#123; img: &quot;/images/perfetto/activate-system-tracing-3.png&quot;, w: 360, h: 720, constraint: &quot;on&quot; &#125;
    Step_1 --&gt; Step_2 --&gt; Step_3</code></pre>
<ul>
<li>打开<strong>系统跟踪</strong></li>
</ul>
<pre><code class="highlight mermaid">flowchart LR
	Step_1@&#123; img: &quot;/images/perfetto/activate-system-tracing-4.png&quot;, w: 360, h: 720, constraint: &quot;on&quot; &#125;
	Step_2@&#123; img: &quot;/images/perfetto/activate-system-tracing-5.png&quot;, w: 360, h: 720, constraint: &quot;on&quot; &#125;
	Step_3@&#123; img: &quot;/images/perfetto/activate-system-tracing-6.jpg&quot;, w: 360, h: 720, constraint: &quot;on&quot; &#125;
    Step_1 --&gt; Step_2 --&gt; Step_3</code></pre>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://blog.csdn.net/Jason_Lee155/article/details/126691265">Android 性能分析工具-systrace使用</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>perf</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Power Management</title>
    <url>/lnx/pm/</url>
    <content><![CDATA[<h1 id="power-state"><a class="markdownIt-Anchor" href="#power-state"></a> Power State</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Level</th>
<th style="text-align:left">State</th>
<th style="text-align:left">Power</th>
<th style="text-align:left">Command<br>(systemctl)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">S0</td>
<td style="text-align:left">idle</td>
<td style="text-align:left">full</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td style="text-align:left">S1</td>
<td style="text-align:left">sleep</td>
<td style="text-align:left">low</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td style="text-align:left">S2</td>
<td style="text-align:left">deeper sleep</td>
<td style="text-align:left">lower</td>
<td style="text-align:left">N/A</td>
</tr>
<tr>
<td style="text-align:left">S3</td>
<td style="text-align:left">suspend to RAM</td>
<td style="text-align:left">CPU off RAM on</td>
<td style="text-align:left">suspend</td>
</tr>
<tr>
<td style="text-align:left">S4</td>
<td style="text-align:left">suspend to DISK</td>
<td style="text-align:left">Most devices off</td>
<td style="text-align:left">hibernate</td>
</tr>
<tr>
<td style="text-align:left">S5</td>
<td style="text-align:left">shutdown</td>
<td style="text-align:left">completely off</td>
<td style="text-align:left">poweroff</td>
</tr>
</tbody>
</table>
<span id="more"></span>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>PRIME</title>
    <url>/lnx/prime/</url>
    <content><![CDATA[<ol>
<li><a href="https://blog.csdn.net/hexiaolong2009/article/details/105961192">关于 DRM 中 DUMB 和 PRIME 名字的由来</a></li>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/10595">In case of prime, allocate linear_buffer from display GPU VRAM instead of render GPU</a></li>
<li><a href="https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/12788">loader/dri3: avoid reusing the same back buffer with DRI_PRIME</a></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>DRM/KMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Scheduler</title>
    <url>/lnx/sched/</url>
    <content><![CDATA[<h1 id="task-state"><a class="markdownIt-Anchor" href="#task-state"></a> Task State</h1>
<pre><code class="highlight mermaid">stateDiagram-v2
    R: running
    S: sleeping
    D: disk sleep
    T: stopped
    t: tracing stop
    X: dead
    Z: zombie
    P: parked
    I: idle

    R --&gt; S: schedule_timeout()
    R --&gt; D: Wait for Disk I/O
    R --&gt; T: SIGTSTP
    R --&gt; t: gdb/strace
    S --&gt; R: wake_up_process()
    D --&gt; R: I/O Completed
    T --&gt; R: SIGCONT
    T --&gt; t: gdb/strace
    T --&gt; Z: SIGKILL But Sth Wrong with Its Parent
    R --&gt; Z: Exit But Sth Wrong with Its Parent
    t --&gt; T: Quit gdb</code></pre>
<span id="more"></span>
<p>Notes:</p>
<ul>
<li><code>disk sleep</code> 也就是 <strong>uninterruptible sleep</strong> 状态</li>
<li><code>zombie</code> 状态的进程在 <code>ps</code> 中被标记为 <code>&lt;defunct&gt;</code></li>
<li>正常的空闲用户进程一般是 <code>sleeping</code> 状态，空闲的 kthread 是 <code>idle</code> 状态</li>
</ul>
<h1 id="内核中和调度相关的-apis"><a class="markdownIt-Anchor" href="#内核中和调度相关的-apis"></a> 内核中和调度相关的 APIs</h1>
<ul>
<li>
<p><code>signed long __sched shedule_timeout_interruptible(signed long timeout);</code></p>
<ul>
<li>调用者 task 开始<em>睡眠直到超时</em></li>
</ul>
</li>
<li>
<p><code>wait_event_timeout(wq_head, condition, timeout)</code></p>
<ul>
<li><code>wq_head</code>: 正在等待的一个队列 <em>waitqueue</em>, 每次 <em>wq_head</em> 被唤醒， <em>condition</em> 都会被检查一次</li>
</ul>
</li>
</ul>
<h1 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h1>
<ul>
<li><code>static inline int signal_pending(struct task_struct *)</code>
<ul>
<li>检查当前 task 是否有信号处理，返回<em>非 0</em> 表示有信号需要处理</li>
</ul>
</li>
</ul>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/2147299/when-to-use-kernel-threads-vs-workqueues-in-the-linux-kernel">when-to-use-kernel-threads-vs-workqueues-in-the-linux-kernel</a></li>
<li><a href="https://lwn.net/Articles/511421/">Making workqueues non-reentrant</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/361409809">知乎：Linux softirq, tasklet 和 workqueue</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>strace - System Call Tracing</title>
    <url>/lnx/strace/</url>
    <content><![CDATA[<figure class="highlight txt"><figcaption><span>strace -c -w -o glmark2.strace glmark2</span></figcaption><table><tr><td class="code"><pre><span class="line">% time     seconds  usecs/call     calls    errors syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ------------------</span><br><span class="line"> 55.82   14.421660          55    258416           ioctl</span><br><span class="line"> 16.68    4.309981          18    238578    205238 recvmsg</span><br><span class="line"> 14.62    3.777039          17    210879        42 futex</span><br><span class="line">  5.06    1.306534          16     77652           getpid</span><br><span class="line">  2.73    0.705886          21     33276           writev</span><br><span class="line">  2.51    0.648318          17     36385           close</span><br><span class="line">  2.40    0.620114          18     33335           ppoll</span><br><span class="line">  0.04    0.011076          24       452           read</span><br><span class="line">  0.04    0.009150          32       281        47 openat</span><br><span class="line">  0.02    0.005639          30       187           mmap</span><br><span class="line">  0.01    0.003267          28       113           munmap</span><br><span class="line">  0.01    0.003240          21       152       120 readlinkat</span><br><span class="line">  0.01    0.002085          26        80           mprotect</span><br><span class="line">  0.01    0.002033          19       104           newfstatat</span><br><span class="line">  0.01    0.001976          26        75           brk</span><br><span class="line">  0.01    0.001364          71        19           recvfrom</span><br><span class="line">  0.00    0.001138          54        21           clone3</span><br><span class="line">  0.00    0.000778          18        43           rt_sigprocmask</span><br><span class="line">  0.00    0.000679          27        25           write</span><br><span class="line">  0.00    0.000645          29        22           getdents64</span><br><span class="line">  0.00    0.000493         492         1           execve</span><br><span class="line">  0.00    0.000323          17        18           lseek</span><br><span class="line">  0.00    0.000249          20        12           getrusage</span><br><span class="line">  0.00    0.000232          17        13           getrandom</span><br><span class="line">  0.00    0.000163          27         6           memfd_create</span><br><span class="line">  0.00    0.000150          24         6           sendmsg</span><br><span class="line">  0.00    0.000136          22         6           ftruncate</span><br><span class="line">  0.00    0.000131          16         8           fcntl</span><br><span class="line">  0.00    0.000054          18         3           geteuid</span><br><span class="line">  0.00    0.000054          18         3           getuid</span><br><span class="line">  0.00    0.000047          23         2         1 faccessat</span><br><span class="line">  0.00    0.000037          18         2           uname</span><br><span class="line">  0.00    0.000033          32         1           socket</span><br><span class="line">  0.00    0.000031          30         1           shutdown</span><br><span class="line">  0.00    0.000028          27         1           connect</span><br><span class="line">  0.00    0.000018          17         1           getpeername</span><br><span class="line">  0.00    0.000018          17         1           sched_getaffinity</span><br><span class="line">  0.00    0.000017          17         1           rt_sigaction</span><br><span class="line">  0.00    0.000017          16         1           prlimit64</span><br><span class="line">  0.00    0.000017          16         1           set_tid_address</span><br><span class="line">  0.00    0.000016          16         1           rseq</span><br><span class="line">  0.00    0.000016          16         1           set_robust_list</span><br><span class="line">------ ----------- ----------- --------- --------- ------------------</span><br><span class="line">100.00   25.834885          29    890185    205448 total</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><a href="https://github.com/strace/strace">strace</a> 主要是用来跟踪分析 Linux 系统调用的，因为系统调用是用户程序与内核交互的唯一途径，所以 strace 对于调试像用户态驱动程序这样的系统软件很有帮助。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://gist.github.com/reveng007/3e1d7a692649d30a75e566684207880c">strace vs. ltrace vs. ptrace vs. ftrace</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Sync File, the carrier of fences</title>
    <url>/lnx/sync_file/</url>
    <content><![CDATA[<p><img src="/images/dot/everything-is-file.svg" alt="everything is file" /></p>
<span id="more"></span>
<h1 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h1>
<p>从 Linux 的 <em>一切皆文件</em> 设计角度来看， Sync file 和 DMA-BUF, Sync object 类似，都是为了将内核空间的某个对象暴露给用户空间，并能使这个对象以 file descriptor 的形式在进程之间传递分享。</p>
<p>DMA-BUF 解决的是 Buffer 在设备之间(GPU 与 DISPLAY)，驱动之间(DRM 与 V4L2)，以及进程之间(Compositor 与 Client)的共享问题。Sync object 与 Sync file 相似，都是解决内核同步原语在进程间传递的问题，它们的区别是前者一个对象只封装<strong>一个</strong> fence, 而后者支持与一个 dma-buf 相关的<strong>多个</strong> fences 的集合。</p>
<p>Sync file 起初是从 Android kernel 引入的， 当 Dave Airlie 和 Faith Ekstrand 分别在 2017 年 和 2022 年提交了 <a href="https://lists.freedesktop.org/archives/dri-devel/2017-June/143204.html">drm/syncobj: add sync_file interaction. (v1.2)</a> 和 <a href="https://patchwork.freedesktop.org/series/104898/">dma-buf: Add an API for exporting sync files (v15)</a> 两个补丁集后，Sync file 便分别与 DRM Syncobj 和 DMA-BUF 产生了关联，而后者的合入标志着Linux 图形世界已经在 implicit sync 和 explicit sync 之间建起了一座桥梁。</p>
<h1 id="background"><a class="markdownIt-Anchor" href="#background"></a> Background</h1>
<h2 id="implicit-sync-vs-explicit-sync"><a class="markdownIt-Anchor" href="#implicit-sync-vs-explicit-sync"></a> Implicit sync vs Explicit sync</h2>
<p>从宏观层面讲，Implicit sync 指同步由 UMD 和 KMD 完全处理，3D 应用程序不参与(3D应用程序包括 compositor)， 相反，Explicit sync 指什么时候等待，等待谁，都交给应用程序自己决定和处理。Android graphics 从一开始就采用 Explicit sync 机制，而 Linux desktop 在 Vulkan 之前基本上都是采用 Implicit sync, 因为 Vulkan API 被设计成支持 Explicit sync, 因为在整个图形栈里，从渲染到合成到显示，任何一个环节只要不支持 Explicit sync，整个路径就只能走 implicit sync, 这就导致 Vulkan 应用与其它采用 Implict sync 的应用之间，尤其是与 X Server 之间的同步变成一个问题。</p>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://zamundaaa.github.io/wayland/2024/04/05/explicit-sync.html">Explicit sync</a></li>
<li><a href="https://www.collabora.com/news-and-blog/blog/2022/06/09/bridging-the-synchronization-gap-on-linux/">Bridging the synchronization gap on Linux</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Syscall vs C routines</title>
    <url>/lnx/syscall/</url>
    <content><![CDATA[<p>系统调用是 Linux 用户态程序与内核通信的接口。 每个特定的文件系统都会在自己的 <code>file_operations</code> 里提供各种文件操作接口，像 <code>.open</code>, <code>.close</code>, <code>.ioctl</code>。系统调用会通过 VFS 的接口调用这些具体的实现，而对于应用程序来说，一般不会直接使用系统调用，而是调用 C 库函数 (C routines).</p>
<p>ioctl 这个系统调用的声明大概是这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMPAT_SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, compat_ulong_t, arg)</span><br></pre></td></tr></table></figure>
<p>ioctl 的 C 库函数 (Aarch64 实现)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.text</span><br><span class="line">ENTRY(__ioctl)</span><br><span class="line">    /* move ioctl syscall number to x8 register */</span><br><span class="line">	mov	x8, #__NR_ioctl</span><br><span class="line">    /* sign extend w0 to x0 */</span><br><span class="line">	sxtw	x0, w0</span><br><span class="line">    /* issue software interrupt to invoke syscall */</span><br><span class="line">	svc	#0x0</span><br><span class="line">    /* add 4095 to x0 and set flags according to result */</span><br><span class="line">	cmn	x0, #4095</span><br><span class="line">    /* if carry bit is set (previous addition carrys out), branch to Lsyscall_error */</span><br><span class="line">	b.cs	.Lsyscall_error</span><br><span class="line">	ret</span><br><span class="line">PSEUDO_END (__ioctl)</span><br><span class="line"></span><br><span class="line">/* symbol management, making __ioctl and ioctl effectively the same function */</span><br><span class="line">libc_hidden_def (__ioctl)</span><br><span class="line">weak_alias (__ioctl, ioctl)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h1>
<p>因为系统调用失败时返回的都是 <code>-errno</code>, 所以当失败时 <code>cmn x0, #4095</code> 的结果必然导致 carry 标志位被置，后面的 <code>b.cs</code> (carry set branch) 则会跳转到 <code>Lsyscall_error</code> 标签继续执行，所以 C 库函数 <code>ioctl()</code> 失败时的返回值是多少，就要看 <code>Lsyscall_error</code> 的处理了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># if !IS_IN (libc)</span><br><span class="line">#  define SYSCALL_ERROR  .Lsyscall_error</span><br><span class="line">#  if RTLD_PRIVATE_ERRNO</span><br><span class="line">#   define SYSCALL_ERROR_HANDLER				\</span><br><span class="line">.Lsyscall_error:						\</span><br><span class="line">	adrp	x1, C_SYMBOL_NAME(rtld_errno);			\</span><br><span class="line">	neg     w0, w0;						\</span><br><span class="line">	str     w0, [x1, :lo12:C_SYMBOL_NAME(rtld_errno)];	\</span><br><span class="line">	mov	x0, -1;						\</span><br><span class="line">	RET;</span><br><span class="line">#  else</span><br><span class="line"></span><br><span class="line">#   define SYSCALL_ERROR_HANDLER				\</span><br><span class="line">.Lsyscall_error:						\</span><br><span class="line">	adrp	x1, :gottprel:errno;				\</span><br><span class="line">	neg	w2, w0;						\</span><br><span class="line">	ldr	PTR_REG(1), [x1, :gottprel_lo12:errno];		\</span><br><span class="line">	mrs	x3, tpidr_el0;					\</span><br><span class="line">	mov	x0, -1;						\</span><br><span class="line">	str	w2, [x1, x3];					\</span><br><span class="line">	RET;</span><br><span class="line">#  endif</span><br><span class="line"># else</span><br><span class="line">#  define SYSCALL_ERROR __syscall_error</span><br><span class="line">#  define SYSCALL_ERROR_HANDLER                                 \</span><br><span class="line">.Lsyscall_error:                                                \</span><br><span class="line">	b	__syscall_error;</span><br><span class="line"># endif</span><br></pre></td></tr></table></figure>
<p>可以看到无论是 <code>#if</code> 或 <code>#else</code> 哪个分支， 都有 <code>mov x0, -1</code>, 所以结论就是 C 库函数 <code>ioctl()</code> 的返回值：成功 <code>0</code>, 失败 <code>-1</code>. 相应的错误码会保存在 <code>errno</code>.</p>
<p>这里再看一下 <a href="https://gitlab.freedesktop.org/mesa/drm">libdrm</a> 库对 ioctl 的封装函数  <code>drmIoctl()</code>, 它的返回值仍然是：成功 <code>0</code>, 失败 <code>-1</code>. 只不过它对 <code>EINTR</code>(4, “Interrupted system call”) 和 <code>EAGAIN</code>(11, “Try again”) 这两种错误码进行了重试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drm_public int</span><br><span class="line">drmIoctl(int fd, unsigned long request, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        ret = ioctl(fd, request, arg);</span><br><span class="line">    &#125; while (ret == -1 &amp;&amp; (errno == EINTR || errno == EAGAIN));</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一个调用 <code>drmIoctl()</code> 的 libdrm 的库函数，比如 <code>drmSyncobjWait()</code>, 它的返回值在失败时变成了 <code>-errno</code>, 当然这样避免让上层调用者去检查 <code>errno</code>, 但却打破了接口的一致性，有利有弊吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drm_public int drmSyncobjWait(int fd, uint32_t *handles, unsigned num_handles,</span><br><span class="line">                              int64_t timeout_nsec, unsigned flags,</span><br><span class="line">                              uint32_t *first_signaled)</span><br><span class="line">&#123;</span><br><span class="line">    struct drm_syncobj_wait args;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    memclear(args);</span><br><span class="line">    args.handles = (uintptr_t)handles;</span><br><span class="line">    args.timeout_nsec = timeout_nsec;</span><br><span class="line">    args.count_handles = num_handles;</span><br><span class="line">    args.flags = flags;</span><br><span class="line"></span><br><span class="line">    ret = drmIoctl(fd, DRM_IOCTL_SYNCOBJ_WAIT, &amp;args);</span><br><span class="line">    if (ret &lt; 0)</span><br><span class="line">        return -errno;</span><br><span class="line"></span><br><span class="line">    if (first_signaled)</span><br><span class="line">        *first_signaled = args.first_signaled;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>udev, sysfs &amp; libudev</title>
    <url>/lnx/udev/</url>
    <content><![CDATA[<h1 id="udev"><a class="markdownIt-Anchor" href="#udev"></a> udev</h1>
<p>udev是Linux系统管理<code>/dev</code>的内核组件，它负责在系统运行时动态的创建和删除<code>/dev</code>下的设备文件(节点)。</p>
<ul>
<li>当设备被检测到时创建设备文件</li>
<li>当设备被移除时删除设备文件</li>
<li><code>/etc/udev/rules.d</code>允许用户自定义设备文件的权限，路径和符号链接</li>
</ul>
<p>udev显然是支持Hotplug, 而且保证<code>/dev</code>下的设备节点是实时更新的。而且它强大的用户自定义行为非常灵活。但它的问题是：</p>
<ul>
<li>用户自定义规则的存在让应用程序很难确定特定的设备文件和设备类型</li>
<li>同一类型的多个设备，设备文件的创建顺序是不确定的</li>
</ul>
<h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1>
<p><a href="https://blog.csdn.net/fjb2080/article/details/7528894">libudev and sysfs tutorial</a></p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>这年初二</title>
    <url>/misc/chuer/</url>
    <content><![CDATA[<table>
<tr>
<td width="50%">
<img src="/images/chuer/fireworks.gif">
</td>
<td width="50%">
<p>小小的人儿<br><br />
攥不住流淌的昼与夜<br><br />
当你舞动手中的仙女棒<br><br />
却仿佛在挥洒银河</p>
<p>捂住双耳<br><br />
不为那凛凛的冰寒<br><br />
只等花儿在星星眼前开放<br><br />
仍怀抱静谧和安然</p>
<p>这年初二<br><br />
我们仨<br><br />
凤翔城里看凤翔<br><br />
往后余生<br><br />
翔凤桥头不彷徨</p>
</td>
</tr>
</table>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>Star</tag>
      </tags>
  </entry>
  <entry>
    <title>观“老石谈芯”视频记</title>
    <url>/misc/1percent/</url>
    <content><![CDATA[<h1 id="1定律"><a class="markdownIt-Anchor" href="#1定律"></a> 1%定律</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;print(1.01**365)&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>37.78343433288728</strong></p>
<p>每天提升1%, 一年后提升近38倍。</p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title>My english is poor</title>
    <url>/misc/english/</url>
    <content><![CDATA[<blockquote>
<p>A language that doesn’t affect the way you think about programming, is not worth knowing.</p>
<p>– <cite>Alan J. Perlis, Recipient of 1966 Turing Award</cite></p>
</blockquote>
<span id="more"></span>
<h1 id="irc"><a class="markdownIt-Anchor" href="#irc"></a> IRC</h1>
<h2 id="ircinternet-relay-chat"><a class="markdownIt-Anchor" href="#ircinternet-relay-chat"></a> <a href="https://zh.wikipedia.org/wiki/IRC">IRC(Internet Relay Chat)</a></h2>
<ul>
<li>一种应用层协议，用于聊天沟通</li>
<li>一种开源社区常用的通讯方式</li>
<li>服务端口号6667[明文], 6697[加密]</li>
<li><a href="https://webchat.oftc.net/">webchat.oftc.net</a>是其中一种基于web的客户端</li>
</ul>
<!--more-->
<h2 id="频道-channels"><a class="markdownIt-Anchor" href="#频道-channels"></a> 频道 Channels</h2>
<ul>
<li><a href="https://webchat.oftc.net/">#dri-devel</a></li>
<li><a href="https://webchat.oftc.net/">#llvm</a></li>
<li><a href="https://webchat.oftc.net/">#panfrost</a></li>
</ul>
<p>如果你想知道谁在跟你交流或你的问题应该@谁，请查看<a href="https://dri.freedesktop.org/wiki/WhosWho/">Who’s Who on IRC</a></p>
<h2 id="短句-acronymphrases"><a class="markdownIt-Anchor" href="#短句-acronymphrases"></a> 短句 Acronym/Phrases</h2>
<p><a href="https://gist.github.com/lucmann/a731f787fae96264c09f0bcdbef7f0dd">abbr.csv</a></p>
<h1 id="粘贴服务-paste-service"><a class="markdownIt-Anchor" href="#粘贴服务-paste-service"></a> 粘贴服务 Paste Service</h1>
<p>在 IRC 上交流时，有时可能需要粘贴 Log，Config 之类的大段文本，但这些又不便直接粘到 IRC 上，这时以下基于 Web 的 Paste 服务可能帮得上你</p>
<ul>
<li><a href="http://ix.io">http://ix.io</a></li>
<li><a href="https://paste.rs">https://paste.rs</a></li>
<li><a href="https://bpaste.net">https://bpaste.net</a></li>
<li><a href="https://gist.github.com">https://gist.github.com</a></li>
</ul>
<h1 id="短语汇"><a class="markdownIt-Anchor" href="#短语汇"></a> 短语汇</h1>
<h2 id="wiggle-room进行解释或表达意见所留的余地-回旋空间"><a class="markdownIt-Anchor" href="#wiggle-room进行解释或表达意见所留的余地-回旋空间"></a> Wiggle Room（进行解释或表达意见所留的）余地、回旋空间。</h2>
<p>there’s pretty much zero wiggle room in semantics 在语义上没有什么可讨论的。</p>
<h2 id="hand-rollhand-rolled"><a class="markdownIt-Anchor" href="#hand-rollhand-rolled"></a> Hand Roll/Hand-rolled</h2>
<p>&quot;Hand roll&quot;或&quot;hand-rolled&quot;是一个英语词汇，通常用于描述手工制作的东西。这个词汇可以用来形容手工制作的食品，如手卷寿司（hand-rolled sushi），也可以用来形容手工制作的烟卷（hand-rolled cigarettes）或手工制作的纸卷（hand-rolled paper）。在其他领域，&quot;hand roll&quot;或&quot;hand-rolled&quot;也可以指手工制作的家具、纺织品、珠宝、音乐乐器等。</p>
<p>I think we’re way past the point where drivers hand-rolling entire gem from nothing is ready for upstream</p>
<h2 id="rubberstamp-不带检查地-允许或通过"><a class="markdownIt-Anchor" href="#rubberstamp-不带检查地-允许或通过"></a> rubberstamp (不带检查地) 允许或通过</h2>
<p>无论这个是否有助于 v10 版本硬件的逆向，我都愿意给你通过(不检查), 但我还是想明白我们所面临的问题。</p>
<p>Willing to rubberstamp regardless of this is helping v10 r/e, but I would like to understand what we’re up against here.</p>
<h2 id="scaffolding-临时结构和代码"><a class="markdownIt-Anchor" href="#scaffolding-临时结构和代码"></a> scaffolding 临时结构和代码</h2>
<p>scaffolding 是指脚手架，通常用于建筑施工中支撑人员和材料的临时结构。在计算机科学中，scaffolding 可以指代软件开发过程中的一些临时结构和代码，用于辅助开发人员快速完成某个功能或实现某个目标。这些临时结构和代码通常会被移除或重构，只留下最终的代码和结构</p>
<p>have the minimal scaffolding to support the preempt-ctx fence in drm_sched_entity</p>
<h2 id="scratching-my-head-挠头表示遇到难题或困扰"><a class="markdownIt-Anchor" href="#scratching-my-head-挠头表示遇到难题或困扰"></a> Scratching my head 挠头，表示遇到难题或困扰</h2>
<p>“Scratching my head” 可以翻译为“挠头”，表示困惑、疑惑或思考时的动作。这个表达方式通常用于描述遇到难题或困扰时的情况。</p>
<h2 id="footgunfoot-gun-自伤行为-指在尝试解决问题时不小心采用了导致问题恶化的行动-类似于搬起石头砸自己的脚"><a class="markdownIt-Anchor" href="#footgunfoot-gun-自伤行为-指在尝试解决问题时不小心采用了导致问题恶化的行动-类似于搬起石头砸自己的脚"></a> footgun/foot-gun 自伤行为。指在尝试解决问题时，不小心采用了导致问题恶化的行动。类似于“搬起石头砸自己的脚”</h2>
<p>“Is the suggested callback a giant foot-gun in the already treacherous territory of scheduling and fencing?”</p>
<h1 id="经常读错的词汇"><a class="markdownIt-Anchor" href="#经常读错的词汇"></a> 经常读错的词汇</h1>
<table>
<thead>
<tr>
<th style="text-align:left">word</th>
<th style="text-align:left">translation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">deque / dɛk /</td>
<td style="text-align:left">n. 双端队列</td>
</tr>
<tr>
<td style="text-align:left">infinite / 'ɪnfɪnət /</td>
<td style="text-align:left">adj. 无限的，非限定的; n. 无穷大，上帝</td>
</tr>
<tr>
<td style="text-align:left">finite / 'fɑɪnɑɪt /</td>
<td style="text-align:left">adj. 有限的，限定的; n. 有限之物</td>
</tr>
<tr>
<td style="text-align:left">opaque / oʊ’peɪk /</td>
<td style="text-align:left">adj. 不透明的，难懂的; n. 不透明体</td>
</tr>
<tr>
<td style="text-align:left">width  / wɪdθ; wɪtθ /</td>
<td style="text-align:left">n. 宽度</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>Hobbies</tag>
      </tags>
  </entry>
  <entry>
    <title>升2级后的第一盘</title>
    <url>/misc/first-game-2ji/</url>
    <content><![CDATA[<p>升2级后的第一盘棋黑竟然下出了连续11手的AI一选（从黑97到黑121), 当然这也与白的应招有关系。不过 可惜最终黑123还是错失翻盘机会。局后复盘，看到连续11手的一选有点激动，故此记录</p>
<span id="more"></span>
<p><img src="/images/game/game.gif" alt="奔跑的Luc执黑 vs 年年有鱼执白(210手黑中盘负)" /></p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>Hobbies</tag>
      </tags>
  </entry>
  <entry>
    <title>电影里的经典台词</title>
    <url>/misc/moive/</url>
    <content><![CDATA[<h1 id="scent-of-a-woman-1992"><a class="markdownIt-Anchor" href="#scent-of-a-woman-1992"></a> Scent of a woman (1992)</h1>
<p>No mistakes in the Tango, not like life. It’s simple, that’s what makes the Tango so great. If you make a mistake, get all tangled up, just Tango on.</p>
<h1 id="rudy-1993"><a class="markdownIt-Anchor" href="#rudy-1993"></a> Rudy (1993)</h1>
<p>Having dreams is what makes life tolerable</p>
<h1 id="the-shawshank-redemption-1994"><a class="markdownIt-Anchor" href="#the-shawshank-redemption-1994"></a> The Shawshank Redemption (1994)</h1>
<p>Get busy living or get busy dying</p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>Hobbies</tag>
      </tags>
  </entry>
  <entry>
    <title>我在邮件列表里学英语</title>
    <url>/misc/maillist/</url>
    <content><![CDATA[<blockquote>
<p>Communication is hard, especially with all the different personalities, languages, and<br />
cultures involved in an international community like this.</p>
<p>– <cite>Faith Ekstrand</cite></p>
</blockquote>
<blockquote>
<p>It is rules and not our individual smarts that keep us from making mistakes.</p>
<p>– <cite>Faith Ekstrand</cite></p>
</blockquote>
<span id="more"></span>
<p>已经订阅 <a href="mailto:dri-devel@lists.freedesktop.org">dri-devel@lists.freedesktop.org</a> 有一年多了，看到过几次激烈的关于 drm 子系统里的像 drm_sched, dma_fence 的讨论。慢慢地我发现在翻译工具的帮助下，邮件列表里这种纯文本的讨论 可以成为很好的学习英语的地方。这里的表达感觉介于正式的书面语和随意的口语之间，更重要的，在讨论当中有很多技术性的专业词汇及俚语。这些不仅有助于提高英语阅读水平，而且有助于熟悉技术讨论中常用的表述习惯和语句组织。<br />
(当然这些邮件就像会议记录一般，可以让我对于所讨论的问题本身反复地阅读直到完全理解)</p>
<h1 id="如何订阅-dri-devel"><a class="markdownIt-Anchor" href="#如何订阅-dri-devel"></a> 如何订阅 dri-devel</h1>
<p>Easy! 只需要自己有一个 E-mail 地址，然后在这个<a href="https://lists.freedesktop.org/mailman/listinfo/dri-devel#:~:text=Subscribe%20to%20dri-devel%20by%20filling%20out%20the%20following,confirmation%2C%20to%20prevent%20others%20from%20gratuitously%20subscribing%20you.">网站</a>填一个简单的表格就可以了。</p>
<h1 id="邮件列表订阅者的-digested-members-和-non-digested-members-有何不同"><a class="markdownIt-Anchor" href="#邮件列表订阅者的-digested-members-和-non-digested-members-有何不同"></a> 邮件列表订阅者的 Digested Members 和 Non-digested Members 有何不同？</h1>
<p><a href="https://td.wku.edu/TDClient/34/Portal/KB/ArticleDet?ID=1620">链接:https://td.wku.edu/TDClient/34/Portal/KB/ArticleDet?ID=1620</a></p>
<h1 id="翻译1"><a class="markdownIt-Anchor" href="#翻译1"></a> 翻译1</h1>
<p>(关于 Linux 社区工作方式)</p>
<p>And, to be clear, for the purposes of this discussion, we’re ALL<br />
idiots, myself included.  If there’s one thing the DRM community has<br />
learned over the years, it’s that drivers are so complex that we all<br />
turn into idiots at some point, relative to the complexity of the code<br />
and hardware behavior.  That’s why things like dma_fence are written so<br />
incredibly defensively and why we’re so harsh about the rules.  It’s<br />
the rules and not our individual smarts that keep us from making<br />
mistakes.  (Kinda like Rust, in a way.)  So while I appreciate the<br />
frustration of “I’m just trying to do something that’s clearly correct<br />
here”, that doesn’t mean that then next person to come by and fix a bug<br />
by tweaking that callback isn’t going to screw it up irreparably.  That<br />
person may even be you in 6 to 12 months after this e-mail thread is a<br />
distant memory.</p>
<p>并且，就讨论的目的而言，我们都是笨蛋，包括我自己在内。多年来，DRM社区所学到的一件事就是，驱动程序是如此复杂，以至于在某些情况下，相对于代码和硬件行为的复杂性，我们都会变得愚笨。这就是为什么像dma_fence这样的东西被编写得如此谨慎，以及为什么我们对规则要求如此严格的原因。正是规则而不是我们个人的聪明才智防止了我们犯错。（某种程度上类似于Rust）所以虽然我理解“我只是想在这里做一些显然正确的事情”的沮丧，但这并不意味着接下来的人在调整回调函数以修复错误时不会犯下不可挽回的错误。这个人甚至可能就是你，在这个邮件线程成为遥远记忆的6到12个月后。💁🤔</p>
<p><a href="https://patchwork.freedesktop.org/patch/525461/">英文原文</a><br />
<a href="https://www.youtube.com/watch?v=3OqllZONTiQ&amp;t=9937s">相关视频</a></p>
<h1 id="翻译2"><a class="markdownIt-Anchor" href="#翻译2"></a> 翻译2</h1>
<p>(关于 DRM device reset 文档建设)</p>
<p><a href="https://patchwork.freedesktop.org/patch/519860/">英文原文</a><br />
<a href="https://patchwork.freedesktop.org/patch/544431/">英文原文</a></p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>Hobbies</tag>
      </tags>
  </entry>
  <entry>
    <title>词汇: nightly</title>
    <url>/misc/nightly/</url>
    <content><![CDATA[<p>最近在两个地方看到<strong>nightly</strong>这个词：</p>
<p><a href="https://cgit.freedesktop.org/drm-tip/">drm-tip</a>或<a href="https://cgit.freedesktop.org/drm/drm-tip/">drm/drm-tip</a> (我也不知道这两个仓库有什么区别，除了它们的Owner不同)</p>
<p>DRM current development and <strong>nightly</strong> trees</p>
<span id="more"></span>
<p>另外一个地方是Rust的版本发布策略，它采用<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">train schedule</a>. Rust总共有3个Release通道:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>从上到下，各个Release版本的更新程度(包含新特性的多少)依次减少，稳定程序依次增加，也就是说，对于大多数普通的开发者，会选择安装Stable, 而对于那些想尝试Rust语言最新的特性的开发者，则会选择安装Nightly或Beta版本。</p>
<p>你可以使用rust toolchain管理工具<code>rustup</code>来安装和切换不同的Release版本，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustup default nightly</span><br></pre></td></tr></table></figure>
<p>将安装最新的Rust nightly版本(这篇博客写于Fri Nov 19 15:28:25 CST 2021)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nightly-x86_64-unknown-linux-gnu installed - rustc 1.58.0-nightly (cc946fcd3 2021-11-18)</span><br></pre></td></tr></table></figure>
<p>从上面两个Nightly的用法看，它基本上代表最新的，最近的，让我想到以前项目的“每日构建版本”。</p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title>学弈</title>
    <url>/misc/thinking-in-go/</url>
    <content><![CDATA[<h1 id="棋理"><a class="markdownIt-Anchor" href="#棋理"></a> 棋理</h1>
<p>最近和朋友的孩子下了几盘棋，在惊叹现在孩子的聪慧和学习能力之余，也深感自己的“棋艺”着实有待提高。便又拣起荒废已久的弈城账号，想下几盘找找感觉，结果又一次应了那句，“业精于勤，荒于嬉”。失落之余，索性去 B 站，重看邱百瑞老师的<a href="https://www.bilibili.com/video/BV1tt4y1G7KR/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=b3ba1ad08e1b41cd7118d8dd88f0e670">带你零基础学围棋</a>.<br />
再看确实有不一样的感受。围棋的奥妙和那些千古流传的棋理自不必多说，我想自己学习下棋，试着了解棋理的原因，也是被围棋这种“方寸之间有天地，黑白之处显乾坤”的魅力所折服。</p>
<span id="more"></span>
<h1 id="征子与引征"><a class="markdownIt-Anchor" href="#征子与引征"></a> 征子与引征</h1>
<p>征子也叫“扭羊头”，是吃子的一种技巧。邱老师说，征子既厉害又危险。一旦征子失败，“原来追别人的棋现在全变成自己的断点，刚才追得很高兴，现在大概也死得很惨”。</p>
<p><img src="/images/thinking-in-go/ladder.png" alt="征子" /></p>
<p>兵家有云，“穷寇莫追”。虽然有可能将对方赶尽杀绝，但也可能在追的时候将自己置于危险之中。竞争也是一样，如果一味地想超越对手，很可能最后把自己搞得惨不忍睹。</p>
<h1 id="扑"><a class="markdownIt-Anchor" href="#扑"></a> 扑</h1>
<p>围棋里“勇敢”的行为，扑 (uchikaki, throw-in), 含有置之死地而后生之意。</p>
<p><img src="/images/thinking-in-go/uchikaki.png" alt="扑" /></p>
<h1 id="基本棋形的死活"><a class="markdownIt-Anchor" href="#基本棋形的死活"></a> 基本棋形的死活</h1>
<table>
<thead>
<tr>
<th style="text-align:left">棋形</th>
<th style="text-align:left">死活类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">直三</td>
<td style="text-align:left">后手活</td>
</tr>
<tr>
<td style="text-align:left">直四</td>
<td style="text-align:left">活</td>
</tr>
<tr>
<td style="text-align:left">曲四</td>
<td style="text-align:left">活</td>
</tr>
<tr>
<td style="text-align:left">丁四</td>
<td style="text-align:left">后手活</td>
</tr>
<tr>
<td style="text-align:left">方四</td>
<td style="text-align:left">死</td>
</tr>
<tr>
<td style="text-align:left">直五</td>
<td style="text-align:left">活</td>
</tr>
<tr>
<td style="text-align:left">曲五</td>
<td style="text-align:left">活</td>
</tr>
<tr>
<td style="text-align:left">聚五</td>
<td style="text-align:left">后手活</td>
</tr>
<tr>
<td style="text-align:left">刀把五</td>
<td style="text-align:left">后手活</td>
</tr>
<tr>
<td style="text-align:left">板六</td>
<td style="text-align:left">活</td>
</tr>
<tr>
<td style="text-align:left">梅花六</td>
<td style="text-align:left">后手活</td>
</tr>
<tr>
<td style="text-align:left">聚七</td>
<td style="text-align:left">活</td>
</tr>
</tbody>
</table>
<h1 id="围地的常识"><a class="markdownIt-Anchor" href="#围地的常识"></a> 围地的常识</h1>
<p>围棋的争夺主要有两大部分</p>
<ul>
<li>围杀对方的子</li>
<li>高效地围地</li>
</ul>
<p>高效地围地才是决定胜负的关键，而围杀对方的子只不过是其中一种手段罢了。</p>
<p><img src="/images/thinking-in-go/efficiency.png" alt="围地的效率" /></p>
<h1 id="中国规则的数子与日本规则的数目"><a class="markdownIt-Anchor" href="#中国规则的数子与日本规则的数目"></a> 中国规则的数子与日本规则的数目</h1>
<p>围棋的中国规则是以数子计算，任意选择一方来数棋盘上的活子数以及活子围成的空（交叉点），为了计算方便，一般会用己方的棋子先把围成的空填满。</p>
<p>而日本规则是点目，所谓“目”，即围成的空。日本规则之所以不去关心棋盘上的活子的数量，而只计算围成的空，是因为围棋一人一手的规则决定了双方算上被吃的死子，在棋盘上放过的子数一定是相等的。所以日本规则在点目前，要将吃掉的对方的死子填入对方围成的空中之后，再清点目数。一目也即一个交叉点。这也是常说的“吃一子的价值是两目棋”的道理。</p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>Hobbies</tag>
      </tags>
  </entry>
  <entry>
    <title>弈城围棋</title>
    <url>/misc/weiqi/</url>
    <content><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>弈城围棋是<a href="http://www.eweiqi.com/">弈城围棋网</a>推出的一款围棋学习和网络对战的 App. 它可安装在包括 Windows, Android, iOS, iPad, MacOS 在内的各个平台。</p>
<span id="more"></span>
<p><img src="/images/weiqi/20220904092030.jpg" alt="弈城围棋 App" /></p>
<h1 id="下载和安装"><a class="markdownIt-Anchor" href="#下载和安装"></a> 下载和安装</h1>
<p>以 Android 手机平台为例，常用的腾讯 “应用宝” 或手机自带的 “应用中心” 里一般搜不到这款 App, 我们可以直接从手机百度中搜索 “弈城围棋” 关键字，结果中的第二个就是，然后从手机浏览器里下载安装即可。</p>
<p><img src="/images/weiqi/202209040920307.jpg" alt="弈城围棋下载" /></p>
<h1 id="主要功能"><a class="markdownIt-Anchor" href="#主要功能"></a> 主要功能</h1>
<p>“弈城围棋”是一个比较大的网络围棋平台，涵盖了中国，韩国和日本的职业棋手和业余棋手，以及通过网络学棋的许多围棋爱好者。所以这款 App 设置了许多不同的房间，以便汇集不同水平的棋手。用户可以任意选择进入房间，也可以随意切换房间。</p>
<p><img src="/images/weiqi/202209040920302.jpg" alt="弈城围棋房间设置" /></p>
<p>“弈城围棋” App 分别设置了 9 路和 19 路对局以及 AI 9 路， AI 19 路，对于初学者，可以从 9 路对局开始练习。</p>
<p><img src="/images/weiqi/202209040920303.jpg" alt="弈城围棋棋路设置" /></p>
<p>“弈城围棋” 具有打谱和复盘的功能，不仅保存有海量职业棋谱，而且保留了自己以往对局的每一张棋谱，还支持搜索功能，方便你随时复盘任意棋局。</p>
<p><img src="/images/weiqi/202209040920304.jpg" alt="弈城围棋棋谱设置" /><br />
<img src="/images/weiqi/202209040920306.jpg" alt="弈城围棋复盘设置" /></p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>Hobbies</tag>
      </tags>
  </entry>
  <entry>
    <title>观“老石谈芯”视频笔记 (二)</title>
    <url>/misc/xiangshan/</url>
    <content><![CDATA[<h1 id="glossary"><a class="markdownIt-Anchor" href="#glossary"></a> Glossary</h1>
<ul>
<li>PoC: Proof of Concept, 概念验证</li>
<li>Chisel: tExtended on Scala</li>
<li>GDSII: 版图</li>
<li>RTL: Register-Transfer Level, RTL 语言包括 SystemVerilog, Verilog, VHDL等</li>
<li>FIRRTL: Chisel 的“翻译器”, Chisel -&gt; Verilog</li>
<li>shift left: 把验证和调试放在 tape in 阶段</li>
<li>GEM5: C Simulator for GPU</li>
<li>PPA: Power, Performance, Area, used in deciding how to optimize semiconductor designs</li>
</ul>
<span id="more"></span>
<h1 id="miscellaneous"><a class="markdownIt-Anchor" href="#miscellaneous"></a> Miscellaneous</h1>
<ul>
<li>中国科学院计算所</li>
<li>中国开放指令生态(RISC-V)联盟</li>
<li>中国科学院大学 “一生一芯”</li>
<li>RIOS: PicoRio</li>
</ul>
<h1 id="infrastructure"><a class="markdownIt-Anchor" href="#infrastructure"></a> Infrastructure</h1>
<ul>
<li>流程：工具化，自动化，平台化</li>
<li>开源：代码开源，流程开放，文档开放</li>
<li>指导：基础与实践并重，某种程度上，实践可能比基础知识更重要</li>
</ul>
<h1 id="my-opinions"><a class="markdownIt-Anchor" href="#my-opinions"></a> My Opinions</h1>
<blockquote>
<p>历史总是惊人的相似。</p>
</blockquote>
<h1 id="related-talks"><a class="markdownIt-Anchor" href="#related-talks"></a> Related Talks</h1>
<p>[1]<a href="https://www.bilibili.com/video/BV1oV41127Hy/?spm_id_from=333.788.recommend_more_video.13&amp;vd_source=b3ba1ad08e1b41cd7118d8dd88f0e670">RISC-V在中国的发展状况</a><br />
[2]<a href="https://www.bilibili.com/video/BV1Mf4y1b7hm?spm_id_from=333.337.search-card.all.click&amp;vd_source=b3ba1ad08e1b41cd7118d8dd88f0e670">揭秘“香山”：高性能开源RISC-V处理器</a><br />
[3]<a href="https://www.youtube.com/watch?v=lXdx0X2WHfY">RISC-V is the future of computing</a></p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>RISC-V</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C++应该知道的那些事</title>
    <url>/prog/cpp-faqs/</url>
    <content><![CDATA[<h1 id="缩略语-abbreviation"><a class="markdownIt-Anchor" href="#缩略语-abbreviation"></a> 缩略语 (Abbreviation)</h1>
<ul>
<li>RAII</li>
</ul>
<p>Resource Acquisition Is Initialization</p>
<p><a href="https://zhuanlan.zhihu.com/p/34660259">知乎-RAII原理</a></p>
<span id="more"></span>
<ul>
<li>RTTI</li>
</ul>
<p>Runtime Type Identification</p>
<p><a href="https://blog.csdn.net/ljianhui/article/details/46487951">CSDN-RTTI原理</a></p>
<ul>
<li>SFINAE</li>
</ul>
<p>Substitution Failure Is Not An Error</p>
<p>意思是在函数模板或类模板（包括类模板特化）类型推导时，由于类型或值替换导致的Ill-formed code(Subsititution Failure)不被作为一个编译时错误。</p>
<h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1>
<ul>
<li>Don’t declare objects <code>const</code> if you want to move from them.</li>
<li>Using <code>std::move</code> doesn’t guarantee anything will be moved.</li>
</ul>
<h1 id="frequently-asked-questions"><a class="markdownIt-Anchor" href="#frequently-asked-questions"></a> Frequently Asked Questions</h1>
<ul>
<li>
<p>在 C++11 之前，编译器可能会为一个类创建的函数有哪些?</p>
</li>
<li>
<p>如果要阻止一个类的对象被复制(copyable), 有哪些做法?</p>
<ol>
<li>将 copy 构造函数和 copy assignment 操作符声明为 private, 并不予实现。</li>
<li>实现一个 base class, 这个 base class 的 copy 构造函数和 copy assignment 操作符都为 private。</li>
</ol>
</li>
<li>
<p>C++ Template parameters 有哪几种?</p>
<ol>
<li>
<p>non-type template parameter</p>
<ul>
<li>lvalue reference type</li>
<li>integral type</li>
<li>pointer type</li>
<li>pointer member type</li>
<li>enumeration type</li>
<li>std::nullptr_t (自从C++11)</li>
<li>floating type (自从C++20)</li>
</ul>
</li>
<li>
<p>type template parameter</p>
</li>
<li>
<p>template template parameter</p>
</li>
</ol>
</li>
<li>
<p>C++ Template 定义为什么通常都在头文件中?</p>
<p>因为 Template 定义必须在模板隐式实例化(<a href="https://lucmann.github.io/p/cpp-template/">implicit instantiation</a>)之前，通常我们在<code>.cpp</code> 源文件里直接使用模板都属于隐式实例化。所以将模板定义在头文件中，可以有效防止模板实例化之前没有定义。</p>
</li>
<li>
<p><code>std::endl</code> 和 <code>\n</code> 有何区别？</p>
<p>对 <code>std::endl</code> 的每次调用都会 flush output buffer</p>
</li>
<li>
<p>Qt</p>
<ul>
<li>信号与槽</li>
<li>对象管理</li>
</ul>
</li>
<li>
<p>pure virtual vs. virtual function</p>
</li>
<li>
<p>g++ 指定 -std=c++11</p>
</li>
<li>
<p>并行编程模型/框架，多线程</p>
<ul>
<li>std::atomic</li>
<li>std::thread</li>
</ul>
</li>
</ul>
<h1 id="linux-c"><a class="markdownIt-Anchor" href="#linux-c"></a> Linux &amp; C</h1>
<ul>
<li>vim 有哪几种工作模式</li>
</ul>
<p>Normal mode:</p>
<p>a<br />
10yy<br />
dgg<br />
dG<br />
10j</p>
<p>Command-line mode:</p>
<p>10,.y<br />
g/^$/d<br />
s/hello//<br />
s/hello//g<br />
s/Hello,/&amp; World/</p>
<ul>
<li>gdb common commands</li>
</ul>
<p>backtrace (bt)<br />
command (comm)<br />
continue ©<br />
finish (fin)<br />
frame (frame)</p>
<ul>
<li>
<p>epoll vs. poll vs. select</p>
</li>
<li>
<p>C 中的 <code>static</code> 关键字常见用法</p>
</li>
</ul>
<h1 id="gpuimage-如果使用-opengl-es-20为什么不能在-iphone-iphone-3g-和-1st-and-2nd-generation-ipod-touches-上运行"><a class="markdownIt-Anchor" href="#gpuimage-如果使用-opengl-es-20为什么不能在-iphone-iphone-3g-和-1st-and-2nd-generation-ipod-touches-上运行"></a> GPUImage 如果使用 OpenGL ES 2.0，为什么不能在 iPhone, iPhone 3G 和 1st and 2nd generation iPod touches 上运行?</h1>
<h1 id="opengl-es-到目前为止一共有几个版本"><a class="markdownIt-Anchor" href="#opengl-es-到目前为止一共有几个版本"></a> OpenGL ES 到目前为止一共有几个版本？</h1>
<p>1.0, 1.1, 2.0 (开始支持 shader), 3.0, 3.1, 3.2</p>
<h1 id="glsl-语言里-vs-fs-里的内置变量和内置函数"><a class="markdownIt-Anchor" href="#glsl-语言里-vs-fs-里的内置变量和内置函数"></a> GLSL 语言里 vs fs 里的内置变量和内置函数</h1>
<ul>
<li>vs
<ul>
<li><code>gl_VertexID</code></li>
<li><code>gl_InstanceID</code></li>
<li><code>gl_Position</code></li>
<li><code>gl_PointSize</code></li>
</ul>
</li>
<li>fs
<ul>
<li><code>in   highp   vec4    gl_FragCoord</code></li>
<li><code>in           bool    gl_FrontFacing</code></li>
<li><code>out  highp   float   gl_FragDepth</code></li>
<li><code>in   mediump vec2    gl_PointCoord</code></li>
</ul>
</li>
</ul>
<h1 id="glsl-语言里-varying-vs-uniform-的区别"><a class="markdownIt-Anchor" href="#glsl-语言里-varying-vs-uniform-的区别"></a> GLSL 语言里 Varying vs Uniform 的区别</h1>
<h1 id="举一个滤镜的例子说说它的实现和算法及使用到的-opengl-es-的扩展功能"><a class="markdownIt-Anchor" href="#举一个滤镜的例子说说它的实现和算法及使用到的-opengl-es-的扩展功能"></a> 举一个滤镜的例子，说说它的实现和算法，及使用到的 OpenGL ES 的扩展/功能</h1>
<h1 id="说说-ogre-渲染引擎的优缺点"><a class="markdownIt-Anchor" href="#说说-ogre-渲染引擎的优缺点"></a> 说说 OGRE 渲染引擎的优缺点</h1>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Template</title>
    <url>/prog/cpp-template/</url>
    <content><![CDATA[<h1 id="c中的模板"><a class="markdownIt-Anchor" href="#c中的模板"></a> C++中的模板</h1>
<p>C++中的模板可分为class template和function template. 它们之间存在不同，例如，function template不能partially specialized(偏特化)</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="function">T <span class="title">f</span><span class="params">(U obj)</span></span>; <span class="comment">// Primary template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="type">void</span> <span class="built_in">f</span>&lt;<span class="type">void</span>, U&gt;(U obj); <span class="comment">// Illegal</span></span><br></pre></td></tr></table></figure>
<h1 id="模板实例化template-instantiation"><a class="markdownIt-Anchor" href="#模板实例化template-instantiation"></a> 模板实例化(Template Instantiation)</h1>
<p>模板的实例化分为Explicit Instantiation和Implicit Instantiation.</p>
<h2 id="explicit-instantiation"><a class="markdownIt-Anchor" href="#explicit-instantiation"></a> Explicit Instantiation</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::out &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;  <span class="comment">// Primary template definition</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">f</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span>); <span class="comment">// explicit instantiation</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> f&lt;&gt;(<span class="type">char</span>);  <span class="comment">// explicit instantiation, template args deduced</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">// explicit instantiation, template args deduced</span></span><br></pre></td></tr></table></figure>
<h2 id="implicit-instantiation"><a class="markdownIt-Anchor" href="#implicit-instantiation"></a> Implicit Instantiation</h2>
<p>实际中，我们使用模板的大多数时候都是 implicit instantiation, 即我们一般不会像上面一样，显式地声明一个具体类型的模板实例，更常见的是直接声明一个模板实例(type)的对象(object)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span>... A&gt; <span class="keyword">class</span> <span class="title class_">NonTypeVariadicTemplate</span> &#123;&#125;;  <span class="comment">// should be in .h</span></span><br><span class="line"></span><br><span class="line">NonTypeVariadicTemplate&lt;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&gt; ntvt; <span class="comment">// implicit instantiation</span></span><br></pre></td></tr></table></figure>
<h1 id="模板特化template-specialisation"><a class="markdownIt-Anchor" href="#模板特化template-specialisation"></a> 模板特化(template specialisation)</h1>
<p>模板特化是C++泛型编程的一个重要技术，它的一个典型应用就是type trait的实现</p>
<h2 id="全特化full-specialisation"><a class="markdownIt-Anchor" href="#全特化full-specialisation"></a> 全特化(full specialisation)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_boolean</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;; <span class="comment">// primary template</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_boolean</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;; <span class="comment">// full specialization</span></span><br></pre></td></tr></table></figure>
<h2 id="偏特化partial-specialisation"><a class="markdownIt-Anchor" href="#偏特化partial-specialisation"></a> 偏特化(partial specialisation)</h2>
<p>虽然模板类的全特化是一个重要的泛型编程技术，但有时候我们可能需要一个介于完全泛化和全特化之间的一个特化版本，这就是偏特化。下面的例子<code>is_pointer&lt;T&gt;</code>，这里我们需要一个完全泛化的模板版本来处理所有<code>T</code>不是一个指针类型的情形，而需要一个偏特化版本来处理所有<code>T</code>是一个指针类型的情形。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;; <span class="comment">// primary version that handles all the cases where T is not a pointer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;; <span class="comment">// partial specialisation to handle all the cases where T is a pointer</span></span><br></pre></td></tr></table></figure>
<p>从上面两个例子<code>is_boolean&lt;T&gt;</code>和<code>is_pointer&lt;T&gt;</code>可以看出，全特化和偏特化的语法有明显区别，偏特化在类名后面的尖括号<code>&lt;&gt;</code>里仍然包含模板参数，像 <code>&lt;T*&gt;</code>, 而全特化类名后面的<code>&lt;&gt;</code>里已经不包含任何模板参数 (如 <code>T</code>)，而全部是具体的类型, 像 <code>&lt;bool&gt;</code>。</p>
<p>下面的例子是一个更复杂的偏特化的例子<code>remove_bounds&lt;T&gt;</code>, 这个模板类仅仅定义一个与<code>T</code>类型相同的typedef成员类型，但是高层的数组关联被移除了，这样的模板类可以完成一个类型的转化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_bounds</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;; <span class="comment">// primary version</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_bounds</span>&lt;T[N]&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;; <span class="comment">// partial specialisation</span></span><br></pre></td></tr></table></figure>
<p>从这个例子可以看出:</p>
<ul>
<li>
<p>偏特化版本的模板参数(形参)的个数不一定和默认模板的相等</p>
<ul>
<li>即 <code>&lt;typename T, std::size_t N&gt;</code> 比默认模板多出了 <code>std::size_t N</code></li>
</ul>
</li>
<li>
<p>偏特化版本的类名后面的模板参数(实参)的个数和类型必须匹配默认模板的参数的个数和类型</p>
<ul>
<li>即 <code>remove_bounds&lt;T[N]&gt;</code> 中的 <code>T[N]</code>, 个数匹配指 <code>T[N]</code> 对应主模板里 <code>T</code>， 类型匹配指 <code>T[N]</code> 中的 <code>T</code> 匹配主模板里的 <code>T</code></li>
</ul>
</li>
</ul>
<h1 id="typename-vs-class"><a class="markdownIt-Anchor" href="#typename-vs-class"></a> <code>typename</code> vs <code>class</code></h1>
<p>大多数情况下，<code>typename</code>和<code>class</code>可以互换使用，但它们也有不能互换的时候，下面的情况只能使用<code>typename</code>关键字:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Option</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OptTraits</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Option::ValueType ValueType;</span><br><span class="line">&#125;;  <span class="comment">// Indicates Option::ValueType is a type</span></span><br></pre></td></tr></table></figure>
<h1 id="template-parameters-vs-template-arguments"><a class="markdownIt-Anchor" href="#template-parameters-vs-template-arguments"></a> template parameters vs template arguments</h1>
<p>template parameters之于template arguments相当于函数的形参之于实参。C++模板的通用语法是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;parameter-list&gt; declaration</span><br></pre></td></tr></table></figure>
<p>parameter-list中的每个形参都可以是下列3种中的任何一种:</p>
<ul>
<li>non-type template parameter</li>
<li>type template parameter</li>
<li>template template parameter</li>
</ul>
<h2 id="模板类的模板构造函数"><a class="markdownIt-Anchor" href="#模板类的模板构造函数"></a> 模板类的模板构造函数</h2>
<p>模板类的模板构造函数，意思是一个模板类的一个构造函数也是一个模板函数。这种情况有两点需要注意:</p>
<ul>
<li>模板类的模板参数名不能和构造函数的模板参数名相同 (<em>template parameter</em> cannot share the same name)</li>
<li>不能显式地指定模板构造函数的模板实参 (cannot explicitly specify <em>template argument</em> for constructor)</li>
</ul>
<p>这种情况可以很好的体现template parameter和template argument的区别，请看下面的例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OptName&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Option</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> OptName::ValueType ValueType;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="type">size_t</span> NumNamedValues&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Option</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* shortName_</span></span></span><br><span class="line"><span class="params"><span class="function">         , <span class="type">const</span> <span class="type">char</span>* longName_</span></span></span><br><span class="line"><span class="params"><span class="function">         , <span class="type">const</span> <span class="type">char</span>* description_</span></span></span><br><span class="line"><span class="params"><span class="function">         , <span class="type">const</span> NamedValue&lt;ValueType&gt; (&amp;namedValues_)[NumNamedValues]</span></span></span><br><span class="line"><span class="params"><span class="function">         , <span class="type">const</span> <span class="type">char</span>* defaultValue_ = DE_NULL)</span></span></span><br><span class="line"><span class="function">         : shortName(shortName_)</span></span><br><span class="line"><span class="function">         , longName(longName_)</span></span><br><span class="line"><span class="function">         , description(description_)</span></span><br><span class="line"><span class="function">         , defaultValue(defaultValue_)</span></span><br><span class="line"><span class="function">         , parse((ParseFunc)DE_NULL)</span></span><br><span class="line"><span class="function">         , namedValues(DE_ARRAY_BEGIN(namedValues_))</span></span><br><span class="line"><span class="function">         , namedValuesEnd(DE_ARRAY_END(namedValues_))</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> NamedValue&lt;<span class="type">bool</span>&gt; s_enableNames[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;enable&quot;</span>, <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;disable&quot;</span>, <span class="literal">false</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiation to call constructor above</span></span><br><span class="line">Option&lt;TestOOM&gt; opt = <span class="built_in">Option</span>&lt;TestOOM&gt;(DE_NULL, <span class="string">&quot;deqp-test-oom&quot;</span>, <span class="string">&quot;Run tests that exhaust memory&quot;</span>, s_enableNames, <span class="string">&quot;disable&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>从这个例子看到模板构造函数被调用时本该指定的non-type template argument(size_t) <code>NumNamedValues</code>并没有被指定, 原因是模板函数的template argument list应该紧跟在函数名后面，但是构建函数模板(类型转换函数模板conversion member function template也是同样情况)被调用的时候<strong>不使用函数名</strong>，所以没有一种方法可以显式地指定</p>
<ul>
<li>constructor member function template</li>
<li>conversion member function template</li>
</ul>
<p>的template argument list.</p>
<h1 id="constraints-rules"><a class="markdownIt-Anchor" href="#constraints-rules"></a> Constraints &amp; Rules</h1>
<ul>
<li>Explicit instantiation时，如果可以从function parameter推导出类型，可以省去template args.</li>
<li>Function template或class template的member function的Explicit实例化不能使用<code>inline</code>和<code>constexpr</code>关键字。</li>
<li>Different template instantiations are distinct types.</li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM</title>
    <url>/prog/llvm/</url>
    <content><![CDATA[<h1 id="llvm-llvm-project"><a class="markdownIt-Anchor" href="#llvm-llvm-project"></a> LLVM &amp; llvm-project</h1>
<p>LLVM 是 Low-Level Virtual Machine 的简写，但事实上它与虚拟机关系不大。我们更熟悉它是一套工具链，包括 clang <code>/'klæŋ/</code>, lld, lldb 等等。接触 LLVM 是因为 Mesa llvmpipe 使用 LLVM, 还有 AMDGPU 和 Radeon 的编译器后端都使用 LLVM IR，所以要编译 Mesa 的 <code>-Dgallium-drivers=llvmpipe,radeonsi</code> 都依赖于 LLVM 的诸多组件, 构建 Linux 内核的 <a href="https://massoudasadiblog.blogspot.com/2024/07/ebpf-on-wsl2-kernel-version-6x-ubuntu.html">eBPF</a> 程序也依赖 LLVM, 构建 <a href="https://perfetto.dev/docs/quickstart/linux-tracing#building-from-source">perfetto</a> 也依赖 LLVM。这里主要记录 LLVM 的构建和使用的一些问题。</p>
<span id="more"></span>
<p>llvm-project 是 2003 年开源的。2022 年初，llvm-project 的源码库和 bug tracker 被移到了 <a href="https://github.com/llvm/llvm-project">GitHub</a>. 一开始，LLVM 的社区交流和项目沟通主要方式是 Mailing Lists 和 <a href="https://lucmann.github.io/misc/english/">IRC</a>, 在 2019 年，LLVM 社区转向 <a href="https://www.discourse.org/">Discourse</a> 这个开源社区交流平台。</p>
<h1 id="build-llvm"><a class="markdownIt-Anchor" href="#build-llvm"></a> Build LLVM</h1>
<ul>
<li><code>cmake -S llvm -B build</code>
<ul>
<li>llvm 是 llvm-project 根目录下的一个子目录，是我们的编译对象，像 lld, 还有 c++ 运行时库这里不需要构建</li>
</ul>
</li>
<li><code>-G &quot;Ninja&quot;</code>
<ul>
<li>使用 ninja 构建系统</li>
</ul>
</li>
<li><code>-DCMAKE_BUILD_TYPE=Debug</code>
<ul>
<li>默认是 <code>-DCMAKE_BUILD_TYPE=Release</code></li>
</ul>
</li>
<li><code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code>
<ul>
<li>生成 compile_commands.json 索引数据库(导入 IDE)</li>
</ul>
</li>
<li><code>-DCMAKE_INSTALL_PREFIX=~/.local/llvm</code>
<ul>
<li>自定义安装路径，默认是 /usr/local</li>
<li>安装路径在安装之后也可以通过 <code>llvm-config --prefix --ldflags</code> 查到</li>
</ul>
</li>
<li><code>-DBUILD_SHARED_LIBS=ON</code>
<ul>
<li><code>BUILD_SHARED_LIBS</code> 是一个 CMake 选项，当它开启时，那些没有指明 STATIC, SHARED, MODULE 的构建目标都会被构建成 SHARED 库。这个一般要开启，否则会导致在链接器进程因 OOM 被 Killed (因为可执行程序由静态库们组装而成, 内存不够用)</li>
</ul>
</li>
<li><code>-DLLVM_LIBDIR_SUFFIX=64</code>
<ul>
<li>如果是 64 位系统，安装路径会由原来 <code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code> 变成 <code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib64</code></li>
</ul>
</li>
<li><code>-DLLVM_BUILD_LLVM_DYLIB=OFF</code>
<ul>
<li>如果 ON，将所有 LLVM 组件生成一个单一的共享库 libLLVM, 适用于将 LLVM 嵌入到其它工具中的情况</li>
</ul>
</li>
<li><code>-DLLVM_ENABLE_PROJECTS=&quot;clang;lld&quot;</code>
<ul>
<li>只构建 clang 和 lld (LLVM Linker) 子项目, 可选项目包括:
<ul>
<li>bolt;clang;clang-tools-extra;compiler-rt;cross-project-tests;libc;libclc;lld;lldb;mlir;openmp;polly</li>
</ul>
</li>
</ul>
</li>
<li><code>-DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot;</code>
<ul>
<li>升级 <code>libc++.so.1</code>, 比如要将 clang++ 支持的 c++ 标准库升级到 c<ins>2x (clang-16 以上支持 c</ins>20), 可选 runtime 包括：
<ul>
<li>libc;libunwind;libcxxabi;libcxx;compiler-rt;openmp;llvm-libgcc;offload</li>
</ul>
</li>
</ul>
</li>
<li><code>-DLLVM_TARGETS_TO_BUILD=&quot;BPF;AMDGPU;host&quot;</code>
<ul>
<li>指定支持哪些后端(ISA), 这里如果是为了编译 Mesa Radeon/AMDGPU, <code>AMDGPU</code> target 必须指定。<code>host</code>是指当前编译机器。另外指定的越多，编译越耗时</li>
<li>安装后可通过 <code>llvm-config --targets-built</code> 获取</li>
</ul>
</li>
<li><code>-DLLVM_PARALLEL_COMPILE_JOBS=1 -DLLVM_PARALLEL_LINK_JOBS=1</code>
<ul>
<li>在编译机配置不高的时候，减小 <code>cc1plus</code> 和 <code>ld</code> 被 OOM-Killed 的风险</li>
<li>当配置 <code>-DCMAKE_BUILD_TYPE=Debug</code> 时，即使将上面两个选项都配置为 1，仍然很大可能会被 OOM-Killed (问题不是 CPU 线程多少，而是内存需求过大)。这时最极解决方法是增大 swap 分区:
<ul>
<li><code>sudo fallocate -l 4G /swapfile</code>
<ul>
<li>比 <code>dd if=/dev/zero of=/swapfile bs=1 count=0 seek=4G</code> 快一点</li>
<li>当 <code>-DBUILD_SHARED_LIBS=OFF</code> (构建 LLVM 为静态库) 时，最好 10G<br />
<img src="/images/llvm/static-link.png" alt="how horrible static linking is" /></li>
</ul>
</li>
<li><code>sudo chmod 600 /swapfile</code></li>
<li><code>sudo mkswap /swapfile</code>
<ul>
<li>格式化成 swap 分区</li>
</ul>
</li>
<li><code>sudo swapon /swapfile</code>
<ul>
<li>激活 swap 分区</li>
</ul>
</li>
<li>增大 swap 分区后的效果<br />
<img src="/images/llvm/mkswap-4G.gif" alt="" /></li>
</ul>
</li>
</ul>
</li>
<li><code>-DLLVM_USE_LINKER=gold</code>
<ul>
<li>将默认链接器 <code>bfd</code> 换成 <code>gold</code> (可能会链接得快一点)</li>
<li>一般 Linux 系统上默认安装有两个链接器
<ul>
<li>/usr/bin/ld -&gt; x86_64-linux-gnu-ld</li>
<li>/usr/bin/ld.bfd -&gt; x86_64-linux-gnu-ld.bfd</li>
<li>/usr/bin/ld.gold -&gt; x86_64-linux-gnu-ld.gold</li>
</ul>
</li>
<li><code>-DLLVM_USE_LINKER=gold</code><br />
<img src="/images/llvm/gold.gif" alt="/usr/bin/ld.gold" /></li>
</ul>
</li>
</ul>
<p>安装后，我们需要将 <code>bin</code> 目录加入 <code>PATH</code>, 并创建 <code>/etc/ld.so.conf.d/llvm.conf</code> 包含下面一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/luc/.local/llvm/lib64</span><br></pre></td></tr></table></figure>
<h1 id="building-llvmpipe"><a class="markdownIt-Anchor" href="#building-llvmpipe"></a> Building llvmpipe</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">llvm-config found: YES (/home/luc/.local/llvm/bin/llvm-config) 15.0.0</span><br><span class="line">Run-time dependency LLVM (modules: bitwriter, core, engine, executionengine, instcombine, mcdisassembler, mcjit, native, scalaropts, transformutils, coroutines) found: YES 15.0.0</span><br><span class="line">Run-time dependency valgrind found: NO (tried pkgconfig)</span><br><span class="line">Program bison found: YES (/usr/bin/bison)</span><br><span class="line">Program bison found: YES (/usr/bin/bison)</span><br><span class="line">Program flex found: YES (/usr/bin/flex)</span><br><span class="line">Run-time dependency libunwind found: NO (tried pkgconfig and cmake)</span><br><span class="line">Run-time dependency OpenMP found: YES 4.5</span><br><span class="line">Run-time dependency x11 found: YES 1.6.9</span><br><span class="line">Run-time dependency xext found: YES 1.3.4</span><br><span class="line">Run-time dependency xfixes found: YES 5.0.3</span><br><span class="line">Run-time dependency xcb-glx found: NO (tried pkgconfig and cmake)</span><br><span class="line">Message: Configuration summary:</span><br><span class="line"></span><br><span class="line">        prefix:          /usr</span><br><span class="line">        libdir:          lib/x86_64-linux-gnu</span><br><span class="line">        includedir:      include</span><br><span class="line"></span><br><span class="line">        OpenGL:          yes (ES1: yes ES2: yes)</span><br><span class="line">        OSMesa:          no</span><br><span class="line"></span><br><span class="line">        DRI platform:    drm</span><br><span class="line">        DRI drivers:     no</span><br><span class="line">        DRI driver dir:  /usr/lib/x86_64-linux-gnu/dri</span><br><span class="line"></span><br><span class="line">        GLX:             DRI-based</span><br><span class="line"></span><br><span class="line">        EGL:             yes</span><br><span class="line">        EGL drivers:     builtin:egl_dri2 builtin:egl_dri3</span><br><span class="line">        EGL/Vulkan/VL platforms:   x11 surfaceless drm xcb</span><br><span class="line">        GBM:             yes</span><br><span class="line">        GBM backends path: /usr/lib/x86_64-linux-gnu/gbm</span><br><span class="line"></span><br><span class="line">        Vulkan drivers:  swrast</span><br><span class="line">        Vulkan ICD dir:  share/vulkan/icd.d</span><br><span class="line"></span><br><span class="line">        llvm:            yes</span><br><span class="line">        llvm-version:    15.0.0</span><br><span class="line"></span><br><span class="line">        Gallium drivers: swrast</span><br><span class="line">        Gallium st:      mesa</span><br><span class="line">        HUD lmsensors:   no</span><br><span class="line"></span><br><span class="line">        Shared-glapi:    yes</span><br><span class="line"></span><br><span class="line">        Perfetto:        no</span><br><span class="line">        Perfetto ds:     auto</span><br><span class="line"></span><br><span class="line">Build targets in project: 174</span><br></pre></td></tr></table></figure>
<p>当编译 Mesa 时，遇到的第一个编译错误是 <code>No such file or directory</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">../src/gallium/auxiliary/gallivm/lp_bld_init.c:52:10: fatal error: llvm-c/Transforms/Coroutines.h: No such file or directory                                                                                                                       52 | #include &lt;llvm-c/Transforms/Coroutines.h&gt;                                                                             |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                                                                       compilation terminated.</span><br></pre></td></tr></table></figure>
<p>这个问题似乎不好解决，我转向构建 LLVM 14.0.6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  llvm-project git:(14.0.6) cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=On -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;lld&quot;</span> -DLLVM_ENABLE_RUNTIMES=<span class="string">&quot;libcxx;libcxxabi&quot;</span> -DCMAKE_INSTALL_PREFIX=~/.local/llvm-14 -DLLVM_LIBDIR_SUFFIX=<span class="string">&quot;64&quot;</span> -DLLVM_TARGETS_TO_BUILD=<span class="string">&quot;host&quot;</span> -DLLVM_BUILD_LLVM_DYLIB=On -DBUILD_SHARED_LIBS=On -DLLVM_PARALLEL_COMPILE_JOBS=1 -DLLVM_PARALLEL_LINK_JOBS=1 -DLLVM_USE_LINKER=gold</span><br></pre></td></tr></table></figure>
<p>但又遇到下面的错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMake Error at /home/luc/gh/llvm-project/libcxx/CMakeLists.txt:880 (message):                                             LIBCXX_ABI_NAMESPACE &#x27;__1&#x27; is reserved for use by libc++.                                                                                                                                                                                                                                                                                                             -- Configuring incomplete, errors occurred!</span><br></pre></td></tr></table></figure>
<p>查看 <code>libcxx/CMakeLists.txt</code> 发现 <code>LIBCXX_ABI_NAMESPACE</code> 是一个 CMake 变量, 而且被缓存了，难怪第一次构建时没有报这个错误，所以在编译新的 LLVM 之前一次记得将原来的构建目录删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(LIBCXX_ABI_NAMESPACE &quot;&quot; CACHE STRING &quot;The inline ABI namespace used by libc++. It defaults to __n where `n` is the  current ABI version.&quot;)</span><br></pre></td></tr></table></figure>
<h1 id="llvm-jit"><a class="markdownIt-Anchor" href="#llvm-jit"></a> LLVM JIT</h1>
<ul>
<li>Just-In-Time</li>
<li>Ahead-Of-Time</li>
</ul>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://sh4dy.com/2024/11/24/learning_llvm_03/">Learning LLVM Part-3</a></li>
</ul>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程中的同步</title>
    <url>/prog/mt/</url>
    <content><![CDATA[<h1 id="同步原语"><a class="markdownIt-Anchor" href="#同步原语"></a> 同步原语</h1>
<p>同步原语(Synchronization Primitive)的<a href="https://www.cs.columbia.edu/~hgs/os/sync.html">确切定义没有一个官方的</a>。但大体来说同步原语可能有以下几种:</p>
<ul>
<li>semaphores</li>
<li>mutex</li>
<li>locks</li>
<li>condition variables</li>
<li>test-and-set machine instructions</li>
</ul>
<span id="more"></span>
<p>但这些同步原语是如何实现多线程同步的呢？</p>
<ul>
<li>当我们谈论线程同步时，我们在说什么？</li>
</ul>
<p>当我们谈论线程同步时，所谓同步，就是必须保证多个线程对同一数据的预期访问次序，也就是&quot;临界区&quot;的保护。之所以多个线程对同一数据的访问可能会产生不预期的结果，是因为内存(这块全局可见存储)中的数据可能会因为CPU读写顺序的差异导致其与各个CPU(核心)本地缓存中的数据不一致。所以线程同步，实质上就是需要保证如果一个CPU核心要读内存之前，另一个CPU已经将新值写入那个地址的内存，如果没有写入，就要让所有准备执行读操作的CPU核心停下来。这个过程中我们不难发现有两个关键点: CPU所执行指令(读写操作)的原子性和内存数据的可见性(本地缓存是否更新到内存)。</p>
<ul>
<li>原子操作</li>
<li>内存屏障</li>
</ul>
<h2 id="xshmfence"><a class="markdownIt-Anchor" href="#xshmfence"></a> xshmfence</h2>
<ul>
<li>基于 futex 和原子操作实现  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">xshmfence_await</span><span class="params">(<span class="keyword">struct</span> xshmfence *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (__sync_val_compare_and_swap(&amp;f-&gt;v, <span class="number">0</span>, <span class="number">-1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (futex_wait(&amp;f-&gt;v, <span class="number">-1</span>)) &#123; <span class="comment">// blocking the caller process until f-&gt;v reaches to 0</span></span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>基于 pthread 条件变量实现</li>
</ul>
<h1 id="posix-threads-实现-lpthread"><a class="markdownIt-Anchor" href="#posix-threads-实现-lpthread"></a> POSIX Threads 实现 - <code>-lpthread</code></h1>
<h2 id="spinlock"><a class="markdownIt-Anchor" href="#spinlock"></a> Spinlock</h2>
<p>自旋锁是解决多处理器共享内存使用的一种底层同步机制。当一个线程试图获取一个已经被另一个线程占有的自旋锁时，这个线程将以循环检查自旋锁是否被释放的方式(自旋)阻塞。一个线程不应该长时间占有一个自旋锁，因为被阻塞的线程仍然消耗CPU资源 (CPU cycles)</p>
<h3 id="posix-interfaces"><a class="markdownIt-Anchor" href="#posix-interfaces"></a> POSIX interfaces</h3>
<h4 id="initializing-a-spinlock"><a class="markdownIt-Anchor" href="#initializing-a-spinlock"></a> Initializing a Spinlock</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_init</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock, <span class="type">int</span> pshared)</span>; </span><br></pre></td></tr></table></figure>
<p><code>pshared</code>属性可以取以下值的其中之一:</p>
<p>PTHREAD_PROCESS_SHARED - 这个自旋锁可以被任何线程操作，即使这些线程属于不同的进程，只要申请这个自旋锁的内存是被这些进程共享的。</p>
<p>PTHREAD_PROCESS_PRIVATE - 这个自旋锁只能被那些与初始化它的线程同属一个进程的线程操作。</p>
<h4 id="acquiring-a-spinlock"><a class="markdownIt-Anchor" href="#acquiring-a-spinlock"></a> Acquiring a Spinlock</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_lock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure>
<p>如果被请求的自旋锁没有被其它线程占有，则请求它的线程成功获取这个锁，否则这个线程不从<code>pthread_spin_lock</code>中返回(阻塞)，直到这个锁被释放。一个线程尝试获取被它自己占有的自旋锁是未定义的行为。</p>
<h4 id="acquiring-a-non-blocking-spinlock"><a class="markdownIt-Anchor" href="#acquiring-a-non-blocking-spinlock"></a> Acquiring a Non-Blocking Spinlock</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_trylock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure>
<p>尝试获取一个自旋锁，与<code>pthread_spin_lock</code>不同的是，如果所请求的锁被另一个线程占有，不阻塞，而是立即返回失败(Non-Blocking).</p>
<h4 id="unlocking-a-spinlock"><a class="markdownIt-Anchor" href="#unlocking-a-spinlock"></a> Unlocking a Spinlock</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_unlock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure>
<p>释放被锁的自旋锁。成功返回0，否则返回以下错误码之一:</p>
<p>EPERM - 调用线程不持有这个锁</p>
<p>EINVAL - lock指向的不是一个已初始化的自旋锁对象</p>
<h4 id="destroying-a-spinlock"><a class="markdownIt-Anchor" href="#destroying-a-spinlock"></a> Destroying a Spinlock</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_destroy</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="无锁队列"><a class="markdownIt-Anchor" href="#无锁队列"></a> 无锁队列</h1>
<p>无锁队列的实现依靠的是CPU提供的原子操作指令(atomic) 和比较和交换指令 (cas). 其中cas 指令还有一种 double-width cas (dwcas), 就是能在 64位机器上原子地进行 128位(dword)值的cas (在 aarch64 cas 和 dwcas 是同一条指令)，CPU是否支持dwcas, 影响实现无锁队列时的一个策略，即队列容量是否固定。</p>
<h2 id="aba-问题"><a class="markdownIt-Anchor" href="#aba-问题"></a> ABA 问题</h2>
<p>无锁数据结构通常采用的是一种简单的“重试”策略，它的思想是线程0 获取一个ptr, 访问它指向的数据，然后尝试更新这个 ptr的值(通过 cas), 如果发现这个 ptr 已经变了(cas 比较测试失败), 那就重新获取有新值的ptr, 再访问新ptr 指向的数据。</p>
<p>ABA 问题出现的场景是，在线程0，前后两次读到ptr 的值的中间，有可能线程1，已经修改过 ptr 的值由A 到 B，而后又在线程0 cas 操作前，线程1又<strong>恰巧</strong>在地址A申请到一个元素遂将ptr 的值又改回A, 结果就是线程1对ptr 的修改(A-&gt;B-&gt;A)对线程0不可见，而实际上A指向的内容可能已经发生变化，对线程0来说可能导致未预期的结果。</p>
<p>这种场景的ABA问题可以通过将原来单独的一个ptr (64位系统上sizeof(ptr) = 8), 替换成一对(ptr, counter)来解决。每次ptr 被修改，counter就+1, 这样即使最后ptr 是相等的(A-&gt;B-&gt;A), 但counter 也不相等，这样只要同时对(ptr, counter) 做 cas 比较就可以准确判定ptr 是否被修改过(如果修改过，即使现在的值和之前的值相等，仍然要重新获取这个值，再次访问它指向的内容)。但现在要比较的数据由原来的8字节变成16字节，所以就需要 dwcas 指令。</p>
<p>由上面ABA问题的分析可以看到，之所以对线程0来说，A指向的内容可能会发生变化，原因是中间存在申请内存的操作。所以只要保证在整个队列操作中，不会动态申请元素(没有了线程1恰巧又重新分配的A这个地址的可能)，这种场景的ABA问题也就不存在了。这就是为什么 CPU 如果不支持 dwcas, 则无锁队列的容量必须是固定大小的。</p>
<h2 id="boostlockfreequeue-源码分析"><a class="markdownIt-Anchor" href="#boostlockfreequeue-源码分析"></a> boost::lockfree::queue 源码分析</h2>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3>
<ul>
<li>出队</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pop(Q: pointer to <span class="built_in">queue</span>, ret: pointer to data type): boolean</span><br><span class="line">D1:    loop                             # Keep trying until pop is done</span><br><span class="line">D2:      head = Q-&gt;Head                 # Read Head</span><br><span class="line">D3:      tail = Q-&gt;Tail                 # Read Tail</span><br><span class="line">D4:      next = head-&gt;next              # Read Head.ptr-&gt;next</span><br><span class="line">D5:      <span class="keyword">if</span> head == Q-&gt;Head             # Are head, tail, and next consistent?</span><br><span class="line">D6:        <span class="keyword">if</span> head.ptr == tail.ptr      # Is <span class="built_in">queue</span> empty or Tail falling bebind?</span><br><span class="line">D7:          <span class="keyword">if</span> next.ptr == <span class="literal">NULL</span>        # Is <span class="built_in">queue</span> empty?</span><br><span class="line">D8:            <span class="keyword">return</span> FALSE             # Queue is empty, couldn<span class="number">&#x27;</span>t pop</span><br><span class="line">D9:          endif</span><br><span class="line">             # Tail is falling behind. Try to advance it</span><br><span class="line">D10:         CAS(&amp;Q-&gt;Tail, tail, &lt;next.ptr, tail.count+<span class="number">1</span>&gt;)</span><br><span class="line">D11:       <span class="keyword">else</span>                         # No need to deal with Tail</span><br><span class="line">             # Read value before CAS, otherwise another pop might <span class="built_in">free</span> the next node</span><br><span class="line">D12:         *ret = next.ptr-&gt;value</span><br><span class="line">             # Try to swing Head to the next node</span><br><span class="line">D13:         <span class="keyword">if</span> CAS(&amp;Q-&gt;Head, head, &lt;next.ptr, head.count+<span class="number">1</span>&gt;)</span><br><span class="line">D14:           <span class="keyword">break</span>                    # Pop is done, Exit loop</span><br><span class="line">D15:         endif</span><br><span class="line">D16:       endif</span><br><span class="line">D17:     endif</span><br><span class="line">D18:   endloop</span><br><span class="line">D19:   <span class="built_in">free</span>(head.ptr)                   # It is safe now to <span class="built_in">free</span> the old dummy node</span><br><span class="line">D20:   <span class="keyword">return</span> TRUE                      # Queue was not empty, pop succeeded </span><br></pre></td></tr></table></figure>
<h3 id="c实现"><a class="markdownIt-Anchor" href="#c实现"></a> C++实现</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">private:</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt; tagged_node_handle &gt; head_;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt; tagged_node_handle &gt; tail_;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">memory_order</span> &#123;</span></span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst, <span class="comment">// Sequentially-consistent ordering</span></span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure>
<p>这个memory_order的顺序，由上到下对原子变量的操作和读写顺序的保证应该是越来越严格的(没有读写顺序保证-&gt;单个原子变量读写顺序保证-&gt;全局读写顺序一致)。</p>
<ul>
<li>
<p><code>memory_order_relaxed</code>只保证原子操作，不保证指令顺序。</p>
</li>
<li>
<p><code>memory_order_acquire</code></p>
<ul>
<li>用于 <code>atomic&lt;T&gt;::load()</code></li>
<li>对于使用memory_order_acquire的指令，该指令后面的所有读写操作<strong>不能重排在该指令之前</strong></li>
<li>当前线程执行的memory_order_acquire指令能够保证读到其他线程memory_order_release指令之前的所有内存写入操作</li>
</ul>
</li>
<li>
<p><code>memory_order_release</code></p>
<ul>
<li>用于 <code>atomic&lt;T&gt;::store()</code></li>
<li>对于使用memory_order_release的指令，该指令之前的所有读写操作<strong>不能重排在该指令之后</strong></li>
<li>当前线程memory_order_release指令之前的所有内存写操作对于其他线程的memory_order_acquire指令都可见。</li>
</ul>
</li>
<li>
<p><code>memory_order_acq_rel</code></p>
<ul>
<li>用于 <code>atomic&lt;T&gt;::fetch_add()</code>, <code>atomic&lt;T&gt;::compare_exchange_weak()</code> 这类 read-modify-write 操作。如果用在普通的 <code>atomic&lt;T&gt;::load()</code>，效果与用memory_order_acquire 无异。</li>
<li>把 memory_order_acquire 和 memory_order_release 结合起来，它可以保证单个原子变量的读写顺序，下面的例子就是不适用 memory_order_acq_rel 的</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_x</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    x.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_y</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    y.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_x_then_y</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.load(<span class="built_in">std</span>::memory_order_acq_rel))</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">if</span> (y.load(<span class="built_in">std</span>::memory_order_acq_rel))</span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_y_then_x</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.load(<span class="built_in">std</span>::memory_order_acq_rel))</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">if</span> (x.load(<span class="built_in">std</span>::memory_order_acq_rel))</span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">a</span><span class="params">(write_x)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">b</span><span class="params">(write_y)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">c</span><span class="params">(read_x_then_y)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">d</span><span class="params">(read_y_then_x)</span>;</span><br><span class="line">    a.join(); b.join(); c.join(); d.join();</span><br><span class="line">    assert(z.load() != <span class="number">0</span>); <span class="comment">// will never happen</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的例子修改自 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference.com/atomic/memory_order Sequentially-consistent ordering</a> 部分。理论上这个例子应该能够说明 memory_order_acq_rel 与 memory_order_seq_cst 的区别，当把原例中的 seq_cst 换成 acq_rel，应该是有可能触发 <code>z.load() == 0</code>的情况的(至少在 aarch64 上，因为x86的存储器模型本身就是按序一致性模型)。但实际上却没有触发，其原因在 <a href="https://stackoverflow.com/questions/67397460/does-stlrb-provide-sequential-consistency-on-arm64">stackoverflow 上有解释</a>。 通过在 <a href="https://godbolt.org/z/8KbxMEY6s">godbolt.org</a> 上查看这个程序的汇编代码，确实 <code>y.load(std::memory_order_acq_rel)</code>和<code>y.store(true, std::memory_order_acq_rel)</code>是被分别翻译成了 <code>ldarb</code> 和 <code>stlrb</code>。</p>
</li>
<li>
<p><code>memory_order_seq_cst</code></p>
<ul>
<li>提供最严格的全局读写顺序一致性保证，上面的例子就只能使用 memory_order_seq_cst</li>
<li>对于使用memory_order_seq_cst 的 <code>atomic&lt;T&gt;::store()</code> 指令来说，它强制flush 每个CPU核心的store buffer, 所以这个store 操作后面的 load (读操作)将被延迟直到store 操作完成所有 store buffer 的刷新(即对全局可见)。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>std::atomic&lt;T&gt;::load(std::memory_order order = std::memory_order_seq_cst)</code></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange"><code>std::atomic&lt;T&gt;::compare_exchange_*()</code></a></p>
<p>C++ std::atomic<T> 的 cas 有8个不同的声明，主要区分在 weak/strong, 参数和是否有 volatile. 而boost::lockfree::queue 里使用的是下面两个版本:</p>
<ul>
<li>
<p><code>std::atomic&lt;T&gt;::compare_exchange_strong(T&amp; expected, T desired, std::memory_order    order = std::memory_order_seq_cst)</code></p>
</li>
<li>
<p><code>std::atomic&lt;T&gt;::compare_exchange_weak(T&amp; expected, T desired, std::memory_order order = std::memory_order_seq_cst)</code></p>
</li>
<li>
<p>为什么 <code>expected</code> 参数是一个引用类型，而<code>desired</code>参数是一个值传递？</p>
</li>
</ul>
</li>
</ul>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms</a></li>
<li><a href="https://github.com/boostorg/lockfree/blob/develop/include/boost/lockfree/detail/tagged_ptr_dcas.hpp#L120">boost::lockfree::queue</a></li>
<li><a href="https://github.com/fangcun010/inline_asm_lockfree_queue">inline_asm_lockfree_queue</a></li>
<li><a href="https://blog.lse.epita.fr//2013/02/27/implementing-generic-double-word-compare-and-swap.html">Implementing generic double-word compare and swap for x86/64</a></li>
<li><a href="https://www.openeuler.org/zh/blog/wangshuo/Linux_Futex_Principle_Analysis/Linux_Futex_Principle_Analysis.html">linux - futex 原理分析</a></li>
<li><a href="https://coffeebeforearch.github.io/2020/08/04/atomic-vs-mutex.html">Mutex vs Atomic</a></li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LEA: Load Effective Address</title>
    <url>/prog/null-deref/</url>
    <content><![CDATA[<h1 id="segfault"><a class="markdownIt-Anchor" href="#segfault"></a> Segfault ?</h1>
<p>下面的程序会段错误吗？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">f</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%016lx\n&quot;</span>, &amp;f-&gt;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="segfault-2"><a class="markdownIt-Anchor" href="#segfault-2"></a> Segfault</h1>
<p>段错误是指程序试图<strong>访问一个不存在或没有权限访问的内存位置</strong>时操作系统发出的信号，一般都会使程序中止。如果上面的程序的 printf 改为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%016lx\n&quot;</span>, f-&gt;a);</span><br></pre></td></tr></table></figure>
<p>则一定段错误，看看 CPU 执行的指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000001149 &lt;main&gt;:</span><br><span class="line">    1149:       f3 0f 1e fa             endbr64</span><br><span class="line">    114d:       55                      push   %rbp</span><br><span class="line">    114e:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1151:       48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">    1155:       89 7d ec                mov    %edi,-0x14(%rbp)</span><br><span class="line">    1158:       48 89 75 e0             mov    %rsi,-0x20(%rbp)</span><br><span class="line">    115c:       48 c7 45 f8 00 00 00    movq   $0x0,-0x8(%rbp)</span><br><span class="line">    1163:       00</span><br><span class="line">    1164:       48 8b 45 f8             mov    -0x8(%rbp),%rax</span><br><span class="line">    1168:       48 8b 00                mov    (%rax),%rax</span><br><span class="line">    116b:       48 89 c6                mov    %rax,%rsi</span><br><span class="line">    116e:       48 8d 05 8f 0e 00 00    lea    0xe8f(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1175:       48 89 c7                mov    %rax,%rdi</span><br><span class="line">    1178:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    117d:       e8 ce fe ff ff          call   1050 &lt;printf@plt&gt;</span><br><span class="line">    1182:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    1187:       c9                      leave</span><br><span class="line">    1188:       c3                      ret</span><br></pre></td></tr></table></figure>
<p>触发段错误的是第 11 行的 <code>mov (%rax),%rax</code>, 因为 <code>rax</code> 寄存器的值是 0， 这条 MOV 指令里的 <code>(%rax)</code> 实际上就是去内存地址 0 取数据。再看看上面不会段错误的程序的指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000001149 &lt;main&gt;:</span><br><span class="line">    1149:       f3 0f 1e fa             endbr64</span><br><span class="line">    114d:       55                      push   %rbp</span><br><span class="line">    114e:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1151:       48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">    1155:       89 7d ec                mov    %edi,-0x14(%rbp)</span><br><span class="line">    1158:       48 89 75 e0             mov    %rsi,-0x20(%rbp)</span><br><span class="line">    115c:       48 c7 45 f8 00 00 00    movq   $0x0,-0x8(%rbp)</span><br><span class="line">    1163:       00</span><br><span class="line">    1164:       48 8b 45 f8             mov    -0x8(%rbp),%rax</span><br><span class="line">    1168:       48 89 c6                mov    %rax,%rsi</span><br><span class="line">    116b:       48 8d 05 92 0e 00 00    lea    0xe92(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1172:       48 89 c7                mov    %rax,%rdi</span><br><span class="line">    1175:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    117a:       e8 d1 fe ff ff          call   1050 &lt;printf@plt&gt;</span><br><span class="line">    117f:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    1184:       c9                      leave</span><br><span class="line">    1185:       c3                      ret</span><br></pre></td></tr></table></figure>
<p>原来的第 11 行 <code>mov (%rax),%rax</code> 变成了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1168:       48 89 c6                mov    %rax,%rsi</span><br><span class="line">116b:       48 8d 05 92 0e 00 00    lea    0xe92(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br></pre></td></tr></table></figure>
<p>它并没有直接去内存地址 0 去取数据，而是将指令寄存器 <code>rip</code> 的当前值加上 <code>0xe92</code> 后将结果存入 <code>rax</code> 寄存器。</p>
<p>所以上面的程序是不是会段错误，就要看 CPU 是不是<strong>访问</strong>了 <code>f (NULL)</code> 这个 0 地址。</p>
<h2 id="mov-vs-lea"><a class="markdownIt-Anchor" href="#mov-vs-lea"></a> MOV vs LEA</h2>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction">What’s the purpose of the LEA instruction?</a></li>
<li><a href="https://eli.thegreenplace.net/2012/01/03/understanding-the-x64-code-models">Understanding the x86 code models</a></li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, Rust</title>
    <url>/prog/rust/</url>
    <content><![CDATA[
<span id="more"></span>
<h1 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> Hello world</h1>
<p>安装 rust 的方式有好几种，但最方便的应该是通过 <strong>rustup</strong> 脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>
<p>rustup 默认安装最新的 stable 工具链到 <code>$HOME/.cargo</code> 目录下，安装的组件包括</p>
<ul>
<li>Rust 构建系统和包管理器 <code>cargo</code></li>
<li>Rust 静态代码分析工具 <code>clippy</code></li>
<li>Rust 离线文档 <strong>rust-docs</strong></li>
<li>Rust 标准库 <strong>rust-std</strong></li>
<li>Rust 编译器 <code>rustc</code></li>
<li>Rust 代码格式工具 <code>rustfmt</code></li>
</ul>
<p>这些组件安装后， Rust 环境基本上就 OK 了，可以写一个 hello world 测试一下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接使用 <code>rustc</code> 来编译它，就像使用 gcc 那样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustc main.rs -o main</span><br></pre></td></tr></table></figure>
<h1 id="rustup"><a class="markdownIt-Anchor" href="#rustup"></a> rustup</h1>
<p>rustup 是一个 rust 工具链管理工具，可以轻松在一个机器上部署多个版本的 rust 工具链，并在它们之间轻松切换。例如安装 stable, nightly, 1.82.0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustup install stable</span><br><span class="line">rustup install nightly</span><br><span class="line">rustup install 1.82.0</span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前工具链版本
<ul>
<li><code>rustup default</code></li>
</ul>
</li>
<li>设置当前工具链为 1.82.0
<ul>
<li><code>rustup default 1.82.0</code></li>
</ul>
</li>
<li>如果存在多个版本的工具链，为 cargo 指定特定工具链
<ul>
<li><code>cargo +1.82.0 install --path /some/rust/project/dir</code></li>
</ul>
</li>
</ul>
<p>当然推荐的方法是使用 <code>cargo</code>, 就像编译 C 时大多用 <code>make</code> 一样。 <code>cargo</code> 是 rust 的包管理工具，帮助管理项目中包的依赖及应用的构建，创建一个 Rust 项目，通常第一步是执行 <code>cargo init</code>, 它自动创建一个 <strong>Rust binary (application) package</strong>, 这样的包里会包含一个 <strong>Cargo.toml</strong> 文件(自动生成)， 后面 <code>cargo build</code> 就是根据这个文件内容来编译 Rust 项目。(如果要清理构建的结果，使用 <code>cargo clean</code>)</p>
<h1 id="cargo"><a class="markdownIt-Anchor" href="#cargo"></a> <a href="https://doc.rust-lang.org/cargo/index.html">cargo</a></h1>
<p>Rust 的包叫 <strong>crate</strong>, <strong>cargo</strong> 既是包管理器，也是 Rust 项目的构建系统。</p>
<h2 id="构建"><a class="markdownIt-Anchor" href="#构建"></a> 构建</h2>
<p>常用的 cargo 构建命令, 每个命令可能支持若干选项，如 <code>cargo build --bin hello_world</code>, 当一个 crate 下存在多个目标时， <code>--bin</code> 指定构建某个目标</p>
<ul>
<li><code>cargo new</code></li>
<li><code>cargo init</code></li>
<li><code>cargo build</code></li>
<li><code>cargo clean</code></li>
<li><code>cargo modules structure --package XXX</code>
<ul>
<li>显示某个 crate 的框架 (如有哪些函数, 类等)</li>
</ul>
</li>
<li><code>cargo doc</code>
<ul>
<li><code>cargo doc --open --manifest-path=/path/to/Cargo.toml</code>
<ul>
<li>生成指定 crate (以及依赖) 的文档，并启动浏览器打开<br />
<img src="/images/rust/rustlings-doc.png" alt="cargo doc --open" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="rust-hello-world"><a class="markdownIt-Anchor" href="#rust-hello-world"></a> Rust Hello World</h1>
<p>Rust 相对于 C 是复杂的，那我们也来一个 Non-trivial 版本的 Hello world。这个 Hello World 不使用标准库，而是通过<strong>汇编指令(x86)</strong> 直接调用操作系统的系统调用 (write), 来将&quot;Hello world&quot;,送到标准输出。</p>
<p>Rust 的标准库依赖 C 库 libc.so.6。但 Rust 语言允许你禁用标准库，从而不依赖 C 库。要达到这个目的，需要对 Hello world 程序和编译过程做些<a href="https://github.com/lucmann/pmp/tree/master/rust">修改</a></p>
<ul>
<li><code>#![no_std]</code> 明确告诉 rustc 不要用标准库， 那就意味着不能调用 <code>println!</code> 宏在标准输出上打印字符, 可以通过内联汇编调用 <code>write</code> 系统调用直接将字符送到标准输出。不要 rust 标准库，也就不要 C 标准库，那也就调用不了 crt1.o 里的 <code>_start</code> 函数， 所以这也意味着要自己实现 <code>_start</code></li>
<li><code>#![no_main]</code> 不要 main 函数，因为程序真正的入口点是 <code>_start</code> 函数， 既然我们直接实现 <code>_start()</code>, 那也就没必要提供 <code>main</code> 这个入口了。</li>
<li>要提供一个 <code>panic_handler</code>, 且需要将 <code>panic</code> 的触发事件改为 <code>abort</code> (默认 <code>panic=unwind</code>)</li>
</ul>
<p><code>cargo build</code> 时可以通过环境变量 <code>RUSTFLAGS</code> 告诉编译器和静态链接器以上这些信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUSTFLAGS=&quot;-Clink-arg=-nostartfiles -Cpanic=abort&quot; cargo build --bin hello_nostd</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125; <span class="comment">// Loop forever to halt the program</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[cfg(target_arch = <span class="string">&quot;x86_64&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="string">b&quot;Hello, world!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fd</span>: <span class="type">usize</span> = <span class="number">1</span>; <span class="comment">// File descriptor for stdout</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">syscall_no</span>: <span class="type">usize</span> = <span class="number">1</span>; <span class="comment">// Syscall number for write in Linux x86_64</span></span><br><span class="line">    <span class="comment">// Use inline asm macro to perform the syscall</span></span><br><span class="line">    core::arch::asm!(</span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">in</span>(<span class="string">&quot;rax&quot;</span>) syscall_no, <span class="comment">// syscall number</span></span><br><span class="line">        <span class="title function_ invoke__">in</span>(<span class="string">&quot;rdi&quot;</span>) fd,         <span class="comment">// file descriptor</span></span><br><span class="line">        <span class="title function_ invoke__">in</span>(<span class="string">&quot;rsi&quot;</span>) message.<span class="title function_ invoke__">as_ptr</span>(), <span class="comment">// pointer to the message</span></span><br><span class="line">        <span class="title function_ invoke__">in</span>(<span class="string">&quot;rdx&quot;</span>) message.<span class="title function_ invoke__">len</span>(), <span class="comment">// length of the message</span></span><br><span class="line">        <span class="title function_ invoke__">out</span>(<span class="string">&quot;rcx&quot;</span>) _, <span class="title function_ invoke__">out</span>(<span class="string">&quot;r11&quot;</span>) _, <span class="comment">// telling compiler these registers will</span></span><br><span class="line">                                    <span class="comment">// be clobbered by syscalls</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exit the program with status code 0</span></span><br><span class="line">    core::arch::asm!(</span><br><span class="line">        <span class="string">&quot;syscall&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">in</span>(<span class="string">&quot;rax&quot;</span>) <span class="number">60</span>, <span class="comment">// syscall number for exit</span></span><br><span class="line">        <span class="title function_ invoke__">in</span>(<span class="string">&quot;rdi&quot;</span>) <span class="number">0</span>,  <span class="comment">// exit status code</span></span><br><span class="line">        <span class="title function_ invoke__">out</span>(<span class="string">&quot;rcx&quot;</span>) _, <span class="title function_ invoke__">out</span>(<span class="string">&quot;r11&quot;</span>) _, <span class="comment">// telling compiler these registers will</span></span><br><span class="line">                                    <span class="comment">// be clobbered by syscalls</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rust-for-linux"><a class="markdownIt-Anchor" href="#rust-for-linux"></a> Rust for Linux</h1>
<p>Rust 是 2022 年 10 月随 Linux 6.1-rc1 进入内核主线的。Linux 内核从此就变成了一个双语言项目，首先要解决的问题之一就是 C 和 Rust 函数互相调用的问题，这就需要一个自动生成 <strong>Rust FFI bindings to C</strong> 的工具 <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>, 所以 bindgen 也是构建内核中 Rust 代码的依赖之一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S rust-bindgen</span><br></pre></td></tr></table></figure>
<p>内核有个特殊之处就是它不能链接 C 标准库，所以它自然也不能链接 Rust 标准库，所以编译开启 Rust (<code>CONFIG_RUST</code>) 内核需要安装 Rust 标准库的源码，这步可以通过 rustup 完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rustup component add rust-src</span><br></pre></td></tr></table></figure>
<p>这些完成后，在内核源码树根目录下运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make rustavailable</span><br></pre></td></tr></table></figure>
<p>检查编译内核的 Rust 环境是否已经准备 OK.</p>
<p>内核 Rust 构建系统提供对 VSCode <strong>rust-analyzer</strong> 插件的支持(因为 Rust for Linux 不用 Cargo, 所以默认情况下 rust-analyzer server 是无法正常工作的), 运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make rust-analyzer</span><br></pre></td></tr></table></figure>
<p>会生成 <strong>rust-project.json</strong>, 有了这个文件，rust-ananlyzer 插件可以运行。但是注意 <code>rust-analyzer</code> 目标必须在内核配置过之后才能 make</p>
<p>编译内核第一步，是得到 <code>.config</code> 配置文件, 配置项 <code>Rust support</code> 的位置在 <code>General setup</code> -&gt; <code>Rust support</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<h1 id="learn-rust-from-rust-for-linux"><a class="markdownIt-Anchor" href="#learn-rust-from-rust-for-linux"></a> Learn Rust from Rust for Linux</h1>
<p>就像之前的 <a href="https://lucmann.github.io/utils/make/">Learn Makefile from Linux Build System</a> 一样，这次我想一边阅读 Linux 内核中的 Rust 驱动代码，一边学习 Rust 语言，好处是可以了解一个实际的项目中，像 Rust 这样的语言的最佳实践是怎样的，这里就当是学习笔记吧</p>
<h1 id="nightly-vs-stable-rustc"><a class="markdownIt-Anchor" href="#nightly-vs-stable-rustc"></a> Nightly vs. Stable rustc</h1>
<p>Nightly rustc 每日自动构建，包含了所有最新的语言功能和标准库功能，所以稳定性也低，有可能有Bug。Rust for Linux 的官方文档虽然没有明确说构建内核 Rust 使用 Stable 编译器还是 Nightly 编译器，但最好使用 Stable, 原因是 Nightly 每天可能都有更新，Rust for Linux 也每天都在更新，如果使用 Nightly 版本的编译器，就需要二者同时都是最新，否则可能出现像下面的情况，编译器的版本号已经是 <code>1.91.0</code> 了，但相应的功能还没更新上(对于 Nightly 版本来说，所有的新功能不是在一天内更新进去的)</p>
<figure class="highlight rust"><figcaption><span>$srctree/scripts/generate_rust_target.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cfg.<span class="title function_ invoke__">rustc_version_atleast</span>(<span class="number">1</span>, <span class="number">91</span>, <span class="number">0</span>) &#123;</span><br><span class="line">    ts.<span class="title function_ invoke__">push</span>(<span class="string">&quot;target-pointer-width&quot;</span>, <span class="number">64</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ts.<span class="title function_ invoke__">push</span>(<span class="string">&quot;target-pointer-width&quot;</span>, <span class="string">&quot;64&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rustup install nightly</code>
<ul>
<li><code>nightly-x86_64-unknown-linux-gnu installed - rustc 1.91.0-nightly (1ebbd87a6 2025-08-11)</code></li>
</ul>
</li>
<li><code>rustup update nightly</code>
<ul>
<li>更新 nightly 版本的 rustc  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info: syncing channel updates for &#x27;nightly-x86_64-unknown-linux-gnu&#x27;</span><br><span class="line"></span><br><span class="line">    nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.92.0-nightly (c8905eaa6 2025-09-28)</span><br><span class="line"></span><br><span class="line">info: checking for self-update</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><code>rustup default nightly</code>
<ul>
<li><code>nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.91.0-nightly (1ebbd87a6 2025-08-11)</code></li>
<li><code>rustc --version</code></li>
</ul>
</li>
<li><code>rustup component add rust-src</code>
<ul>
<li><code>make rustavailable</code></li>
<li>安装 rustc nightly 后同样必须安装 nightly rust-src,否则 <code>make rustavailable</code> 会失败</li>
</ul>
</li>
<li><code>rustup default nightly</code> or <code>rustup default stable</code>
<ul>
<li>在 nightly 和 stable 之间切换</li>
</ul>
</li>
<li><code>rustup override set stable</code>
<ul>
<li>只改变 current working directory 的编译器版本，不影响系统的编译器版本配置</li>
</ul>
</li>
</ul>
<h1 id="macros"><a class="markdownIt-Anchor" href="#macros"></a> Macros</h1>
<p>Rust 中的宏虽说是强大，但也非常复杂，单看它文档里的<strong>声明宏</strong>的语法定义就头大了，更不用说过程宏了。但 Rust 的宏强大就强大在<strong>过程宏</strong>，声明宏只是减少代码量，而过程宏能让编译器<strong>自动生成代码</strong>。</p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/macros-by-example.html">https://doc.rust-lang.org/reference/macros-by-example.html</a></li>
</ul>
<h2 id="declarative-macros-声明式宏-macro_rules"><a class="markdownIt-Anchor" href="#declarative-macros-声明式宏-macro_rules"></a> Declarative Macros 声明式宏 <code>macro_rules!</code></h2>
<p>Rust 声明式宏给人的感觉就好像是把编译器前端的<strong>词法分析(Lexical)</strong>, <strong>语法分析(Syntactic)</strong> 开放给了用户，用户根据这套语法分析逻辑自己定义代码。定义一个声明式宏的一般语法是</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> MACRO_NAME &#123;</span><br><span class="line">    ( PATTERN ) =&gt; &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明式宏有点像<strong>模式匹配</strong>(至少它们都用到 <code>=&gt;</code>🐶), 调用宏时传入的<strong>那段字串</strong>会与 <strong>PATTERN</strong> 的结构匹配，一旦匹配就会按<strong>展开规则</strong>进行展开，这里的<strong>展开规则</strong>本身的写法很复杂，但也很强大。</p>
<p>内核中的 <code>dev_dbg</code> 就是一个声明式宏，实际上 <code>crate::dev_printk</code> 还是一个声明式宏</p>
<ul>
<li>dev_dbg 宏定义</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> dev_dbg &#123;</span><br><span class="line">    ($($f:tt)*) =&gt; &#123; $crate::dev_printk!(pr_dbg, $($f)*); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dev_printk 宏定义</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[doc(hidden)]</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> dev_printk &#123;</span><br><span class="line">    ($method:ident, $dev:expr, $($f:tt)*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            ($dev).$<span class="title function_ invoke__">method</span>(::core::<span class="built_in">format_args!</span>($($f)*));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dev_dbg 宏使用</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">dev_dbg!(dev, <span class="string">&quot;GPU instance built\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>从上面3段代码看，Rust 声明宏与 C 宏本质上差不多，形式上差得多。从 <code>dev_dbg</code> 的定义看，这个宏的参数是一个 <strong>TokenTree (tt)</strong>, 这个参数的名字就是 <code>$f</code>, 它的展开就是以 <code>pr_dbg</code> 这个<strong>Identifier (ident)</strong> 作为第一个参数调用 <code>dev_printk</code> 宏，其它参数透传过去。</p>
<p>而 <code>dev_printk</code> 宏有3个参数：</p>
<ul>
<li>第1个是一个 <strong>Identifier</strong>, 参数名是 <code>$method</code></li>
<li>第2个是一个 <strong>Expression</strong>, 参数名是 <code>$dev</code></li>
<li>第3个是一个 <strong>TokenTree</strong>,  参数名是 <code>$f</code></li>
</ul>
<p><code>dev_dbg!(dev, &quot;GPU instance built\n&quot;)</code> 最终展开后就是 <code>dev.pr_dbg(::core::format_args!(&quot;GPU instance built\n&quot;))</code></p>
<h2 id="procedural-macros-过程宏-rust-code-that-generates-rust-code"><a class="markdownIt-Anchor" href="#procedural-macros-过程宏-rust-code-that-generates-rust-code"></a> Procedural Macros 过程宏 Rust code that generates rust code</h2>
<ul>
<li>Function-like macros</li>
<li>derive macros</li>
<li>attribute macros</li>
</ul>
<h3 id="function-like-macros"><a class="markdownIt-Anchor" href="#function-like-macros"></a> Function-like macros</h3>
<p>函数式过程宏的一般语法是</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(Name)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">foo_bar</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    foo::<span class="title function_ invoke__">foo_bar</span>(input.<span class="title function_ invoke__">into</span>())).<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的宏的实现(如何把input TokenStream 变成结果 TokenStream) 一般在一个单独的 rust mod 里。</p>
<h3 id="derive-macros-derivedebug"><a class="markdownIt-Anchor" href="#derive-macros-derivedebug"></a> derive macros <code>#[derive(Debug)]</code></h3>
<h3 id="attribute-macros-bitfield"><a class="markdownIt-Anchor" href="#attribute-macros-bitfield"></a> attribute macros <code>#[bitfield]</code></h3>
<ul>
<li>Outer attribute
<ul>
<li><code>#[...]</code>
<ul>
<li>仅修饰紧跟着它的项 (fn, struct, trait)</li>
</ul>
</li>
</ul>
</li>
<li>Inner attribute
<ul>
<li><code>#![...]</code>
<ul>
<li>修饰它所在的整个项 (crate, mod)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="traits"><a class="markdownIt-Anchor" href="#traits"></a> Traits</h1>
<h1 id="closures-闭包匿名函数"><a class="markdownIt-Anchor" href="#closures-闭包匿名函数"></a> Closures 闭包(匿名函数)</h1>
<p>Rust closure 和 C++ 的 lambda 类似，都是实现<strong>匿名函数</strong>，都是一种语法糖，也都是<strong>零开销抽象</strong>。Rust closure 的一般语法是</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a_closure</span> = || &#123; .... &#125;;</span><br><span class="line"><span class="comment">// now you can call it</span></span><br><span class="line"><span class="title function_ invoke__">a_closure</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当函数体只有一个表达式时，花括号都可以省略</p>
</li>
<li>
<p>Rust closure 的变量捕获相对简单，因为它是由编译器隐式地自动完成的(根据你使用变量的方式)</p>
</li>
<li>
<p>下面是一个使用 closure 的例子</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_</span>: <span class="type">Result</span> = util::<span class="title function_ invoke__">wait_on</span>(Delta::<span class="title function_ invoke__">from_micros</span>(<span class="number">10</span>), || <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>util::wait_on()</code> 的第2个参数的类型 <code>F</code>, 是一个实现了 <code>Fn()</code> trait 且返回值类型是 <code>Option&lt;R&gt;</code> 的类型</p>
</li>
<li>
<p>第2个实参： <code>|| None</code> (这个闭包够简单吧) 符合这个类型的要求</p>
</li>
<li>
<p><code>Option&lt;T&gt;</code> 是个泛型枚举类型，<code>None</code> 就是它的一个枚举值</p>
</li>
<li>
<p><a href="https://elixir.bootlin.com/linux/v6.17-rc6/source/drivers/gpu/nova-core/util.rs#L35"><code>util::wait_on()</code></a>的实现如下</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">wait_on</span>&lt;R, F: <span class="title function_ invoke__">Fn</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;R&gt;&gt;(timeout: Delta, cond: F) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;R&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start_time</span> = Instant::&lt;Monotonic&gt;::<span class="title function_ invoke__">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(ret) = <span class="title function_ invoke__">cond</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> start_time.<span class="title function_ invoke__">elapsed</span>().<span class="title function_ invoke__">as_nanos</span>() &gt; timeout.<span class="title function_ invoke__">as_nanos</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ETIMEDOUT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="概念区分"><a class="markdownIt-Anchor" href="#概念区分"></a> 概念区分</h1>
<h2 id="引用和借用"><a class="markdownIt-Anchor" href="#引用和借用"></a> 引用和借用</h2>
<p><a href="https://course.rs/basic/ownership/borrowing.html"><strong>获取变量引用的过程叫借用(Borrowing)</strong></a>。借用这一概念是 Rust 所有权的核心。</p>
<h2 id="string-vs-str-vs-str"><a class="markdownIt-Anchor" href="#string-vs-str-vs-str"></a> <code>String</code> vs <code>str</code> vs <code>&amp;str</code></h2>
<ul>
<li><code>str</code> 是 rust 语言级别的字符串类型， <code>String</code> 是 rust 标准库里实现的众多字符串类型之一, <code>&amp;str</code> 是字符串切片
<ul>
<li>除了 <code>std::string::String</code> 之外，标准库还定义了这些字符串类型
<ul>
<li><code>std::ffi::OsString</code>, <code>std::ffi::OsStr</code></li>
<li><code>std::ffi::CString</code>, <code>std::ffi::CStr</code></li>
<li><code>std::path::PathBuf</code>, <code>std::path::Path</code></li>
</ul>
</li>
</ul>
</li>
<li><code>str</code> 类型的字符串是硬编码进可执行文件，且不可修改，<code>String</code>是一个可增长、可修改且具有所有权的 UTF-8 编码的字符串</li>
<li><code>&amp;str</code> 和 <code>String</code> 之间的转换
<ul>
<li><code>&amp;str</code> =&gt; <code>String</code>
<ul>
<li><code>String::from(&quot;hello,world&quot;)</code></li>
<li><code>&quot;hello,world&quot;.to_string()</code></li>
</ul>
</li>
<li><code>String</code> =&gt; <code>&amp;str</code>  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s[..]);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(s.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span> ,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="none-vs"><a class="markdownIt-Anchor" href="#none-vs"></a> <code>None</code> vs <code>()</code></h2>
<p><code>None</code> 是一个值，<code>enum Option&lt;T&gt;</code> 中的一个枚举值，表示一个<strong>不存在的值</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>()</code> 是一个类型，在泛型中有时被用作<strong>占位符</strong>，表示这里需要一个类型，但并不关心具体是什么类型</p>
<figure class="highlight rust"><figcaption><span>$srctree/drivers/gpu/nova-core/falcon.rs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_</span> = util::<span class="title function_ invoke__">wait_on</span>(Delta::<span class="title function_ invoke__">from_micros</span>(<span class="number">150</span>), || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = regs::NV_PFALCON_FALCON_HWCFG2::<span class="title function_ invoke__">read</span>(bar, E::BASE);</span><br><span class="line">    <span class="keyword">if</span> r.<span class="title function_ invoke__">reset_ready</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/index.html">The Cargo Book</a></li>
<li><a href="https://course.rs/basic/variable.html">Rust 语言圣经</a>👍</li>
<li><a href="https://github.com/rust-lang/rustlings">Rustling</a>🦀</li>
<li><a href="https://rust-for-linux.com/">Rust for Linux</a>👀</li>
<li><a href="https://rust.docs.kernel.org/kernel/">rust.docs.kernel.org</a></li>
<li><a href="https://github.com/dtolnay/proc-macro-workshop">The best way to learn procedural macros is by writing them</a></li>
<li><a href="https://doc.rust-lang.org/book/ch20-05-macros.html">The Rust Programming Language - Macros</a></li>
<li><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">The Rust Programming Language - Closures: Anonymous Functions That Capture Their Environment</a></li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 标准库</title>
    <url>/prog/std/</url>
    <content><![CDATA[<h1 id="stdallocator"><a class="markdownIt-Anchor" href="#stdallocator"></a> <a href="https://en.cppreference.com/w/cpp/memory/allocator">std::allocator</a></h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span> &gt; <span class="keyword">struct</span> <span class="title class_">allocator</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><code>std::allocator</code>本质上就是 new/delete, 但是为什么需要它呢？</p>
<ul>
<li>分离 allocation 和 construction(或者分离 deallocation 和 destruction)</li>
<li>主要的使用场景就是在实现container时</li>
</ul>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/31358804/whats-the-advantage-of-using-stdallocator-instead-of-new-in-c">What’s advantage of using std::allocator instead of new in C++?</a></li>
</ul>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQs about System Programming</title>
    <url>/prog/syscall/</url>
    <content><![CDATA[<ol>
<li>x86_64 平台下，system-calls 最多可以有几个参数？</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
  </entry>
  <entry>
    <title>Smart Pointer</title>
    <url>/prog/smart-pointer/</url>
    <content><![CDATA[<p>smart pointer是C<ins>11引入的，被包含在C</ins>标准库中。smart pointer是为了管理对象的所属(object ownership)而设计的，smart pointer对象负责自动地销毁所关联对象。常见的smart pointer有:</p>
<span id="more"></span>
<ul>
<li><code>std::shared_ptr</code></li>
<li><code>std::unique_ptr</code></li>
<li><code>std::weak_ptr</code></li>
</ul>
<h1 id="shared_ptr"><a class="markdownIt-Anchor" href="#shared_ptr"></a> <code>shared_ptr</code></h1>
<p>shared_ptr主要用在多个对象共享同一个资源的场景(sharing ownership)。它允许当指针指向的对象在任何地方都不再被使用的时候自动销毁所指对象。C++引入它的目的是消除内存泄漏(memory leak)和野指针(dangling pointer). 从实现的角度看，shared_ptr是通过消耗更多的内存来换取程序的健壮性。每个shared_ptr对象的内部都指向两块内存区域:</p>
<ul>
<li>Pointer to object</li>
<li>Pointer to control data that is used for reference counting</li>
</ul>
<div align=center><img src="/prog/smart-pointer/shared_ptr.png" class="" title="shared_ptr memory layout"></div>
<p>通常一个<code>shared_ptr</code>对象的内存大小不小于40字节，这是32位平台普通指针变量大小的10倍。<code>shared_ptr</code>的destructor和虚成员函数意味着这些成员函数的调用是动态解析的，这就增加了额外的运行时开销。</p>
<h2 id="creation"><a class="markdownIt-Anchor" href="#creation"></a> creation</h2>
<ul>
<li>
<p>binding a <code>shared_ptr</code> object with raw pointer</p>
<p><code>std::shared_ptr&lt;int&gt; p1(new int());</code></p>
</li>
<li>
<p>using <code>std::make_shared</code></p>
<p><code>std::shared_ptr&lt;int&gt; p1 = std::make_shared&lt;int&gt;();</code></p>
</li>
</ul>
<h2 id="reference-counting"><a class="markdownIt-Anchor" href="#reference-counting"></a> reference counting</h2>
<p><code>p1.use_count();</code></p>
<h2 id="detachment"><a class="markdownIt-Anchor" href="#detachment"></a> detachment</h2>
<ul>
<li>
<p>calling <code>reset()</code> with no parameter</p>
<p><code>p1.reset();</code></p>
<p>这个调用将<code>p1</code>的reference count减1， 如果reference count变成0，则自动删除<code>p1</code>关联的raw pointer.</p>
</li>
<li>
<p>calling <code>reset()</code> with parameter</p>
<p><code>p1.reset(new int(42));</code></p>
<p>这个调用将<code>p1</code>关联到一个新的raw pointer, 因此<code>p1</code>的reference count还是1.</p>
</li>
<li>
<p>using <code>nullptr</code></p>
<p><code>p1 = nullptr;</code></p>
</li>
</ul>
<h2 id="psuedo-pointer"><a class="markdownIt-Anchor" href="#psuedo-pointer"></a> psuedo pointer</h2>
<h1 id="unique_ptr"><a class="markdownIt-Anchor" href="#unique_ptr"></a> <code>unique_ptr</code></h1>
<p><code>unique_ptr</code>同样是为了管理对象的所属(unique ownership)，但与<code>shared_ptr</code>相反，<code>unique_ptr</code>允许在程序的生命周期的任何时候只有一个指针指向对象，所以<code>unique_ptr</code>是不可复制的。</p>
<h1 id="weak_ptr"><a class="markdownIt-Anchor" href="#weak_ptr"></a> <code>weak_ptr</code></h1>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>编译，链接和运行</title>
    <url>/utils/build/</url>
    <content><![CDATA[<p><img src="/images/build/execve.svg" alt="" /></p>
<p>《程序员的自我修养–链接，装载与库》这本书是在读研时才看的，印象很深，现在想想这本书讲的都是程序员，尤其是从事系统编程需要的知识。这里我将平时使用的跟编译，链接和构建应用程序及库相关的知识记录下来，希望以后能温故知新。</p>
<span id="more"></span>
<h1 id="编译器与链接器"><a class="markdownIt-Anchor" href="#编译器与链接器"></a> 编译器与链接器</h1>
<ul>
<li>
<p>gcc</p>
</li>
<li>
<p><a href="https://gcc.gnu.org/projects/cxx-status.html">g++</a></p>
</li>
<li>
<p>clang</p>
</li>
<li>
<p><a href="https://clang.llvm.org/cxx_status.html">clang++</a></p>
</li>
<li>
<p>bfd (使用 Binary File Descriptor 库构建的 Linker, Ubuntu 上默认的 ld)</p>
</li>
<li>
<p>gold (<a href="https://android.googlesource.com/toolchain/binutils/+/53b6ed3bceea971857c996b6dcb96de96b99335f/binutils-2.19/gold"><strong>go</strong>ogle <strong>l</strong>oa<strong>d</strong>er</a>)</p>
</li>
<li>
<p>mold (<a href="https://github.com/rui314/mold"><strong>mo</strong>dern <strong>l</strong>oa<strong>d</strong>er</a>)</p>
</li>
</ul>
<h2 id="gcc-的优化级别"><a class="markdownIt-Anchor" href="#gcc-的优化级别"></a> gcc 的优化级别</h2>
<p><code>-O</code> 和 <code>-O1</code> 是等价的。 <code>-O</code> 会对目标文件大小和执行时间进行优化，但不会进行非常耗时的优化，以下是 <code>-O</code> 打开的优化: (其中红色的是 <code>-Og</code> 关闭的)</p>
<ul>
<li>-fauto-inc-dec</li>
<li><span style="color:red">-fbranch-count-reg</span></li>
<li>-fcombine-stack-adjustments</li>
<li>-fcompare-elim</li>
<li>-fcprop-registers</li>
<li>-fdce</li>
<li>-fdefer-pop</li>
<li><span style="color:red">-fdelayed-branch</span></li>
<li><span style="color:red">-fdse</span></li>
<li>-fforward-propagate</li>
<li>-fguess-branch-probability</li>
<li><span style="color:red">-fif-conversion</span></li>
<li><span style="color:red">-fif-conversion2</span></li>
<li><span style="color:red">-finline-functions-called-once</span></li>
<li>-fipa-modref</li>
<li>-fipa-profile</li>
<li>-fipa-reference</li>
<li>-fipa-reference-addressable</li>
<li>-fmerge-constants</li>
<li><span style="color:red">-fmove-loop-invariants</span></li>
<li><span style="color:red">-fmove-loop-stores</span></li>
<li>-fomit-frame-pointer</li>
<li>-freorder-blocks</li>
<li>-fshrink-wrap</li>
<li>-fshrink-wrap-separate</li>
<li>-fsplit-wide-types</li>
<li>-fssa-backprop</li>
<li><span style="color:red">-fssa-phiopt</span></li>
<li><span style="color:red">-ftree-bit-ccp</span></li>
<li>-ftree-ccp</li>
<li>-ftree-ch</li>
<li>-ftree-coalesce-vars</li>
<li>-ftree-copy-prop</li>
<li>-ftree-dce</li>
<li>-ftree-dominator-opts</li>
<li><span style="color:red">-ftree-dse</span></li>
<li>-ftree-forwprop</li>
<li>-ftree-fre</li>
<li>-ftree-phiprop</li>
<li><span style="color:red">-ftree-pta</span></li>
<li>-ftree-scev-cprop</li>
<li>-ftree-sink</li>
<li>-ftree-slsr</li>
<li><span style="color:red">-ftree-sra</span></li>
<li>-ftree-ter</li>
<li>-funit-at-a-time</li>
</ul>
<h2 id="编译器背后做的事"><a class="markdownIt-Anchor" href="#编译器背后做的事"></a> 编译器背后做的事</h2>
<ul>
<li>当你编译一个 hello world C 程序时，一般并不会指定 <code>-lc</code> 链接选项，那为什么会自动链接 libc.so.6 呢？</li>
</ul>
<p>原因是 gcc 有一套内置的链接规则，通过 <code>gcc -dumpspecs</code> 可以看到它，这套规则规定在满足条件时，gcc 会默认为你加上 <code>-lc</code> 选项</p>
<h1 id="动态链接器-vs-静态链接器"><a class="markdownIt-Anchor" href="#动态链接器-vs-静态链接器"></a> 动态链接器() vs 静态链接器 ()</h1>
<p><strong>动态链接器 <code>/lib64/ld-linux-x86-64.so.2</code></strong> 是程序运行时调用的，它由操作系统内核通过 execve 族系统调用加载到内存，进而由它加载其它用到的动态链接库。它本身是一个静态链接库，不依赖其它库。</p>
<p><strong>静态链接器 <code>/usr/bin/ld</code></strong> 是构建程序或库时调用的，它由编译器(如 gcc)调用, 它本身是一个可执行程序，而且可以读入链接脚本(linker script)来改变它的行为。例如，常见的 <code>/lib/x86_64-linux-gnu/libc.so</code> 就是一个<strong>链接器脚本文件(纯ASCII text)</strong>, 而不是<s>共享对象(shared object) Binary 文件</s>, 这个链接脚本的内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* GNU ld script</span><br><span class="line">   Use the shared library, but some functions are only in</span><br><span class="line">   the static library, so try that secondarily.  */</span><br><span class="line">OUTPUT_FORMAT(elf64-x86-64)</span><br><span class="line">GROUP (</span><br><span class="line">  /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">  /usr/lib/x86_64-linux-gnu/libc_nonshared.a</span><br><span class="line">  AS_NEEDED ( /lib64/ld-linux-x86-64.so.2 )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>虽然静态链接器和动态链接器运行在两个不同的阶段，但静态链接器也可以影响到动态链接器的行为，比如 <code>-Wl,-rpath,/path/to/lib</code>, 也就是常说的 Runtime PATH, 这个参数可以让动态链接器去指定<strong>目录</strong>下搜索的目标动态库。</p>
<ul>
<li><code>-L/path/to/lib</code>          编译时搜索路径</li>
<li><code>-Wl,-rpath,/path/to/lib</code> 运行时搜索路径</li>
</ul>
<h2 id="动态库都去哪儿呢"><a class="markdownIt-Anchor" href="#动态库都去哪儿呢"></a> 动态库都去哪儿呢</h2>
<ul>
<li>pkg-config</li>
</ul>
<p><strong>pkg-config (symbolic link to <code>/usr/bin/pkgconf</code>)</strong> 是用来获取系统上安装的库的信息的程序。cmake, meson 这些构建系统底层都是靠它来解析依赖包的。 下面的命令可以查看 pkg-config 工作时所搜索的路径和优先次序， 用户也可以通过环境变量 <strong><code>PKG_CONFIG_PATH</code></strong> 来指定自己想要优先搜索的路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg-config --variable pc_path pkg-config | sed <span class="string">&#x27;s/:/\n/g&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/lib/x86_64-linux-gnu/pkgconfig</span><br><span class="line">/usr/local/lib/pkgconfig</span><br><span class="line">/usr/local/share/pkgconfig</span><br><span class="line">/usr/lib/x86_64-linux-gnu/pkgconfig</span><br><span class="line">/usr/lib/pkgconfig</span><br><span class="line">/usr/share/pkgconfig</span><br></pre></td></tr></table></figure>
<p><code>pkg-config</code> 是二进制可执行程序 <code>/usr/bin/pkgconf</code> 的一个符号链接文件，它是 CMake, meson 等构建系统主要使用的系统动态库检测的工具。<code>pkg-config</code> 本质上是在解析 <code>*.pc</code> 文件。下面是常见的 Mesa OpenGL Library 的 .pc 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  piglit git:(main) ✗ find /usr -name &#x27;gl.pc&#x27; -ls</span><br><span class="line">    78674      4 -rw-r--r--   1 root     root          205 Jan  3  2023 /usr/lib/x86_64-linux-gnu/pkgconfig/gl.pc</span><br><span class="line">    72985      4 -rw-r--r--   1 root     root          362 Jun  7 18:16 /usr/local/lib/x86_64-linux-gnu/pkgconfig/gl.pc</span><br><span class="line">➜  piglit git:(main) ✗ bat /usr/local/lib/x86_64-linux-gnu/pkgconfig/gl.pc</span><br><span class="line">───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: /usr/local/lib/x86_64-linux-gnu/pkgconfig/gl.pc</span><br><span class="line">───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ prefix=/usr/local</span><br><span class="line">   2   │ includedir=$&#123;prefix&#125;/include</span><br><span class="line">   3   │ libdir=$&#123;prefix&#125;/lib/x86_64-linux-gnu</span><br><span class="line">   4   │</span><br><span class="line">   5   │ glx_tls=yes</span><br><span class="line">   6   │</span><br><span class="line">   7   │ Name: gl</span><br><span class="line">   8   │ Description: Mesa OpenGL Library</span><br><span class="line">   9   │ Version: 24.2.0-devel</span><br><span class="line">  10   │ Requires.private: x11, xext, xfixes, x11-xcb, xcb, xcb-glx &gt;=  1.8.1, xcb-dri2 &gt;=  1.8, xxf86vm, libdrm &gt;=  2.4.75</span><br><span class="line">  11   │ Libs: -L$&#123;libdir&#125; -lGL</span><br><span class="line">  12   │ Libs.private: -lpthread -pthread -lm</span><br><span class="line">  13   │ Cflags: -I$&#123;includedir&#125;</span><br><span class="line">───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">➜  piglit git:(main) ✗ bat /usr/lib/x86_64-linux-gnu/pkgconfig/gl.pc</span><br><span class="line">───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: /usr/lib/x86_64-linux-gnu/pkgconfig/gl.pc</span><br><span class="line">───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ prefix=/usr</span><br><span class="line">   2   │ includedir=$&#123;prefix&#125;/include</span><br><span class="line">   3   │ libdir=$&#123;prefix&#125;/lib/x86_64-linux-gnu</span><br><span class="line">   4   │</span><br><span class="line">   5   │ Name: GL</span><br><span class="line">   6   │ Description: Legacy OpenGL and GLX library and headers.</span><br><span class="line">   7   │ Version: 1.2</span><br><span class="line">   8   │ Libs: -L$&#123;libdir&#125; -lGL</span><br><span class="line">   9   │ Cflags: -I$&#123;includedir&#125;</span><br><span class="line">───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lib*-dev</code> 与 <code>lib*</code> 的区别</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ dpkg -L libxcb1</span><br><span class="line">/.</span><br><span class="line">/usr</span><br><span class="line">/usr/lib</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libxcb.so.1.1.0</span><br><span class="line">/usr/share</span><br><span class="line">/usr/share/doc</span><br><span class="line">/usr/share/doc/libxcb1</span><br><span class="line">/usr/share/doc/libxcb1/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libxcb1/copyright</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libxcb.so.1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ dpkg -L libxcb1-dev</span><br><span class="line">/.</span><br><span class="line">/usr</span><br><span class="line">/usr/include</span><br><span class="line">/usr/include/xcb</span><br><span class="line">/usr/include/xcb/bigreq.h</span><br><span class="line">/usr/include/xcb/xc_misc.h</span><br><span class="line">/usr/include/xcb/xcb.h</span><br><span class="line">/usr/include/xcb/xcbext.h</span><br><span class="line">/usr/include/xcb/xproto.h</span><br><span class="line">/usr/lib</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libxcb.a</span><br><span class="line">/usr/lib/x86_64-linux-gnu/pkgconfig</span><br><span class="line">/usr/lib/x86_64-linux-gnu/pkgconfig/xcb.pc</span><br><span class="line">/usr/share</span><br><span class="line">/usr/share/doc</span><br><span class="line">/usr/share/doc/libxcb1-dev</span><br><span class="line">/usr/share/doc/libxcb1-dev/copyright</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libxcb.so</span><br><span class="line">/usr/share/doc/libxcb1-dev/changelog.Debian.gz</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/usr/sbin/ldconfig</code></li>
</ul>
<p>Configure Dynamic Linker Run Time Bindings</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  <span class="built_in">test</span> <span class="variable">$#</span> = 0							\</span><br><span class="line">    &amp;&amp; <span class="built_in">test</span> x<span class="string">&quot;<span class="variable">$LDCONFIG_NOTRIGGER</span>&quot;</span> = x				\</span><br><span class="line"> &amp;&amp; <span class="built_in">test</span> x<span class="string">&quot;<span class="variable">$DPKG_MAINTSCRIPT_PACKAGE</span>&quot;</span> != x			\</span><br><span class="line"> &amp;&amp; dpkg-trigger --check-supported 2&gt;/dev/null</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="keyword">if</span> dpkg-trigger --no-await ldconfig; <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">test</span> x<span class="string">&quot;<span class="variable">$LDCONFIG_TRIGGER_DEBUG</span>&quot;</span> != x; <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;ldconfig: wrapper deferring update (trigger activated)&quot;</span></span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">		<span class="built_in">exit</span> 0</span><br><span class="line">	<span class="keyword">fi</span>	</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> /sbin/ldconfig.real <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="got-plt-pic"><a class="markdownIt-Anchor" href="#got-plt-pic"></a> GOT, PLT &amp; PIC</h2>
<ul>
<li>GOT Global Offset Table</li>
<li>PLT Procedure Linkage Table</li>
<li>PIC Position Independent Code</li>
</ul>
<h1 id="构建系统"><a class="markdownIt-Anchor" href="#构建系统"></a> 构建系统</h1>
<ul>
<li>autotools</li>
<li>cmake</li>
<li>make</li>
<li>meson</li>
<li>ninja</li>
<li>scons</li>
</ul>
<h2 id="autotools"><a class="markdownIt-Anchor" href="#autotools"></a> autotools</h2>
<pre><code class="highlight mermaid">flowchart LR
  autoreconf((&quot;autoreconf&lt;br&gt;[Perl script]&quot;))
  autoconf(autoconf)
  aclocal(aclocal)
  automake(automake)
  autoheader(autoheader)
  gettextize(gettextize)
  libtoolize(libtoolize)

  am@&#123;shape: docs, label: &quot;Makefile.am&quot;&#125;
  in@&#123;shape: docs, label: &quot;Makefile.in&quot;&#125;
  mk@&#123;shape: docs, label: &quot;Makefile&quot;&#125;
  ac@&#123;shape: paper-tape, label: &quot;configure.ac&quot;&#125;
  co@&#123;shape: paper-tape, label: &quot;configure&lt;br&gt;[Shell script]&quot;&#125;

  autoreconf --&gt; autoconf
  autoreconf -.-&gt; aclocal
  autoreconf -.-&gt; automake
  autoreconf -.-&gt; autoheader
  autoreconf -.-&gt; gettextize
  autoreconf -.-&gt; libtoolize

  am --&gt; automake --&gt; in
  ac --&gt; autoconf --&gt; co
  in --&gt; co --&gt; mk</code></pre>
<p><a href="https://stackoverflow.com/questions/4071880/what-are-the-differences-between-autotools-cmake-and-scons"><strong>autotools</strong> 的唯一的可取处就是 GNU 项目广泛使用它</a>。使用它的项目的构建步骤一般是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure --prefix=<span class="variable">$PREFIX</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>当你遇到 <code>./autogen.sh: 13: autoreconf: not found</code> 这样的错误时，你可能需要安装这些软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install autoconf automake libtool gettext</span><br></pre></td></tr></table></figure>
<h2 id="cmake"><a class="markdownIt-Anchor" href="#cmake"></a> cmake</h2>
<ul>
<li>use <code>gold</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -B build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=On -DCMAKE_EXE_LINKER_FLAGS=-fuse-ld=gold</span><br></pre></td></tr></table></figure>
<h2 id="meson"><a class="markdownIt-Anchor" href="#meson"></a> meson</h2>
<ul>
<li><a href="https://mesonbuild.com/Builtin-options.html#details-for-buildtype">-D buildtype</a></li>
</ul>
<p>meson 的 buildtype 是用来设定编译优化级别 (optimization levels: -O0, -O1, -O2, -O3, -Os) 和是否有调试信息 (debug: -g)。 实际上，meson 提供两个分开的选项分别控制编译优化级别和调试信息</p>
<ul>
<li>
<p>-Doptimization (plain|0|2|3|s, plain 指不设置任何 optimization flags)</p>
</li>
<li>
<p>-Ddebug (true|false)</p>
</li>
<li>
<p>只编译某个 target</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ninja -C build target</span><br></pre></td></tr></table></figure>
<ul>
<li>meson install --tags tag1,tag2</li>
</ul>
<p>Installation tags 是专门为打包 (packaging) 设计的，因为打包时开发文件包(头文件)，文档包 (mannul) 和二进制包 (shared libraries) 一般是分开的 3 个包。所以 <code>meson install --tags</code> 可以让用户分 3 次安装，每次只安装这个包所需的文件。meson 有几个预定义的 tags (不用用户自己使用 <code>install_tag</code> 关键字去指定 tag 名)</p>
<table>
<thead>
<tr>
<th style="text-align:left">tags</th>
<th style="text-align:left">files</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">devel</td>
<td style="text-align:left">static_library(), install_headers(), .a, .pc</td>
</tr>
<tr>
<td style="text-align:left">runtime</td>
<td style="text-align:left">executable(), shared_library(), shared_module(), .so, .dll</td>
</tr>
<tr>
<td style="text-align:left">man</td>
<td style="text-align:left">install_man()</td>
</tr>
<tr>
<td style="text-align:left">doc</td>
<td style="text-align:left">hotdoc.generate_doc()</td>
</tr>
<tr>
<td style="text-align:left">i18n</td>
<td style="text-align:left">i18n.gettext(), files installed into <code>localedir</code></td>
</tr>
<tr>
<td style="text-align:left">bin</td>
<td style="text-align:left">scripts and executables bundled with a library used by end users</td>
</tr>
<tr>
<td style="text-align:left">bin-devel</td>
<td style="text-align:left">scripts and executables bundled with  a library used by developers</td>
</tr>
</tbody>
</table>
<ul>
<li>use <code>gold</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meson build --prefix=/usr -D&#123;c,cpp&#125;_args=-fuse-ld=gold -Dflavors=x11-gl,x11-glesv2</span><br></pre></td></tr></table></figure>
<h1 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h1>
<p>一个 ELF 可执行文件的真正入口点是 <strong><code>_start()</code></strong></p>
<p><img src="/images/build/start_main.svg" alt="" /></p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/compiler_support">C++ compiler support</a></li>
</ul>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>CLion 使用笔记</title>
    <url>/utils/clion/</url>
    <content><![CDATA[<h1 id="choice-of-clion"><a class="markdownIt-Anchor" href="#choice-of-clion"></a> Choice of CLion</h1>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLion 2020.2.5</span><br><span class="line">Build #CL-202.8194.17, built on November 26, 2020</span><br><span class="line">Licensed to CLion Evaluator</span><br><span class="line">Expiration date: October 3, 2022</span><br><span class="line">Runtime version: 11.0.9+11-b944.49 amd64</span><br><span class="line">VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.</span><br><span class="line">Windows 10 10.0</span><br><span class="line">GC: ParNew, ConcurrentMarkSweep</span><br><span class="line">Memory: 1987M</span><br><span class="line">Cores: 8</span><br><span class="line">Registry: run.processes.with.pty=TRUE</span><br><span class="line">Non-Bundled Plugins: IdeaVIM, Lua, io.zhile.research.ide-eval-resetter, zielu.gittoolbox</span><br></pre></td></tr></table></figure>
<h1 id="on-clion-with-wsl"><a class="markdownIt-Anchor" href="#on-clion-with-wsl"></a> On CLion with WSL</h1>
<h2 id="avoid-annoying-event-notification-every-startup"><a class="markdownIt-Anchor" href="#avoid-annoying-event-notification-every-startup"></a> Avoid annoying event notification every startup</h2>
<ul>
<li>filesystem case-sensitivity mismatch</li>
</ul>
<p>原因：<a href="https://confluence.jetbrains.com/display/IDEADEV/Filesystem+Case-Sensitivity+Mismatch">WSL Ubuntu 是 case-sensitive OS, 而 Host 侧的 Windows 11 是 case-insensitive OS</a></p>
<ul>
<li>external file changes sync may be slow</li>
</ul>
<p>原因：<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000013130-External-file-changes-sync-may-be-slow">Native file watcher will not work for the shared and network folders</a></p>
<p>这两个问题其实都是我在使用 WSL 的原因，避免方法也很简单 <code>C:\Users\whoami\AppData\Roaming\JetBrains\CLion2020.2\idea.properties</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea.case.sensitive.fs=true</span><br><span class="line">idea.filewatcher.disabled=true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 不是一个构建系统</title>
    <url>/utils/cmake/</url>
    <content><![CDATA[<p>最近看了一些关于Modern CMake(since 3.0.0)的教程，这里记录一下.</p>
<span id="more"></span>
<h1 id="modern-cmake"><a class="markdownIt-Anchor" href="#modern-cmake"></a> Modern CMake</h1>
<p>作为一个<em>Build System Generator</em>, 现代CMake可以帮助我们做哪些事情呢？</p>
<ul>
<li>Build</li>
<li>Install</li>
<li>Test</li>
<li>Package</li>
</ul>
<h1 id="command-options"><a class="markdownIt-Anchor" href="#command-options"></a> Command Options</h1>
<ul>
<li>
<p>cmake -B build</p>
<ul>
<li>Build的工作主要包括解决依赖关系，构建目标(库,应用,测试用例)。<code>cmake</code>命令有很多选项可以帮助我们灵活有效地构建目标， 例如：Out-of-source构建，意思是不污染源代码目录，在指定的单独的目录下生成构建系统, 如果build不存在，cmake会创建它</li>
</ul>
</li>
<li>
<p>cmake -B build --graphviz=file.dot</p>
<ul>
<li>将构建目标间的依赖关系输出Graphivz dot, 生成的<code>file.dot</code>可以用dot命令生成图片<code>dot -Tpng -o file.png file.dot</code></li>
</ul>
</li>
<li>
<p>cmake --build build</p>
<ul>
<li>开始构建, 通过<code>-B</code>, <code>--build</code>选项可以省去<code>mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make</code>繁琐的操作</li>
</ul>
</li>
<li>
<p>cmake --build build --clean-first</p>
<ul>
<li>全量构建, 如果是 <code>-G &quot;Ninja&quot;</code>, 则 <code>ninja -C build clean</code>, 然后再重新 <code>ninja -C build</code></li>
</ul>
</li>
<li>
<p>cmake --build build --target lib1</p>
<ul>
<li>只构建指定的目标<code>lib1</code>, 如果<code>lib1</code>依赖其它目标，被依赖的目标也会被构建</li>
</ul>
</li>
<li>
<p>cmake --install build</p>
<ul>
<li>安装</li>
</ul>
</li>
<li>
<p>cmake -L build</p>
<ul>
<li>查询CMAKE变量配置值，包括内置变量和自定义变量</li>
</ul>
</li>
<li>
<p>cmake --build build --target help</p>
<ul>
<li>列出生成的Makefile里有效的<code>target</code></li>
</ul>
</li>
</ul>
<h1 id="built-in-variables"><a class="markdownIt-Anchor" href="#built-in-variables"></a> Built-in Variables</h1>
<ul>
<li>
<p><code>-DCMAKE_EXE_LINKER_FLAGS=&quot;-fuse-ld=gold&quot;</code></p>
<ul>
<li>将 linker 由默认的 bfd 换成 gold, CMake 3.29+ 使用 <code>-DCMAKE_LINKER=gold</code></li>
</ul>
</li>
<li>
<p><code>-DCMAKE_EXPORT_COMPILE_COMMANDS=on</code></p>
<ul>
<li>生成 compile_commands.json</li>
</ul>
</li>
<li>
<p><code>-DCMAKE_CXX_FLAGS=&quot;-Wno-error=missing-field-initializers&quot;</code></p>
<ul>
<li>将 <code>missing-field-initializers</code> 由 error 转为 warning</li>
</ul>
</li>
<li>
<p><code>-DCMAKE_CXX_FLAGS=&quot;-stdlib=libc++ -fexperimental-library&quot;</code></p>
<ul>
<li>当你使用 LLVM 的 c++ runtimes 时， 需要额外指定这两个编译选项，否则编译器仍然会使用 <code>libstdc++.so.1</code></li>
</ul>
</li>
<li>
<p><code>-DCMAKE_EXE_LINKER_FLAGS=&quot;-nostartfiles&quot;</code></p>
<ul>
<li>解决 “Scrt1.o: undefined reference to <code>main</code>”</li>
</ul>
</li>
<li>
<p>CMAKE_SOURCE_DIR</p>
<ul>
<li>指所在工程顶层目录绝对路径，一般源码git-clone下来后就确定了</li>
</ul>
</li>
<li>
<p>CMAKE_CURRENT_SOURCE_DIR</p>
<ul>
<li>指CMakeLists.txt所在目录的绝对路径，随着CMakeLists.txt位置变化</li>
</ul>
</li>
<li>
<p><code>-DCMAKE_VERBOSE_MAKEFILE=ON</code></p>
<ul>
<li>产生非常详细的编译过程日志，包括目录改变，编译器选项和链接器选项</li>
</ul>
</li>
<li>
<p>CMAKE_INSTALL_PREFIX</p>
<ul>
<li>自定义安装路径, 默认 /usr/local</li>
</ul>
</li>
<li>
<p>`-DCMAKE_CXX_STANDARD=14</p>
<ul>
<li>C++ 版本号, 如 11, 14</li>
</ul>
</li>
<li>
<p><code>-DCMAKE_CXX_COMPILER_ID=GNU</code></p>
<ul>
<li>如 GNU, Clang, Intel, MSVC, 作用和 <code>CC=gcc CXX=g++</code> 一样</li>
</ul>
</li>
<li>
<p><code>-DCMAKE_CXX_FLAGS=&quot;-std=c++11&quot;</code></p>
<ul>
<li>C++ 编译器选项， 如 -std=c++11</li>
</ul>
</li>
</ul>
<h2 id="guideline"><a class="markdownIt-Anchor" href="#guideline"></a> Guideline</h2>
<ul>
<li>Declare your module with <code>ADD_LIBRARY</code> or <code>ADD_EXECUTABLE</code>.</li>
<li>Declare your build flags with <code>TARGET_xxx()</code>.</li>
<li>Declare your dependencies with <code>TARGET_LINK_LIBRARIES</code></li>
<li>Specify what is <code>PUBLIC</code> and what is <code>PRIVATE</code></li>
<li>Don’t make any assumption about the platform and compiler.</li>
<li>Make sure that all your projects can be built both standalone and as a subproject of another project.</li>
<li>Always add namespaced aliases for libraries.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(foo STATIC</span><br><span class="line">  foo1.cpp</span><br><span class="line">  foo2.cpp</span><br><span class="line">  )</span><br><span class="line">add_library(my::foo ALIAS foo)</span><br></pre></td></tr></table></figure>
</li>
<li>Don’t make libraries STATIC/SHARED unless they cannot be built otherwise.</li>
<li>Leave the control of BUILD_SHARED_LIBS to your clients.</li>
<li>Create macros to wrap commands that have output parameters. Otherwise, creat a function.</li>
<li>Modern CMake is about Targets and Properties!</li>
<li>Avoid custom variables in the arguments of project commands.</li>
<li>CMake is not a build system, but a build system generator.</li>
<li>Forget those commands:
<ul>
<li>add_compile_options()</li>
<li>include_directories()</li>
<li>link_directories()</li>
<li>link_libraries()</li>
</ul>
</li>
<li>Non-INTERFACE_ properties define the build specification of a targt</li>
<li>INTERFACE_ properties define the usage requirements of a target</li>
<li>Use target_link_libraries() to express direct dependencies</li>
<li>Don’t use <code>TARGET_LINK_LIBRARIES()</code> without specifying <code>PUBLIC</code>, <code>PRIVATE</code> or <code>INTERFACE</code>.</li>
</ul>
<h2 id="targets-and-properties"><a class="markdownIt-Anchor" href="#targets-and-properties"></a> Targets and Properties</h2>
<p>Modern CMake更像一个面向对象编程语言， Targets是Objects, 它们有Properties(Member Variables)和Commands(Methods),<br />
Targets的Properties包括编译这个Target的源文件，编译选项，以及最后链接的库这些都是一个Target的Properties. 只要是Properties，就有这个Property的作用域(Scope). Properties也有作用域的概念(scope), 对应<code>INTERFACE</code>和<code>PRIVATE</code>.<br />
INTERFACE properties是外部用的，也就是给导入或使用本Targets的其它Targets用的。PRIVATE properties是Targets内部用的。</p>
<h2 id="cmake-inheritance"><a class="markdownIt-Anchor" href="#cmake-inheritance"></a> CMake Inheritance</h2>
<h3 id="include-inheritance"><a class="markdownIt-Anchor" href="#include-inheritance"></a> Include Inheritance</h3>
<p>在 CMake 中，在预处理阶段搜索头文件是从 <code>INCLUDE_DIRECTORIES</code> 和 <code>INTERFACE_INCLUDE_DIRECTORIES</code> 这两个变量里包含的路径中搜索。<code>target_include_directories</code> 会将指定的路径都加入 <code>INCLUDE_DIRECTORIES</code>, 但是会依据 <code>&lt;PRIVATE|PUBLIC|INTERFACE&gt;</code> 有选择地将指定路径加入 <code>INTERFACE_INCLUDE_DIRECTORIES</code>. <code>INCLUDE_DIRECTORIES</code> 包含的路径只会被<strong>当前 target</strong> 作为搜索路径, 而 <code>INTERFACE_INCLUDE_DIRECTORIES</code> 包含的路径会被加到任何依赖当前 target 的 target 的 <code>INCLUDE_DIRECTORIES</code>.</p>
<h2 id="generator-expressions"><a class="markdownIt-Anchor" href="#generator-expressions"></a> Generator Expressions</h2>
<p>Generator Expressions（生成表达式）是指在生成构建系统的过程中（如果是Make构建系统，就是在生成Makefile的过程中）针对每个构建配置生成特定的值. 生成表达式有3类:</p>
<ul>
<li>Logical Expressions</li>
<li>Informational Expressions</li>
<li>Output Expressions</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_compile_definitions(foo PRIVATE</span><br><span class="line">    &quot;VERBOSITY=$&lt;IF:$&lt;CONFIG:Debug&gt;,30,10&gt;&quot;</span><br><span class="line">)    </span><br></pre></td></tr></table></figure>
<p>上例中使用了嵌套的generator expressions, <code>$&lt;CONFIG:cfg&gt;</code>嵌套在<code>$&lt;IF:?,true-value...,false-value...&gt;</code>, 两者都是logical expressions, 注意后者是CMake 3.8才有的。<code>$&lt;CONFIG:Debug&gt;</code>的意思是如果<code>CONFIG</code>是<code>Debug</code>,那么这个表达式的值是<code>1</code>,否则是<code>0</code>, 注意这个比较是不区分大小写的字符串比较。<code>$&lt;IF:?,true-value...,false-value...&gt;</code>就像三元表达式<code>a ? b : c</code>一样。</p>
<p>注意<code>0</code>和<code>1</code>是两个basic logical expressions,所有其它logical expressions的最终值都是<code>0</code>或<code>1</code>,所以下面的表达式是有效的</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span><a href="CONFIG:Debug">CONFIG:Debug</a>:DEBUG_MODE&gt;</p>
<p>它展开后是<code>$&lt;0:DEBUG_MODE&gt;</code>或<code>$&lt;1:DEBUG_MODE&gt;</code>,所以整个表达式最终值是<code>DEBUG_MODE</code>或空。</p>
<h2 id="find_package"><a class="markdownIt-Anchor" href="#find_package"></a> <code>find_package()</code></h2>
<p>如果cmake可以成功执行 <code>find_package(PACKAGE)</code>，那么说明你的系统上一定存在一个 <code>FindPACKAGE.cmake</code>的文件</p>
<ul>
<li><code>find_package(Threads REQUIRED)</code>: FindThreads.cmake 文件确定一个系统上的 thread 库，如果在Linux 下，如果找到的话就是 <code>libpthread.so</code> (C++ std::thread 依赖 <code>libpthread.so</code>)</li>
</ul>
<h2 id="pkg_check_modules"><a class="markdownIt-Anchor" href="#pkg_check_modules"></a> <code>pkg_check_modules()</code></h2>
<p>使用 <code>pkg_check_modules()</code> 前需要先(因为pkg_check_modules() 底层是依靠 pkg-config)</p>
<ul>
<li><code>find_package(PkgConfig)</code></li>
</ul>
<p>例如找到系统上的 <a href="http://libdrm.so">libdrm.so</a> (因为cmake和libdrm本身没有提供 FindLibDRM.cmake), 就需要</p>
<ul>
<li><code>pkg_check_modules(LIBDRM REQUIRED libdrm)</code></li>
</ul>
<p>这里 <code>LIBDRM</code> 是自定义的，但要与后面使用的变量名对齐，<a href="http://xn--libdrm-hh4kt54g.so">如果libdrm.so</a> 被找到，则以下变量会被置成相应的路径或值(基本上就是pkg-config 能查到的所有信息)</p>
<ul>
<li>LIBDRM_FOUND</li>
<li>LIBDRM_LIBRARIES</li>
<li>LIBDRM_LIBRARY_DIRS</li>
<li>LIBDRM_LDFLAGS</li>
<li>LIBDRM_LDFLAGS_OTHER</li>
<li>LIBDRM_INCLUDE_DIRS</li>
<li>LIBDRM_CFLAGS</li>
<li>LIBDRM_CFLAGS_OTHER</li>
</ul>
<h2 id="ctest"><a class="markdownIt-Anchor" href="#ctest"></a> CTest</h2>
<ul>
<li>
<p>打开CTest, 后续可以直接通过 <code>make [-C builddir] test</code> 运行测试用例</p>
<ul>
<li><code>enable_testing()</code></li>
</ul>
</li>
<li>
<p>增加测试用例</p>
<ul>
<li><code>add_test(NAME PALBench.test_cpu_read_vram COMMAND test_cpu_access_vram -size 1048576 -access read)</code></li>
</ul>
</li>
</ul>
<h1 id="notes"><a class="markdownIt-Anchor" href="#notes"></a> NOTES</h1>
<h2 id="-fpic"><a class="markdownIt-Anchor" href="#-fpic"></a> -fPIC</h2>
<ul>
<li>-fPIC 是一个编译器选项，而不是链接器选项。</li>
<li>当你正在构建的一个动态库(<a href="http://xn--libPAL-hh4k.so">如libPAL.so</a>)依赖另一个静态库(如libADT.a), 这时必须在 <code>add_library(ADT STATIC ...)</code> 之后增加编译选项 <code>-fPIC</code>, 这时需要使用
<ul>
<li><code>target_compile_options(ADT PRIVATE &quot;-fPIC&quot;)</code><br />
而不是</li>
<li><code>target_link_options(ADT PUBLIC &quot;-fPIC&quot;)</code></li>
</ul>
</li>
</ul>
<h2 id="_gnu_source"><a class="markdownIt-Anchor" href="#_gnu_source"></a> _GNU_SOURCE</h2>
<ul>
<li>编译器莫名其妙地报undeclared错误，如 <code>O_CLOEXEC</code> 未声明，即使已经包含了它的头文件 <code>fcntl.h</code> 也还报，这可能需要定义一下<code>_GNU_SOURCE</code>:
<ul>
<li><code>target_compile_definitions(target PUBLIC _GNU_SOURCE)</code></li>
</ul>
</li>
</ul>
<h1 id="小贴士"><a class="markdownIt-Anchor" href="#小贴士"></a> 小贴士</h1>
<ul>
<li><code>time ninja -C build | while read line; do echo $(date +%s.%N) $&#123;line&#125;; done</code>
<ul>
<li>输出编译时间</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>find</title>
    <url>/utils/find/</url>
    <content><![CDATA[<h1 id="find-命令"><a class="markdownIt-Anchor" href="#find-命令"></a> <code>find</code> 命令</h1>
<p><code>find</code> 命令用来在目录树里查找文件。本文主要介绍 GNU find. 它从每个 starting-point 开始递归搜索，通过求值 expression 的真值来确定输出结果。</p>
<h1 id="find-的命令行组成"><a class="markdownIt-Anchor" href="#find-的命令行组成"></a> <code>find</code> 的命令行组成</h1>
<p><img src="/images/find/find.drawio.png" alt="example-of-find" /></p>
<ul>
<li>Options</li>
<li>Starting-point</li>
<li>Expression
<ul>
<li>Tests</li>
<li>Actions</li>
<li>Global options</li>
<li>Position options</li>
<li>Operators</li>
</ul>
</li>
</ul>
<h1 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h1>
<ul>
<li>
<p>只在当前目录搜索（不递归）不以 f 或 g 或 h 开头的目录</p>
<ul>
<li><code>find . -maxdepth 1 -name '[^fgh]*' -type d</code>
<ul>
<li><code>-type d</code>: 找目录</li>
<li><code>-type f</code>: 找文件(不包括 symbolic link)</li>
<li><code>-type l</code>: 找符号链接文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>排除/proc 和 /tmp 这两个目录</p>
<ul>
<li><code>find / -path /proc -prune -o -path /tmp -prune -o -name &quot;README.md&quot;</code>
<ul>
<li><code>-prune</code> 告诉 find 跳过前面的目录，也可以用 <code>\( -o \)</code> 将多个 <code>-path</code> 合并，只保留一个 <code>-prune</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>只在当前目录查找除了指定及隐藏目录以外的所有目录，打印并删除</p>
<ul>
<li><code>find -maxdepth 1 \( -path ./gh -o -path ./aaa -o -path ./mesa-install -o -path ./1.3.290.0 -o -path ./1.3.280.1 \) -prune -o -type d ! -name &quot;.*&quot; -print -exec rm -rf &#123;&#125; \;</code>
<ul>
<li>注意匹配隐藏目录时用 <code>.*</code>, <code>.</code> 在 shell 里不是通配符</li>
<li><code>-print</code>： 不让 <code>./gh</code>, <code>./aaa</code> 这些目录出现在 <code>find</code> 命令的输出结果中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>查找 ~/gh 目录下只有文件属主(u)有执行权限(x)的文件 (精确匹配文件的 permission bits)</p>
<ul>
<li><code>find ~/gh -perm u=x -type f</code></li>
</ul>
</li>
<li>
<p>查找 ~/gh 目录下文件属主(u)有执行权限(x) 的文件（组用户(g)或其它用户(o)可能有或没有执行权限）</p>
<ul>
<li><code>find ~/gh -perm -u=x -type f</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Compiler Collection - gcc/g++</title>
    <url>/utils/gcc/</url>
    <content><![CDATA[<h1 id="__attribute__"><a class="markdownIt-Anchor" href="#__attribute__"></a> <code>__attribute__</code></h1>
<p><code>__attribute__</code> is a keyword introduced by GCC. It is regarded as an extension of a language. It helps the compiler optimize calls, check code more carefully for correctness, control memory placement and code generation options.</p>
<span id="more"></span>
<h2 id="syntax"><a class="markdownIt-Anchor" href="#syntax"></a> Syntax</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__ ((attribute-list))</span><br></pre></td></tr></table></figure>
<p>where an attribute-list is a possibly empty comma-separated sequence of attributes. Say:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void _init( void ) __attribute__((constructor));</span><br></pre></td></tr></table></figure>
<h2 id="categories"><a class="markdownIt-Anchor" href="#categories"></a> Categories</h2>
<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes">Function Attributes</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html#Variable-Attributes">Variable Attribute</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html#Type-Attributes">Type Attributes</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Label-Attributes.html#Label-Attributes">Label Attributes</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Enumerator-Attributes.html#Enumerator-Attributes">Enumerator Attributes</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Attributes.html#Statement-Attributes">Statement Attributes</a></li>
</ul>
<p>Let’s say to specify an attribute of variables.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern __thread struct _glapi_table * _glapi_tls_Dispatch</span><br><span class="line">    __attribute__((tls_model(&quot;initial-exec&quot;)));</span><br></pre></td></tr></table></figure>
<p>where the <code>tls_model</code> attribute sets thread-local storage model of a particular thread variable, overriding <code>-ftls-model=</code> command-line switch on a per-variable basis. The <a href="https://docs.oracle.com/cd/E53394_01/html/E54813/man-tlsam.html#scrolltoc"><code>tls_model</code></a> argument should be one of <code>global-dynamic</code>, <code>local-dynamic</code>, <code>initial-exec</code>, or <code>local-exec</code>.</p>
<h3 id="visibility"><a class="markdownIt-Anchor" href="#visibility"></a> <a href="http://anadoxin.org/blog/control-over-symbol-exports-in-gcc.html">Visibility</a></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((visibility(&quot;default&quot;)));</span><br></pre></td></tr></table></figure>
<p>this attribute involves with the visibility of exported symbols in a shared object, overriding <code>-fvisibility=hidden</code> command-line option during the compilation. The visibility argument should be one of <code>default</code>, <code>hidden</code>, <code>internal</code>, or <code>protected</code>.</p>
<h1 id="内置宏"><a class="markdownIt-Anchor" href="#内置宏"></a> 内置宏</h1>
<p>编译器会预定义许多宏，尤其在交叉编译时，不同的工具链编译器会定义不同的宏。例如:</p>
<ul>
<li><strong>aarch64</strong></li>
<li>__ARM_ARCH_7A</li>
<li>__ARM_ARCH_8A</li>
</ul>
<p>如果使用<strong>armv7</strong>的工具链，那么只有<code>__ARM_ARCH_7A</code>会被定义，而如果使用<strong>armv8</strong>的工具链，那么只有<code>__ARM_ARCH_8A</code>会被定义。但以上两个编译器都会定义<code>__aarch64__</code>.</p>
<h2 id="how-to-check-macros-predefined-by-compiler"><a class="markdownIt-Anchor" href="#how-to-check-macros-predefined-by-compiler"></a> How to Check Macros Predefined by Compiler</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc -march=armv8-a -E -dM - &lt; /dev/null</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-E</code> 是<code>gcc</code>的一个<code>common option</code>, 指示编译器只做预处理</li>
<li><code>-d&lt;letters&gt;</code> 是<code>gcc</code>的一个<code>common option</code>, 打开由字母指定的compiler pass的dump
<ul>
<li><code>-dM</code> 打印预处理阶段所有的宏<code>#define</code>, 包括预定义宏。</li>
<li><code>-dD</code> 功能和<code>-dM</code>类似，但它不包含预定义宏，而且它同时输出<code>#define</code>和预处理结果。</li>
<li><code>-dN</code> 功能和<code>-dD</code>类似，但只输出宏名，不展开宏。</li>
<li><code>-dI</code> 除了预处理结果外，还输出<code>#include</code>.</li>
<li><code>-dU</code> 功能和<code>-dD</code>类似，但只输出那些被展开的宏或在预处理中被<code>#if</code>, <code>#ifndef</code>测试过的宏。</li>
</ul>
</li>
</ul>
<h2 id="__builtin_offsetof"><a class="markdownIt-Anchor" href="#__builtin_offsetof"></a> <a href="https://gcc.gnu.org/onlinedocs/gcc/Offsetof.html"><code>__builtin_offsetof</code></a></h2>
<ul>
<li>C/C++ 宏 <code>offsetof</code> 包含在头文件 <code>stddef.h</code></li>
</ul>
<h1 id="内置函数"><a class="markdownIt-Anchor" href="#内置函数"></a> 内置函数</h1>
<h2 id="__builtin_clz"><a class="markdownIt-Anchor" href="#__builtin_clz"></a> <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html"><code>__builtin_clz</code></a></h2>
<p><code>int __builtin_clz(unsigned int x);</code></p>
<p>返回一个数的高位端的 <code>0</code> 的个数</p>
<h2 id="原子操作函数族"><a class="markdownIt-Anchor" href="#原子操作函数族"></a> <a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">原子操作函数族</a></h2>
<ul>
<li><code>type __atomic_add_fetch(type *ptr, type val, int memorder)</code></li>
</ul>
<p>以原子方式给 <code>ptr</code> 指向的内存值加上 <code>val</code>, 并返回 <code>ptr</code> 指向内存加完后的值。它与 GCC 的 <code>__sync_add_and_fetch()</code> 有何区别呢？ 唯一的区别是 <code>__atomic_add_fetch</code> 更新。</p>
<ul>
<li><code>bool __atomic_compare_exchange_n(type *ptr, type *expected, type desired, bool weak, int success_memorder, int failure_memorder)</code></li>
</ul>
<p>原子 CAS 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (*ptr == *expected); then</span><br><span class="line">   *ptr = desired  // read-modify-write</span><br><span class="line">else</span><br><span class="line">   *expected = *ptr // read</span><br></pre></td></tr></table></figure>
<p><code>type __sync_val_compare_and_swap (type *ptr, type oldval, type newval, ...)</code></p>
<p>内置的原子比较和交换操作，也就是说，如果 <code>*ptr</code> 的当前值是 <code>oldval</code>, 则把 <code>newval</code> 写入 <code>*ptr</code>, 并且返回写入前的 <code>*ptr</code> 值。</p>
<h1 id="与编译器相关的-keywords"><a class="markdownIt-Anchor" href="#与编译器相关的-keywords"></a> 与编译器相关的 keywords</h1>
<h2 id="volatile-vs-register"><a class="markdownIt-Anchor" href="#volatile-vs-register"></a> volatile vs. register</h2>
<table>
<thead>
<tr>
<th style="text-align:left">volatile</th>
<th style="text-align:left">register</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">type qualifier</td>
<td style="text-align:left">storage class</td>
</tr>
<tr>
<td style="text-align:left">force (compiler)</td>
<td style="text-align:left">hint (compiler)</td>
</tr>
<tr>
<td style="text-align:left">latency</td>
<td style="text-align:left">fast</td>
</tr>
<tr>
<td style="text-align:left">OK for global variables</td>
<td style="text-align:left">NOT for global variables</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Debugger - gdb</title>
    <url>/utils/gdb/</url>
    <content><![CDATA[<h1 id="gdb-cheat-sheet"><a class="markdownIt-Anchor" href="#gdb-cheat-sheet"></a> <a href="https://github.com/lucmann/x-cheatsheet">GDB Cheat Sheet</a></h1>
<p><img src="/images/gdb/gdb-cheatsheet-1.png" alt="gdb cheatsheet1" /></p>
<span id="more"></span>
<p><img src="/images/gdb/gdb-cheatsheet-2.png" alt="gdb cheatsheet2" /></p>
<h1 id="gdb-init-file"><a class="markdownIt-Anchor" href="#gdb-init-file"></a> GDB Init File</h1>
<p>GDB Init File 包含一组 gdb 命令，每次启动 gdb 时自动执行，这个文件可以有 3 个位置</p>
<ul>
<li><code>~/.config/gdb/gdbinit</code></li>
<li><code>~/.gdbinit</code></li>
<li><code>./.gdbinit</code></li>
</ul>
<h1 id="gdb-script-file"><a class="markdownIt-Anchor" href="#gdb-script-file"></a> GDB Script File</h1>
<p>将下面的 gdb 命令写入一个 script 文件里 <code>gdbscript.txt</code>，执行 <code>gdb glxgears -x gdbscript.txt</code>, gdb 会自动执行这个 script 文件里的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Avoid keyboard input</span><br><span class="line">set pagination off</span><br><span class="line"></span><br><span class="line"># Save log to file</span><br><span class="line">set logging file llvmpipe.log</span><br><span class="line">set logging enabled on</span><br><span class="line"></span><br><span class="line"># Avoid prompt that &quot;Make breakpoint pending on future shared library load?&quot;</span><br><span class="line">set breakpoint pending on</span><br><span class="line"></span><br><span class="line"># Add breakpoint at llvmpipe_flush()</span><br><span class="line">break llvmpipe_flush</span><br><span class="line">    command 1</span><br><span class="line">    shell date +&quot;%T.%3N&quot; &gt;&gt; llvmpipe.log # Append a timestamp to log file</span><br><span class="line">    backtrace</span><br><span class="line">    continue</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># Start the program</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">continue</span><br><span class="line"></span><br><span class="line">set logging off</span><br><span class="line">quit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>P.S. <a href="https://pastebin.com/bCEBrwAW">llvmpipe.log</a></p>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>Debugger</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Cheat Sheet</title>
    <url>/utils/git/</url>
    <content><![CDATA[<pre><code class="highlight mermaid">gitGraph
  commit id: &quot;1(good)&quot;
  commit id: &quot;2&quot;
  commit id: &quot;3&quot;
  branch test-commit-4
  commit id: &quot;4(good)&quot;
  branch test-commit-5-if-commit-6-is-bad
  commit id: &quot;5(first bad)&quot;
  branch test-commit-6-if-commit-4-is-good
  commit id: &quot;6(bad)&quot;
  commit id: &quot;7(bad)&quot;</code></pre>
<span id="more"></span>
<h1 id="git-am"><a class="markdownIt-Anchor" href="#git-am"></a> git am</h1>
<ul>
<li><code>git am foo.patch</code>
<ul>
<li>应用补丁 foo.patch (注意与 <code>git apply</code> 的区别，<code>git am</code> 同时会将commit log 也应用上去)</li>
</ul>
</li>
<li><code>git am -i -3 /tmp/patches/*</code>
<ul>
<li><code>-i</code>：交互式地 apply patch, 即每个 Patch 都询问 <em>Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all:</em></li>
<li><code>-3</code>: 当有冲突时进入 3way merge 模式，即允许你手动解决冲突(如果 git 自动解决不了)，然后 <code>git am -i --continue</code></li>
</ul>
</li>
</ul>
<h1 id="git-bisect"><a class="markdownIt-Anchor" href="#git-bisect"></a> git bisect</h1>
<ul>
<li><code>git bisect start &lt;end-commit&gt; &lt;start-commit&gt;</code>
<ul>
<li>一般 <em>end-commit</em> 是最近的提交(如 HEAD), <em>start-commit</em> 是比较老的提交</li>
<li>执行这个命令，代码库会 checkout 到这个范围<strong>正当中</strong>的那个提交，接下来你可以做一些测试和验证</li>
</ul>
</li>
<li><code>git bisect good</code> 或 <code>git bisect bad</code>
<ul>
<li>根据前面测试的结果，设置当前的提交是 <em>good</em> 还是 <em>bad</em></li>
<li>如此重复前两步，直到找到问题提交</li>
</ul>
</li>
<li><code>git bisect log &gt; file.txt</code>
<ul>
<li>打印出前两步的过程记录</li>
</ul>
</li>
<li><code>git bisect replay file.txt</code>
<ul>
<li>将 bisect 过程记录加以修改，重新执行</li>
</ul>
</li>
<li><code>git bisect reset</code>
<ul>
<li>将仓库由<strong>二分查找</strong>状态恢复到原来状态</li>
</ul>
</li>
</ul>
<h1 id="git-clone"><a class="markdownIt-Anchor" href="#git-clone"></a> git clone</h1>
<ul>
<li><code>git clone --recurse-submodules</code>
<ul>
<li>克隆仓库时连同子仓库一同克隆</li>
</ul>
</li>
</ul>
<h1 id="git-describe"><a class="markdownIt-Anchor" href="#git-describe"></a> git describe</h1>
<ul>
<li>
<p><code>git describe &lt;commit&gt;</code></p>
<ul>
<li>找到离 <code>&lt;commit&gt;</code> 最近的 tag</li>
</ul>
</li>
<li>
<p><code>git describe --contains &lt;commit&gt;</code></p>
<ul>
<li>找到<strong>包含</strong> <code>&lt;commit&gt;</code> 的 tag</li>
<li>例：<code>git describe --contains a6149f03</code>
<ul>
<li><code>v6.8-rc1~111^2~23^2~81</code></li>
</ul>
</li>
<li>它和不加 <code>--contains</code> 的区别是，<code>git describe</code> 仅仅是<strong>离得最近</strong>，从前往后都算，而 <code>git describe --contains</code> 是 <strong>包含</strong>，上面例子中命令的输出 <code>v6.8-rc1~111^2~23^2~81</code>， 表示在 v6.8 中一定包含 <code>a6149f03</code> 这个 commit, 而且它指出了具体的位置：从 <code>v6.8-rc1</code> 这个 tag 的 commit 往后第 111 个 commit (<code>^2</code> 表示它是一个 <strong>merge commit</strong>), 从这个 merge commit 再往后第 23 个 commit (仍然是一个 merge commit), 从这个 commit 再往后第 81 个 commit， 就是 <code>a6149f03</code></li>
</ul>
</li>
</ul>
<h1 id="git-for-each-ref"><a class="markdownIt-Anchor" href="#git-for-each-ref"></a> git for-each-ref</h1>
<ul>
<li>`git for-each-ref --sort=taggerdate --format=‘%(align:12)%(refname:short)%(end) | %(taggerdate:short)’ ‘refs/tags/v6.17*’
<ul>
<li>
<p>格式化输出所有以 <code>v6.17</code> 开头的 tags</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v6.17-rc1    | 2025-08-10</span><br><span class="line">v6.17-rc2    | 2025-08-17</span><br><span class="line">v6.17-rc3    | 2025-08-24</span><br><span class="line">v6.17-rc4    | 2025-08-31</span><br><span class="line">v6.17-rc5    | 2025-09-07</span><br><span class="line">v6.17-rc6    | 2025-09-14</span><br><span class="line">v6.17-rc7    | 2025-09-21</span><br><span class="line">v6.17        | 2025-09-28</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>git 的 <code>--format</code> 想要达到 C printf 的 <code>%-12s</code> 的效果需要使用 <code>%(align:N)%(fieldname:short)%(end)</code></p>
</li>
</ul>
</li>
</ul>
<h1 id="git-log"><a class="markdownIt-Anchor" href="#git-log"></a> git log</h1>
<ul>
<li><code>git log -S&lt;regex&gt; --pickaxe-regex /path/to/a/file</code>
<ul>
<li>查找匹配的字串在这个文件中出现的次数发生变化的 commit</li>
</ul>
</li>
<li><code>git log -G&lt;regex&gt; /path/to/a/file</code>
<ul>
<li>查找到涉及修改文件 <code>file</code> 的内容匹配正则表达式 <regex> 的 commit</li>
</ul>
</li>
<li><code>git log --diff-filter=D --summary --oneline</code>
<ul>
<li>找出有文件删除记录的 commit, 并显示出哪些文件被删除</li>
<li>filters 有:
<ul>
<li>A: Added</li>
<li>C: Copied</li>
<li>D: Deleted</li>
<li>M: Modified</li>
<li>R: Renamed</li>
</ul>
</li>
<li>当 filters 使用小写时，表示<strong>不包含</strong>这些变更类型</li>
</ul>
</li>
<li><code>git log --oneline --grep &quot;fix:&quot;</code>
<ul>
<li>tig 类似的参数是 <code>--grep=&quot;fix:&quot;</code></li>
</ul>
</li>
</ul>
<h1 id="git-ls-remote"><a class="markdownIt-Anchor" href="#git-ls-remote"></a> git ls-remote</h1>
<ul>
<li><code>git ls-remote upstream</code>
<ul>
<li>当有多个 remote 同时存在时，指定查看某个 remote 的 refs</li>
</ul>
</li>
</ul>
<h1 id="git-remote"><a class="markdownIt-Anchor" href="#git-remote"></a> git remote</h1>
<ul>
<li><code>git remote prune &lt;remote&gt;</code>
<ul>
<li>将给定的 <code>&lt;remote&gt;</code> 远端不存在的<strong>本地分支</strong>全部删除(注意: rm -rf 警告，最好先 <code>git remote prune --dry-run &lt;remote&gt;</code>)</li>
</ul>
</li>
</ul>
<h1 id="git-shortlog"><a class="markdownIt-Anchor" href="#git-shortlog"></a> git shortlog</h1>
<ul>
<li>`git shortlog -sne --author=“Name Surname”
<ul>
<li>统计某个贡献者的提交，像这样：<code>17  Luc Ma &lt;luc@sietium.com&gt;</code></li>
</ul>
</li>
</ul>
<h1 id="git-submodule"><a class="markdownIt-Anchor" href="#git-submodule"></a> git submodule</h1>
<ul>
<li><code>git submodule init</code>
<ul>
<li>在主仓库初始化一个子仓库</li>
</ul>
</li>
<li><code>git submodule update</code>
<ul>
<li>更新所有子仓库
<ul>
<li><code>git submodule update --recursive</code>
<ul>
<li>递归地更新所有子仓库，有时候子仓库里又有子仓库，如<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Submodule path &#x27;thirdparty/snappy&#x27;: checked out &#x27;6af9287fbdb913f0794d0148c6aa43b58e63c8e3&#x27;</span><br><span class="line">Submodule path &#x27;thirdparty/snappy/third_party/benchmark&#x27;: checked out &#x27;d572f4777349d43653b21d6c2fc63020ab326db2&#x27;</span><br><span class="line">Submodule path &#x27;thirdparty/snappy/third_party/googletest&#x27;: checked out &#x27;b796f7d44681514f58a683a3a71ff17c94edb0c1&#x27;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>fatal: remote error: upload-pack: not our ref e15ab44e64c70b54fc375c019c95bddc066a84cf fatal: Fetched in submodule path 'submodules/ImGuiScope', but it did not contain e15ab44e64c70b54fc375c019c95bddc066a84cf. Direct fetching of that commit failed</code>
<ul>
<li>如果你需要在一个 submodule 仓库里添加自己的修改，那么可能需要将 <code>.gitmodules</code> 文件里对应仓库的 <code>url</code> 变成你自己的<strong>远程可写</strong>仓库的 URL</li>
</ul>
</li>
</ul>
<h1 id="gitignore"><a class="markdownIt-Anchor" href="#gitignore"></a> .gitignore</h1>
<h2 id="记几个与gitignore相关的命令"><a class="markdownIt-Anchor" href="#记几个与gitignore相关的命令"></a> 记几个与gitignore相关的命令：</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git check-ignore -v file # 输出file是写在哪个.gitignore文件中</span><br><span class="line">git status -s --ignored # 查看所有被ignored的文件</span><br><span class="line">git ls-tree -r --name-only master # 查看所有被tracked的文件</span><br><span class="line">git rm --cached file # 永久撤销对file文件的跟踪</span><br></pre></td></tr></table></figure>
<h2 id="记几个与gitignore相关的要点"><a class="markdownIt-Anchor" href="#记几个与gitignore相关的要点"></a> 记几个与gitignore相关的要点：</h2>
<ul>
<li>git支持嵌套的<code>.gitignore</code>文件，就是说可以在repo下的某个子目录里写一个<code>.gitignore</code>文件，但是这个<code>.gitignore</code>只能影响这个目录下的内容</li>
<li><code>.gitignore</code>文件里的记录<em>只影响untracked</em>的文件，就是说如果想ignore一个之前已经跟踪了的文件，就必须先对这个文件执行<code>git rm --cached</code>，否则即使把这个文件写到<code>.gitignore</code>中也不生效。而且会产生疑惑，明明已经把某个文件加到<code>.gitignore</code>中了，为什么仍然被跟踪? 这时最好使用<code>git ls-tree -r --name-only master</code>命令确认那个文件是否还在被跟踪。</li>
</ul>
<h1 id="github"><a class="markdownIt-Anchor" href="#github"></a> GitHub</h1>
<h2 id="ssh-connect-to-host-githubcom-port-22-connection-timed-out"><a class="markdownIt-Anchor" href="#ssh-connect-to-host-githubcom-port-22-connection-timed-out"></a> <code>ssh: connect to host github.com port 22: Connection timed out</code></h2>
<p>之前好好的，突然 <code>git pull</code>, <code>git clone</code> 等这个错误，两种解决方法</p>
<ul>
<li>修改 git 配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global &quot;url.ssh://git@ssh.github.com:443/.insteadOf&quot; git@github.com:</span><br></pre></td></tr></table></figure>
<ul>
<li>修改 ssh 配置</li>
</ul>
<figure class="highlight vim"><figcaption><span>~/.ssh/config</span></figcaption><table><tr><td class="code"><pre><span class="line">Host github.<span class="keyword">com</span></span><br><span class="line">    Hostname ssh.github.<span class="keyword">com</span></span><br><span class="line">    Port <span class="number">443</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog using Hexo</title>
    <url>/utils/hexo/</url>
    <content><![CDATA[<h1 id="npm"><a class="markdownIt-Anchor" href="#npm"></a> npm</h1>
<p>hexo 依赖的很多 nodejs 包都过期了，但发现在Ubuntu 23.04 上很难更新(编译node-sass 要用的 python2 都需要自己源码编译安装)，索性先搁置吧。</p>
<span id="more"></span>
<ul>
<li><code>npm install</code> 慢
<ul>
<li><code>npm config get registry</code></li>
<li><code>npm config set registry=https://registry.npmmirror.com</code></li>
</ul>
</li>
<li><code>FetchError: request to https://registry.npm.taobao.org/ansi-regex failed, reason: certificate has expired</code>
<ul>
<li><code>npm config set strict-ssl false</code></li>
<li><code>npm cache clean --force</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Installable Client Driver</title>
    <url>/utils/icd/</url>
    <content><![CDATA[<h1 id="来自-chatgpt-的解释"><a class="markdownIt-Anchor" href="#来自-chatgpt-的解释"></a> 来自 <a href="https://openprompt.co/ChatGPT">ChatGPT</a> 的解释</h1>
<h2 id="what-is-vulkan-icd"><a class="markdownIt-Anchor" href="#what-is-vulkan-icd"></a> What is Vulkan ICD?</h2>
<blockquote>
<p>Vulkan ICD (Installable Client Driver) is a software component that enables the Vulkan API (Application Programming Interface) to interact with the hardware of a computer system. Vulkan is a low-level graphics API developed by the Khronos Group, which provides developers with more control over hardware resources, leading to improved performance and efficiency in graphics-intensive applications such as video games. The Vulkan ICD is responsible for managing the communication between the Vulkan API and the graphics hardware of a system. It is typically provided by the manufacturer of the graphics card as a driver for the system.</p>
</blockquote>
<span id="more"></span>
<h2 id="what-is-opencl-icd"><a class="markdownIt-Anchor" href="#what-is-opencl-icd"></a> What is OpenCL ICD?</h2>
<blockquote>
<p>OpenCL ICD (Installable Client Driver) is a component of OpenCL (Open Computing Language) that enables a computer system to access the processing power of multiple devices, such as CPUs and GPUs, as a unified compute resource. OpenCL is a framework for programming heterogeneous systems, which means systems that consist of multiple processing units with different architectures. The OpenCL ICD manages the communication between the OpenCL API and the devices available on the system, allowing developers to write code that can run on a variety of devices. It provides flexibility to the developers in choosing the device based on the requirements of the application. The OpenCL ICD is typically provided by the manufacturer of the device as a driver for the system.</p>
</blockquote>
<h1 id="mesa-opencl-icd-与-intel-opencl-icd-的对比"><a class="markdownIt-Anchor" href="#mesa-opencl-icd-与-intel-opencl-icd-的对比"></a> <code>mesa-opencl-icd</code> 与 <code>intel-opencl-icd</code> 的对比</h1>
<h2 id="mesa-opencl-icd"><a class="markdownIt-Anchor" href="#mesa-opencl-icd"></a> <code>mesa-opencl-icd</code></h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./etc/</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./etc/OpenCL/</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./etc/OpenCL/vendors/</span><br><span class="line">-rw-r--r-- root/root        19 2022-03-09 00:37 ./etc/OpenCL/vendors/mesa.icd</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/lib/</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/gallium-pipe/</span><br><span class="line">-rw-r--r-- root/root  10555528 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/gallium-pipe/pipe_iris.so</span><br><span class="line">-rw-r--r-- root/root   7895008 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/gallium-pipe/pipe_nouveau.so</span><br><span class="line">-rw-r--r-- root/root   6214144 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/gallium-pipe/pipe_r300.so</span><br><span class="line">-rw-r--r-- root/root   7228928 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/gallium-pipe/pipe_r600.so</span><br><span class="line">-rw-r--r-- root/root   7677888 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/gallium-pipe/pipe_radeonsi.so</span><br><span class="line">-rw-r--r-- root/root   6449632 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/gallium-pipe/pipe_swrast.so</span><br><span class="line">-rw-r--r-- root/root   6217504 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/gallium-pipe/pipe_vmwgfx.so</span><br><span class="line">-rw-r--r-- root/root   1549288 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/libMesaOpenCL.so.1.0.0</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/share/</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/share/bug/</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/share/bug/mesa-opencl-icd/</span><br><span class="line">-rw-r--r-- root/root        44 2022-03-09 00:37 ./usr/share/bug/mesa-opencl-icd/control</span><br><span class="line">-rwxr-xr-x root/root       448 2022-03-09 00:37 ./usr/share/bug/mesa-opencl-icd/script</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/share/doc/</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/share/doc/mesa-opencl-icd/</span><br><span class="line">-rw-r--r-- root/root       823 2022-03-09 00:37 ./usr/share/doc/mesa-opencl-icd/changelog.Debian.gz</span><br><span class="line">-rw-r--r-- root/root     14241 2022-03-09 00:37 ./usr/share/doc/mesa-opencl-icd/copyright</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/share/lintian/</span><br><span class="line">drwxr-xr-x root/root         0 2022-03-09 00:37 ./usr/share/lintian/overrides/</span><br><span class="line">-rw-r--r-- root/root        49 2022-03-09 00:37 ./usr/share/lintian/overrides/mesa-opencl-icd</span><br><span class="line">lrwxrwxrwx root/root         0 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/libMesaOpenCL.so -&gt; libMesaOpenCL.so.1</span><br><span class="line">lrwxrwxrwx root/root         0 2022-03-09 00:37 ./usr/lib/x86_64-linux-gnu/libMesaOpenCL.so.1 -&gt; libMesaOpenCL.so.1.0.0</span><br></pre></td></tr></table></figure>
<h2 id="intel-opencl-icd"><a class="markdownIt-Anchor" href="#intel-opencl-icd"></a> <code>intel-opencl-icd</code></h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./etc/</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./etc/OpenCL/</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./etc/OpenCL/vendors/</span><br><span class="line">-rw-r--r-- root/root        52 2020-04-09 03:55 ./etc/OpenCL/vendors/intel.icd</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./usr/</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./usr/bin/</span><br><span class="line">-rwxr-xr-x root/root    406064 2020-04-09 03:55 ./usr/bin/ocloc</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./usr/lib/</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./usr/lib/x86_64-linux-gnu/</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./usr/lib/x86_64-linux-gnu/intel-opencl/</span><br><span class="line">-rw-r--r-- root/root   5049688 2020-04-09 03:55 ./usr/lib/x86_64-linux-gnu/intel-opencl/libigdrcl.so</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./usr/share/</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./usr/share/doc/</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-09 03:55 ./usr/share/doc/intel-opencl-icd/</span><br><span class="line">-rw-r--r-- root/root       389 2020-04-09 03:55 ./usr/share/doc/intel-opencl-icd/changelog.Debian.gz</span><br><span class="line">-rw-r--r-- root/root      5085 2020-04-06 17:05 ./usr/share/doc/intel-opencl-icd/copyright</span><br></pre></td></tr></table></figure>
<p>安装 <code>*-opencl-icd</code> 软件包并不会安装 OpenCL 开发相关头文件：<code>&lt;CL/cl.h&gt;</code></p>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>lspci 学习笔记</title>
    <url>/utils/lspci/</url>
    <content><![CDATA[<h1 id="与-pci-设备相关的一些-ids"><a class="markdownIt-Anchor" href="#与-pci-设备相关的一些-ids"></a> 与 PCI 设备相关的一些 IDs</h1>
<ul>
<li>Device ID: 4 位十六进制数字</li>
<li>Vendor ID: 4 位十六进制数字</li>
<li>Domain ID: 4 位十六进制数字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3772:00:00.0 0100: 1af4:1049 (rev 01)</span><br><span class="line">5401:00:00.0 0880: 1af4:105a (rev 01)</span><br><span class="line">b30b:00:00.0 0302: 1414:008e</span><br><span class="line">c4c5:00:00.0 0100: 1af4:1049 (rev 01)</span><br><span class="line">cdbf:00:00.0 0100: 1af4:1049 (rev 01)</span><br></pre></td></tr></table></figure>
<p><code>lspci -Dn</code> 的输出格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;domain&gt;:&lt;bus&gt;:&lt;slot&gt;.&lt;func&gt;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>slot</code> 其实就是 <code>device</code>, 而且只包含 2 位十六进制数字。我们可以从 <code>lspci</code> 的<a href="https://github.com/pciutils/pciutils/blob/master/lspci.c">源码</a>看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">show_slot_path</span><span class="params">(<span class="keyword">struct</span> device *d)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">p</span> =</span> d-&gt;dev;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opt_path)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">bus</span> *<span class="title">bus</span> =</span> d-&gt;parent_bus;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">bridge</span> *<span class="title">br</span> =</span> bus-&gt;parent_bridge;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (br &amp;&amp; br-&gt;br_dev)</span><br><span class="line">	&#123;</span><br><span class="line">	  show_slot_path(br-&gt;br_dev);</span><br><span class="line">	  <span class="keyword">if</span> (opt_path &gt; <span class="number">1</span>)</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;/%02x:%02x.%d&quot;</span>, p-&gt;bus, p-&gt;dev, p-&gt;func);</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;/%02x.%d&quot;</span>, p-&gt;dev, p-&gt;func);</span><br><span class="line">	  <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%02x:%02x.%d&quot;</span>, p-&gt;bus, p-&gt;dev, p-&gt;func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lspci 之所以只使用 2 位十六进制数字分别表示 <code>bus</code>, <code>slot</code>(<code>dev</code>), 是因为它们被定义成 8 位位宽</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">next</span>;</span>			<span class="comment">/* Next device in the chain */</span></span><br><span class="line">  u16 domain_16;			<span class="comment">/* 16-bit version of the PCI domain for backward compatibility */</span></span><br><span class="line">					<span class="comment">/* 0xffff if the real domain doesn&#x27;t fit in 16 bits */</span></span><br><span class="line">  u8 bus, dev, func;			<span class="comment">/* Bus inside domain, device and function */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These fields are set by pci_fill_info() */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> known_fields;		<span class="comment">/* Set of info fields already known (see pci_fill_info()) */</span></span><br><span class="line">  u16 vendor_id, device_id;		<span class="comment">/* Identity of the device */</span></span><br><span class="line">  u16 device_class;			<span class="comment">/* PCI device class */</span></span><br><span class="line">  <span class="type">int</span> irq;				<span class="comment">/* IRQ number */</span></span><br><span class="line">  <span class="type">pciaddr_t</span> base_addr[<span class="number">6</span>];		<span class="comment">/* Base addresses including flags in lower bits */</span></span><br><span class="line">  <span class="type">pciaddr_t</span> size[<span class="number">6</span>];			<span class="comment">/* Region sizes */</span></span><br><span class="line">  <span class="type">pciaddr_t</span> rom_base_addr;		<span class="comment">/* Expansion ROM base address */</span></span><br><span class="line">  <span class="type">pciaddr_t</span> rom_size;			<span class="comment">/* Expansion ROM size */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pci_cap</span> *<span class="title">first_cap</span>;</span>		<span class="comment">/* List of capabilities */</span></span><br><span class="line">  <span class="type">char</span> *phy_slot;			<span class="comment">/* Physical slot */</span></span><br><span class="line">  <span class="type">char</span> *module_alias;			<span class="comment">/* Linux kernel module alias */</span></span><br><span class="line">  <span class="type">char</span> *label;				<span class="comment">/* Device name as exported by BIOS */</span></span><br><span class="line">  <span class="type">int</span> numa_node;			<span class="comment">/* NUMA node */</span></span><br><span class="line">  <span class="type">pciaddr_t</span> flags[<span class="number">6</span>];			<span class="comment">/* PCI_IORESOURCE_* flags for regions */</span></span><br><span class="line">  <span class="type">pciaddr_t</span> rom_flags;			<span class="comment">/* PCI_IORESOURCE_* flags for expansion ROM */</span></span><br><span class="line">  <span class="type">int</span> domain;				<span class="comment">/* PCI domain (host bridge) */</span></span><br><span class="line">  <span class="type">pciaddr_t</span> bridge_base_addr[<span class="number">4</span>];	<span class="comment">/* Bridge base addresses (without flags) */</span></span><br><span class="line">  <span class="type">pciaddr_t</span> bridge_size[<span class="number">4</span>];		<span class="comment">/* Bridge sizes */</span></span><br><span class="line">  <span class="type">pciaddr_t</span> bridge_flags[<span class="number">4</span>];		<span class="comment">/* PCI_IORESOURCE_* flags for bridge addresses */</span></span><br><span class="line">  u8 prog_if, rev_id;			<span class="comment">/* Programming interface for device_class and revision id */</span></span><br><span class="line">  u16 subsys_vendor_id, subsys_id;	<span class="comment">/* Subsystem vendor id and subsystem id */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">parent</span>;</span>		<span class="comment">/* Parent device, does not have to be always accessible */</span></span><br><span class="line">  <span class="type">int</span> no_config_access;			<span class="comment">/* No access to config space for this device */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fields used internally */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pci_access</span> *<span class="title">access</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pci_methods</span> *<span class="title">methods</span>;</span></span><br><span class="line">  u8 *cache;				<span class="comment">/* Cached config registers */</span></span><br><span class="line">  <span class="type">int</span> cache_len;</span><br><span class="line">  <span class="type">int</span> hdrtype;				<span class="comment">/* Cached low 7 bits of header type, -1 if unknown */</span></span><br><span class="line">  <span class="type">void</span> *aux;				<span class="comment">/* Auxiliary data for use by the back-end */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pci_property</span> *<span class="title">properties</span>;</span>	<span class="comment">/* A linked list of extra properties */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pci_cap</span> *<span class="title">last_cap</span>;</span>		<span class="comment">/* Last capability in the list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="xorg-config-之-device-section"><a class="markdownIt-Anchor" href="#xorg-config-之-device-section"></a> Xorg config 之 <code>Device</code> Section</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section &quot;Device&quot;</span><br><span class="line">Identifier &quot;name&quot;</span><br><span class="line">Driver &quot;driver&quot;</span><br><span class="line">BusID &quot;bus-id&quot;</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>
<p><code>Device</code> Section 中 <code>BusID</code> 的格式是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PCI:bus:device:func</span><br></pre></td></tr></table></figure>
<h1 id="xorg-log-中的-pci-信息格式"><a class="markdownIt-Anchor" href="#xorg-log-中的-pci-信息格式"></a> Xorg log 中的 PCI 信息格式</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xf86Msg(X_PROBED, <span class="string">&quot;PCI:%s(%u@%u:%u:%u) %04x:%04x:%04x:%04x &quot;</span>, prim,</span><br><span class="line">        info-&gt;bus, info-&gt;domain, info-&gt;dev, info-&gt;func,</span><br><span class="line">        info-&gt;vendor_id, info-&gt;device_id,</span><br><span class="line">        info-&gt;subvendor_id, info-&gt;subdevice_id);</span><br></pre></td></tr></table></figure>
<p>日志中的 PCI BusID 格式是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bus@domain:device:func</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Make Cheatsheet</title>
    <url>/utils/make/</url>
    <content><![CDATA[<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">  recipe</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li><strong>target …</strong> 说明在一条规则里 target 可以有多个</li>
<li><strong>prerequisites</strong> 可以为空</li>
<li><strong>recipe</strong> 可以为空, 这时 make 相应的 target 会提示
<ul>
<li><code>Nothing to be done for 'target'.</code></li>
<li>可以通过 <code>;</code> 分号显示地指出 recipe 是空
<ul>
<li><code>target: ;</code></li>
</ul>
</li>
</ul>
</li>
<li>如果 make 命令行没有指定任何目标，make 会将 Makefile 里解析出来的<strong>第一个目标</strong>作为默认目标</li>
</ul>
<h1 id="make-基本原理"><a class="markdownIt-Anchor" href="#make-基本原理"></a> Make 基本原理</h1>
<h2 id="static-pattern-rules"><a class="markdownIt-Anchor" href="#static-pattern-rules"></a> Static Pattern Rules</h2>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">targets ...: target-pattern: prereq-patterns ...</span><br><span class="line">  recipe</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h2 id="static-pattern-rules-vs-implicit-rules"><a class="markdownIt-Anchor" href="#static-pattern-rules-vs-implicit-rules"></a> Static Pattern Rules vs. Implicit Rules</h2>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">target-pattern : prereq-patterns</span><br><span class="line">  recipe</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h1 id="make-常用参数"><a class="markdownIt-Anchor" href="#make-常用参数"></a> Make 常用参数</h1>
<h2 id="-d-debugflags"><a class="markdownIt-Anchor" href="#-d-debugflags"></a> -d, --debug=FLAGS</h2>
<ul>
<li>所有支持的 FLAGS (多个 flags 用<code>,</code> 分开)</li>
<li>Debug Level Specification (GNU Make 4.3)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">标志</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">All</td>
<td style="text-align:left">启用所有调试输出（等效于单独使用 -d）</td>
</tr>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:left">Basic</td>
<td style="text-align:left">基本调试：显示目标重建决策、过期检查等核心信息</td>
</tr>
<tr>
<td style="text-align:left">v</td>
<td style="text-align:left">Verbose</td>
<td style="text-align:left">详细模式：比 b 更详细的执行信息</td>
</tr>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">Implicit</td>
<td style="text-align:left">隐式规则：显示隐式规则搜索/应用过程</td>
</tr>
<tr>
<td style="text-align:left">j</td>
<td style="text-align:left">Jobs</td>
<td style="text-align:left">作业控制：输出子进程执行细节（命令/PID/退出码）</td>
</tr>
<tr>
<td style="text-align:left">m</td>
<td style="text-align:left">Makefile</td>
<td style="text-align:left">Makefile 处理：跟踪 include/重解析过程</td>
</tr>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">Remaking</td>
<td style="text-align:left">重制检查：显示 makefile 自身的重制决策</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td style="text-align:left">None</td>
<td style="text-align:left">禁用所有调试（特殊用途）</td>
</tr>
</tbody>
</table>
<!--more-->
<h1 id="make-常用变量"><a class="markdownIt-Anchor" href="#make-常用变量"></a> Make 常用变量</h1>
<h2 id="make-变量赋值操作符"><a class="markdownIt-Anchor" href="#make-变量赋值操作符"></a> Make 变量赋值操作符</h2>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">immediate = deferred</span><br><span class="line">immediate ?= deferred</span><br><span class="line">immediate := immediate</span><br><span class="line">immediate ::= immediate</span><br><span class="line">immediate :::= immediate-with-escape</span><br><span class="line">immediate += deferred or immediate</span><br><span class="line">immediate != immediate</span><br></pre></td></tr></table></figure>
<ul>
<li><code>!=</code> 用于将 shell 命令执行的结果赋给变量，等价于 <code>variable := $(shell shell_cmd)</code></li>
</ul>
<h2 id="makecmdgoals"><a class="markdownIt-Anchor" href="#makecmdgoals"></a> MAKECMDGOALS</h2>
<p>表示执行 make 命令时用户给入的 targets, 这里<em>执行 make 命令时</em> 不仅包括从终端命令行执行 make, 也包括在 Makefile 规则里执行 <code>make -f ...</code></p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(info <span class="variable">$(MAKECMDGOALS)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果执行 <code>make</code>, 它不会打印任何东西，但如果执行 <code>make all</code>, 它的输出是 <code>all</code></p>
<h2 id="makefile_list"><a class="markdownIt-Anchor" href="#makefile_list"></a> MAKEFILE_LIST</h2>
<p>被 make 解析过的所有 Makefile 文件名列表，按照解析的先后顺序由左到右罗列。如果当前的 Makefile 里使用了 <code>include</code>, 如 <code>include inc.mk</code>, 那么 <code>inc.mk</code> 就会成为这个列表的最后一个。注意它是<strong>文件名</strong>列表，不是文件路径列表</p>
<h2 id="curdir"><a class="markdownIt-Anchor" href="#curdir"></a> CURDIR</h2>
<p>Makefile 所在的目录的<strong>绝对路径</strong></p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(info <span class="variable">$(CURDIR)</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果这个 Makefile 位于 <code>/home/luc/gh/Makefile</code>, 它打印的就是 <code>/home/luc/gh</code></p>
<h1 id="make-常用函数"><a class="markdownIt-Anchor" href="#make-常用函数"></a> Make 常用函数</h1>
<h2 id="info-error-warning"><a class="markdownIt-Anchor" href="#info-error-warning"></a> info, error, warning</h2>
<ul>
<li>原型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(info text...)</span><br><span class="line">$(error text...)</span><br><span class="line">$(warning text...)</span><br></pre></td></tr></table></figure>
<ul>
<li>这3个函数被放在 GNU Make 官方文件 <a href="https://www.gnu.org/software/make/manual/html_node/Make-Control-Functions.html">8.13 Functions That Control Make</a> 章节，这里把它们放在常用函数最前面，是因为它们对于验证调试 Makefile 非常有用</li>
<li><code>$(info text...)</code> 相当于 <code>printf()</code></li>
<li><code>$(error text...)</code> 相当于 <code>assert(0)</code></li>
<li>info 和 warning 的区别是前者打印在 <strong>stdout</strong>, 后者打印在 <strong>stderr</strong></li>
<li>原样打印，不支持转义字符如 <code>\n</code></li>
<li>info, warning, error 函数打印调试 makefile 之所以比在规则里使用 <code>echo</code> 方便，是因为它们作为内置函数可以在 makefile 的任何地方单独出现，而不像 echo 只能在规则里出现</li>
<li>make 里的函数也会<strong>展开 expansion</strong>, 相当于 make 函数都有返回值，info, warning 函数展开后都是空字串</li>
</ul>
</li>
</ul>
<h2 id="dir-notdir"><a class="markdownIt-Anchor" href="#dir-notdir"></a> dir, notdir</h2>
<ul>
<li>原型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir names...)</span><br><span class="line">$(notdir names...)</span><br></pre></td></tr></table></figure>
<ul>
<li>这两个内置函数被放在 GNU Make 官方文档 <a href="https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html">8.3 Functions for File Names</a> 章节的头两个，可见它们的使用之多。这一章节的函数都是专门用来<strong>拆分</strong>文件路径的。</li>
<li><code>$(dir names...)</code> 只取出后面文件路径(或文件路径列表)的目录部分, 相当于 shell 里的 <code>dirname</code></li>
<li><code>$(notdir names...)</code> 只取出后面文件路径(或文件路径列表)的文件名部分, 相当于 shell 里的 <code>basename</code></li>
<li>举个例子 Linux kernel <code>scripts/Kbuild.include</code> 中 <code>dot-target</code> 定义的例子:
<ul>
<li>`dot-target = $(dir <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">@</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">@).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">@</span><span class="mclose">)</span><span class="mord">.</span></span></span></span>(notdir $@)</li>
<li>这个 dot-target 其实就是把 <code>foo/bar.o</code> 变成 <code>foo/.bar.o</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="filter-filter-out"><a class="markdownIt-Anchor" href="#filter-filter-out"></a> filter, filter-out</h2>
<ul>
<li>原型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(filter pattern...,text)</span><br><span class="line">$(filter-out pattern...,text)</span><br></pre></td></tr></table></figure>
<ul>
<li>filter 函数返回 <code>text</code> 中所有<strong>匹配</strong> <code>pattern...</code> 的单词</li>
<li><code>pattern...</code> 表示可以提供多个用<strong>空白分隔</strong>的 pattern</li>
<li>filter-out 是返回那些<strong>不匹配</strong>的，即它的结果与 filter 正好相反</li>
</ul>
</li>
</ul>
<h2 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> foreach</h2>
<ul>
<li>原型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(foreach var, list, text)</span><br></pre></td></tr></table></figure>
<ul>
<li>expansion 时机：<code>var</code>, <code>list</code> 在一开始就展开，而 <code>text</code> 是在后面才展开</li>
<li><code>list</code> 是一个空白分隔的字符串</li>
<li><code>text</code> 的多次展开也被<strong>空白</strong>连接成一整个长字符串</li>
</ul>
</li>
</ul>
<h2 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h2>
<ul>
<li>原型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(if condition, then-part[, else-part])</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <em>condition</em> 展开后是 <strong>非空字串</strong>non-empty string, 则为真，如果是<strong>空字串</strong>，则执行 <code>else-part</code>(如果有的话)</li>
<li><em>then-part</em> 和 <em>else-part</em> 永远只能有一个被求值 (evaluated)</li>
<li>if 函数同样有返回值，条件真时，返回 <em>then-part</em> 的求值结果; 条件假时，返回 <em>else-part</em> 的求值结果, 如果没有 <em>else-part</em>, 返回空字串</li>
</ul>
</li>
</ul>
<h2 id="or-and"><a class="markdownIt-Anchor" href="#or-and"></a> or, and</h2>
<ul>
<li>原型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(or condition1[,condition2[,condition3...]]）</span><br><span class="line">$(and condition1[,condition2[,condition3...]]）</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>短路或(short-circuiting OR)</strong>(不是骂人🐶), 即一个挨一个展开 <em>condition</em>, 只要遇到一个展开为<strong>非空字串</strong>，就停止，这个函数返回的就是展开的那个字串，如果所有 <em>condition</em> 展开都是空，则返回空字串</li>
<li><strong>短路与(short-circuiting AND)</strong>, 即一个挨一个展开 <em>condition</em>, 只要遇到一个展开为<strong>空字串</strong>，就停止，这个函数返回的就是空字串，如果所有 <em>condition</em> 展开都是非空字串，返回<strong>最后一个字串</strong></li>
<li><em>condition</em> 可以有 1 到 n 个</li>
</ul>
</li>
</ul>
<h2 id="origin"><a class="markdownIt-Anchor" href="#origin"></a> origin</h2>
<ul>
<li>原型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(origin variable)</span><br></pre></td></tr></table></figure>
<ul>
<li><em>variable</em> 不需要加 <code>$</code> 符号</li>
<li>它的功能类似 shell 里的 <code>which</code> 或 <code>type</code> (告诉你一个命令是不是 shell 内置命令)</li>
<li>它的返回值有以下这些(都是字串)
<ul>
<li>undefined</li>
<li>default</li>
<li>environment</li>
<li>environment override</li>
<li>file</li>
<li>command line</li>
<li>override</li>
<li>automatic</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用户自定义函数"><a class="markdownIt-Anchor" href="#用户自定义函数"></a> 用户自定义函数</h2>
<p>像其它语言一样，在 Makefile 里也可以自己定义函数， 例如</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">rust_exports = <span class="variable">$(NM)</span> -p --defined-only $(1) | awk &#x27;$$2~/(T|R|D|B)/ &amp;&amp; $$3!~/__(pfx|cfi|odr_asan)/ &#123; printf $(2),$$3 &#125;&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>Makefile 里定义函数，感觉还是在<strong>定义变量</strong></li>
<li>函数名是 <code>rust_exports</code></li>
<li>函数接受两个参数 <code>$(1)</code>, <code>$(2)</code></li>
<li>函数中可以使用 Makefile 变量，如 <code>$(NM)</code></li>
<li><a href="https://gist.github.com/lucmann/3a30f9cc06bb8773a77aa5ccc945c3e5">当函数中的参数时，必须使用 <code>=</code>，而不是 <code>:=</code>, 因为有参数时需要将<strong>参数延迟展开</strong></a></li>
</ul>
<p>如何调用它</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> rust_exports,<span class="variable">$&lt;</span>,&quot;EXPORT_SYMBOL_RUST_GPL(%s)</span>;\n<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用自定义函数使用 Make 内置函数 <code>$(call variable,param,param,...)</code></li>
<li>在这个例子里，第1个实参是 <code>$&lt;</code>, 第2个实参是一个字符串，实际上是 awk printf 函数接受的<strong>格式字符串(format string)</strong></li>
</ul>
<h3 id="函数-例2"><a class="markdownIt-Anchor" href="#函数-例2"></a> 函数 例2</h3>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">if_makefile_exists = <span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">if</span>-exist-cond)</span>,<span class="variable">$(cmd)</span>,@：)</span><br><span class="line">if-exist-cond = <span class="variable">$(<span class="built_in">wildcard</span> $(1)</span>/Makefile)</span><br><span class="line">cmd = make -C $(1) $(2)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>if_makefile_exists</code> 函数接受两个参数，
<ul>
<li>参数1：目录名</li>
<li>参数2：Target</li>
</ul>
</li>
<li>功能是如果<strong>参数1</strong>指定的目录下存在 Makefile, 则构建<strong>参数2</strong>指定的目标，否则什么都不做(<code>@:</code>)</li>
<li>调用方法：<code>$(call if_makefile_exists,images/dot,all)</code></li>
</ul>
<h1 id="make-用户手册"><a class="markdownIt-Anchor" href="#make-用户手册"></a> Make 用户手册</h1>
<ul>
<li><a href="https://www.gnu.org/software/make/manual/make.html">Make Manual</a></li>
</ul>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA on WSL2</title>
    <url>/utils/nvidia-docker/</url>
    <content><![CDATA[
<p>References:</p>
<ol>
<li><a href="https://developer.nvidia.com/blog/announcing-cuda-on-windows-subsystem-for-linux-2/">Announcing CUDA on Windows Subsystem for Linux 2</a></li>
</ol>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU</title>
    <url>/utils/qemu/</url>
    <content><![CDATA[<h1 id="qemu"><a class="markdownIt-Anchor" href="#qemu"></a> QEMU</h1>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">QEMU</th>
<th style="text-align:left">VirtualBox</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">开发者</td>
<td style="text-align:left">开源（QEMU 项目, 最初由 Fabrice Bellard 开发）</td>
<td style="text-align:left">Oracle（原 Sun Microsystems）</td>
</tr>
<tr>
<td style="text-align:left">开源/闭源</td>
<td style="text-align:left">完全开源（GPLv2）</td>
<td style="text-align:left">部分开源（扩展包闭源）</td>
</tr>
<tr>
<td style="text-align:left">支持架构</td>
<td style="text-align:left">x86, ARM, RISC-V, MIPS, LoongArch, SPARC等</td>
<td style="text-align:left">仅 x86_64</td>
</tr>
<tr>
<td style="text-align:left">是否支持纯软件模拟</td>
<td style="text-align:left">支持（TCG 模拟,也支持 KVM 加速）</td>
<td style="text-align:left">不支持（必须 Intel VT-x/AMD-V）</td>
</tr>
<tr>
<td style="text-align:left">适用场景</td>
<td style="text-align:left">嵌入式开发, 跨架构仿真</td>
<td style="text-align:left">桌面用户运行 Win/Linux</td>
</tr>
</tbody>
</table>
<span id="more"></span>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>Regular Expression</title>
    <url>/utils/regex/</url>
    <content><![CDATA[<h1 id="regular-expressions"><a class="markdownIt-Anchor" href="#regular-expressions"></a> Regular Expressions</h1>
<ul>
<li>
<p><a href="https://www.regular-expressions.info/posix.html#bre">POSIX Basic Regular Expression</a></p>
<ul>
<li>grep</li>
</ul>
</li>
<li>
<p><a href="https://www.regular-expressions.info/gnu.html#ere">POSIX Extended Regular Expression</a></p>
<ul>
<li>egrep</li>
<li>awk</li>
<li>emacs</li>
</ul>
</li>
</ul>
<h1 id="gnu-extensions"><a class="markdownIt-Anchor" href="#gnu-extensions"></a> GNU Extensions</h1>
<h2 id="shorthand-classes"><a class="markdownIt-Anchor" href="#shorthand-classes"></a> Shorthand Classes</h2>
<table>
<thead>
<tr>
<th style="text-align:left">shorthand</th>
<th style="text-align:left">equivalence</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left"><code>[[:alnum:]_]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left"><code>[^[:alnum:]_]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left"><code>[[:space:]]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left"><code>[^[:space:]]</code></td>
</tr>
</tbody>
</table>
<h2 id="word-boundaries"><a class="markdownIt-Anchor" href="#word-boundaries"></a> Word Boundaries</h2>
<table>
<thead>
<tr>
<th style="text-align:left">shorthand</th>
<th style="text-align:left">matches</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">position at a word boundary</td>
</tr>
<tr>
<td style="text-align:left"><code>\B</code></td>
<td style="text-align:left">position not at a word boundary</td>
</tr>
<tr>
<td style="text-align:left"><code>\&lt;</code></td>
<td style="text-align:left">position at the start of a word</td>
</tr>
<tr>
<td style="text-align:left"><code>\&gt;</code></td>
<td style="text-align:left">position at the end of a word</td>
</tr>
<tr>
<td style="text-align:left"><code>\`</code> (backtick)</td>
<td style="text-align:left">position at the start of subject string</td>
</tr>
<tr>
<td style="text-align:left"><code>\'</code> (single quote)</td>
<td style="text-align:left">position at the end of subject string</td>
</tr>
</tbody>
</table>
<h1 id="perl-compatiable-regular-expression-pcre"><a class="markdownIt-Anchor" href="#perl-compatiable-regular-expression-pcre"></a> Perl Compatiable Regular Expression (PCRE)</h1>
<h2 id="grep-multiline-mode"><a class="markdownIt-Anchor" href="#grep-multiline-mode"></a> <code>grep</code> multiline mode</h2>
<ul>
<li><code>-P</code>: 使用 Perl 正则表达式扩展</li>
<li><code>-z</code>: 让 grep 把输入的行看成是一个多个行的集合，一个整体</li>
<li><code>.*?</code>: 后面的 <code>?</code> 表示 <code>.*</code> 按 <strong>non-greedy</strong> 模式匹配，也就是尽可能少(短)的匹配</li>
<li><code>(?s)</code>: 让 <code>.</code> 匹配包括 <code>\n</code> 在内的任意字符，也就是所谓的 <strong>dot all</strong> flag.</li>
</ul>
<h2 id="rg-multiline-mode"><a class="markdownIt-Anchor" href="#rg-multiline-mode"></a> <code>rg</code> multiline mode</h2>
<ul>
<li>
<p><code>-U, --multiline</code> 使能多行匹配，允许正则表达式里包含 <code>\n</code> (普通模式下不允许)，但 <code>-U</code> 并不会改变 <code>.</code> 的语义，所以你仍然需要显式地给 <code>.</code> 指定 <code>(?s)</code> flag</p>
<ul>
<li><code>rg -U 'struct file_operations .*? = ?\&#123;(?s).*?\.mmap = (?s).*?\&#125;;' -tc drivers/gpu</code><br />
这个例子找出内核 GPU 驱动中所有重写了 <code>mmap</code> file operation 方法的c文件</li>
</ul>
</li>
</ul>
<h1 id="lookarounds-lookahead-lookbehind"><a class="markdownIt-Anchor" href="#lookarounds-lookahead-lookbehind"></a> Lookarounds: Lookahead, Lookbehind</h1>
<table>
<thead>
<tr>
<th style="text-align:left">语法</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(?=foo)</td>
<td style="text-align:left">正向先行断言 Positive Lookahead</td>
<td style="text-align:left">向前(右) 字符串里必须有 foo</td>
</tr>
<tr>
<td style="text-align:left">(?!foo)</td>
<td style="text-align:left">负向先行断言 Negative Lookahead</td>
<td style="text-align:left">向前(右) 字符串里不能有 foo</td>
</tr>
<tr>
<td style="text-align:left">(?&lt;=foo)</td>
<td style="text-align:left">正向后行断言 Positive Lookbehind</td>
<td style="text-align:left">向后(左) 字符串里必须有 foo</td>
</tr>
<tr>
<td style="text-align:left">(?&lt;!foo)</td>
<td style="text-align:left">负向后行断言 Negative Lookbehind</td>
<td style="text-align:left">向后(左) 字符串里不能有 foo</td>
</tr>
</tbody>
</table>
<ul>
<li>它们只是<strong>检查是否匹配，不作为最终匹配结果的一部分</strong>，即所谓&quot;断言&quot;</li>
<li>它们可以解决 Non greedy 匹配有时解决不了的问题</li>
<li><code>rg</code> (<a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>) 默认不支持 lookahead, lookbehind, 需要加 <code>-P</code> 或 <code>--pcre2</code> 选项</li>
</ul>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Sanitizers</title>
    <url>/utils/sanitizer/</url>
    <content><![CDATA[<p><img src="/images/sanitizer/shadowed-process-memory.png" alt="shadowed process memory" /></p>
<span id="more"></span>
<h1 id="sanitizer-简介"><a class="markdownIt-Anchor" href="#sanitizer-简介"></a> Sanitizer 简介</h1>
<p>Sanitizer 是一个动态 Bug 检测的工具，它可以检测的 Bug 有以下几类：</p>
<ul>
<li>内存越界</li>
<li>内存未初始化</li>
<li>内存泄漏</li>
<li>死锁</li>
<li>未定义行为 (UB)</li>
</ul>
<h1 id="内存-bug"><a class="markdownIt-Anchor" href="#内存-bug"></a> 内存 Bug</h1>
<p>Sanitizer 检测内存越界，未初始化，泄漏的原理是让编译器在程序真正使用的内存周围加上额外的内存 <strong>(Red Zone)</strong>， 并在这些 Red Zone 里填上不同的值。</p>
<p><img src="/images/sanitizer/redzones.png" alt="various red zones" /></p>
<p>要完成这些需要让程序链接一个叫 <strong><code>libasan.so</code></strong> 的运行时动态库，以及在编译和链接时指定 <strong><code>-fsanitize=address</code></strong>。</p>
<ul>
<li>AddressSanitizer (ASan <strong><code>-fsanitizer=address</code></strong>):
<ul>
<li>use-after-free</li>
<li>double-free</li>
<li>buffer (heap, stack, and global buffer) overflows</li>
<li>memory leak</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo *foo = <span class="keyword">new</span> Foo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/sanitizer/leak-sanitizer.png" alt="Leak Sanitizer" /></p>
<ul>
<li>MemorySanitizer (MSan <strong><code>-fsanitizer=memory -fsanitizer-memory-track-origins</code></strong>):
<ul>
<li>uninitialized memory reads</li>
</ul>
</li>
</ul>
<h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1>
<ul>
<li>ThreadSanitizer: data races, deadlocks</li>
</ul>
<h1 id="未定义行为"><a class="markdownIt-Anchor" href="#未定义行为"></a> 未定义行为</h1>
<ul>
<li>UndefinedBehaviorSanitizer (UBSan <strong><code>-fsanitizer=undefined</code></strong>)
<ul>
<li>signed integer overflow</li>
<li>use-of-null-pointer</li>
<li>division by zero</li>
</ul>
</li>
</ul>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="https://microblink.com/be-wise-sanitize-keeping-your-c-code-free-from-bugs/">Be wise, sanitize: Keeping your C++ code free from bugs</a></li>
<li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags">AddressSanitizer flags</a></li>
<li><a href="https://llvm.org/devmtg/2016-01/slides/ModernCplusplusDevelopment.pdf">An LLVM developer setup: Modern C++ development tools</a></li>
<li><a href="https://www.bilibili.com/video/BV1YT411Q7BU/?spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=b3ba1ad08e1b41cd7118d8dd88f0e670">Sanitizer 在字节跳动 C++ 中的实践</a></li>
</ul>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanced Shell</title>
    <url>/utils/shell/</url>
    <content><![CDATA[<h1 id="基础知识-变量和函数"><a class="markdownIt-Anchor" href="#基础知识-变量和函数"></a> 基础知识 - 变量和函数</h1>
<p>Linux 下的 Shell 有很多， sh, bash, csh, zsh 等, 这里主要记录一下 bash 和 zsh 的一些不同之处</p>
<h2 id="parameter-expansion"><a class="markdownIt-Anchor" href="#parameter-expansion"></a> Parameter Expansion</h2>
<h3 id="use-an-alternate-value"><a class="markdownIt-Anchor" href="#use-an-alternate-value"></a> Use an alternate value</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;var:+WORD&#125;</span></span><br><span class="line"><span class="variable">$&#123;var+WORD&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>var</code> 没有设置或为空，则这个变量展开为 Nothing (注意：不是空 empty, 是 nothing), 如果被设置了（不包括被设置成空），它展开为 <code>+</code> 后面的 WORD.</p>
<p>如果冒号被省略，则 <code>var</code> 即使被设置为空，它也展开为 <code>+</code> 后面的 WORD</p>
<h3 id="indirect"><a class="markdownIt-Anchor" href="#indirect"></a> Indirect</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;!var&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>var</code> 的值是 <code>MESA_DEBUG</code>, 那么这个形式展开后是变量 <code>MESA_DEBUG</code> 的值，例如 <code>export MESA_DEBUG=1</code>, <code>var=MESA_DEBUG</code>, 则最后的展开结果是 <code>1</code></p>
<h3 id="quoted"><a class="markdownIt-Anchor" href="#quoted"></a> Quoted</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;var@Q&#125;</span></span><br></pre></td></tr></table></figure>
<p>带 <code>@Q</code> 指变量展开后的值被单引号引起来，例如 <code>export ABC=abc</code>, <code>echo &quot;ABC=$&#123;ABC@Q&#125;&quot;</code> 的结果是 <code>ABC='abc'</code></p>
<h2 id="反斜杠-backslash"><a class="markdownIt-Anchor" href="#反斜杠-backslash"></a> 反斜杠 backslash \</h2>
<p><code>\</code> 在 shell 中是用来转义字符的，就是说 <code>echo &quot;\\\\&quot;</code> 显示的实际只有一个 <code>\</code>, 而且 <code>while read var</code> 时要注意加 <code>-r</code> 选项，读入原始字串</p>
<h1 id="经典命令"><a class="markdownIt-Anchor" href="#经典命令"></a> 经典命令</h1>
<h2 id="exec"><a class="markdownIt-Anchor" href="#exec"></a> exec</h2>
<p><code>exec</code> 命令有 2 个特点：</p>
<ul>
<li>直接覆盖当前进程，就是说进程 PID 不变，但执行的代码被更换了</li>
<li>原来的 shell 环境被销毁，这样当前的代码结束后，也就不会返回原 shell(没得返回)， 直接退出, 所以<strong>循环中慎用 exec</strong></li>
<li>可以把它想像成系统调用 <code>execve()</code></li>
</ul>
<p>下面是 linux kernel 安装 bzImage 的一段代码，其中就使用了 <code>exec</code>, 保证列出的 4 个安装脚本中，只执行第 1 个存在的，不会重复安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User/arch may have a custom install script</span></span><br><span class="line">for file in &quot;$&#123;HOME&#125;/bin/$&#123;INSTALLKERNEL&#125;&quot;		\</span><br><span class="line">	    &quot;/sbin/$&#123;INSTALLKERNEL&#125;&quot;			\</span><br><span class="line">	    &quot;$&#123;srctree&#125;/arch/$&#123;SRCARCH&#125;/install.sh&quot;	\</span><br><span class="line">	    &quot;$&#123;srctree&#125;/arch/$&#123;SRCARCH&#125;/boot/install.sh&quot;</span><br><span class="line">do</span><br><span class="line">	if [ ! -x &quot;$&#123;file&#125;&quot; ]; then</span><br><span class="line">		continue</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">installkernel(8) says the parameters are like follows:</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">	<span class="comment">#   installkernel version zImage System.map [directory]</span></span></span><br><span class="line">	exec &quot;$&#123;file&#125;&quot; &quot;$&#123;KERNELRELEASE&#125;&quot; &quot;$&#123;KBUILD_IMAGE&#125;&quot; System.map &quot;$&#123;INSTALL_PATH&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="timeout"><a class="markdownIt-Anchor" href="#timeout"></a> timeout</h2>
<p><code>timeout</code> 命令用来给一个 <em>COMMAND</em> 设定一个 <em>DURATION</em>， 这在自动化中很有用，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in `fd --type x`; do timeout -k 0.1 10 ./$i; done</span><br></pre></td></tr></table></figure>
<p>假如当前在 <a href="https://github.com/SaschaWillems/Vulkan">VulkanExamples</a> 的 bin 目录下，上面的命令表示让每个 demo 执行 <strong>10s</strong> 后结束(<code>timeout</code> 给它发 <code>TERM</code> 信号), 如果发了 <code>TERM</code> 信号后，又经过 <strong>0.1s (<code>-k 0.1</code>)</strong>，这个 demo 还未能退出，就再发 <code>KILL</code> 信号，强制结束它</p>
<h2 id="tree"><a class="markdownIt-Anchor" href="#tree"></a> tree</h2>
<p><code>tree</code> 像一个简单的文件浏览器，但它并不是 shell 内置的命令，<code>apt install tree</code> 或 <code>pacman -S tree</code> 都可以安装。有时一个目录中包含太多的文件，tree 的默认输出就不太好浏览，这时可以只打印目录，并限制搜索深度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree -L 2 -d</span><br></pre></td></tr></table></figure>
<h2 id="crontab"><a class="markdownIt-Anchor" href="#crontab"></a> crontab</h2>
<p><code>crontab -e</code> (添加定时任务)， 不光可以添加周期性的定时任务，也可以添加开机时一次性任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@reboot /home/luc/mystart.sh</span><br></pre></td></tr></table></figure>
<p>crontab 是每用户的， 就是说当前用户设定的任务，只有当前用户的权限，所以如果有些情况下任务执行需要 root 权限，就需要切换到 root 用户后 <code>crontab -e</code></p>
<h1 id="文本处理-awk-sed-greprg-三剑客"><a class="markdownIt-Anchor" href="#文本处理-awk-sed-greprg-三剑客"></a> 文本处理 - awk, sed, grep(rg) 三剑客</h1>
<p>Linux 下的文本处理三剑客: grep, sed, awk, 除了它们其实还有一些小巧的命令，如 <code>tr</code>, <code>cut</code> 也可以帮助我们快速处理和格式化文本。<br />
下面以一个例子为例。</p>
<h2 id="awk"><a class="markdownIt-Anchor" href="#awk"></a> awk</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;program&#x27; inputfile1 inputfile2 ...</span><br></pre></td></tr></table></figure>
<p>awk 的调用形式就是上面这样的，而其中的 <em>program</em> 由若干条 rules 组成，而一条 <em>rule</em> 由一个 <em>pattern</em> 和一个 <em>action</em> 组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern &#123; action &#125;</span><br><span class="line">pattern &#123; action &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li><code>awk '&#123;$1=$1&#125;;1'</code>
<ul>
<li>将一个字段前后的空白(空格和 Tab) 全部清除</li>
</ul>
</li>
</ul>
<h2 id="sed"><a class="markdownIt-Anchor" href="#sed"></a> sed</h2>
<p>sed 和 awk 一样，都是按行处理文本的。</p>
<ul>
<li><code>sed -n '2 &#123;s/^/#/; p; q&#125;' file</code>
<ul>
<li>sed 默认会将每一行都打印出来， <code>-n</code> 取消这一行为</li>
<li>sed 可以在操作的前面指定位置和范围， 如
<ul>
<li>行号</li>
<li>正则表达式 <code>/^foo/</code></li>
<li>两个正则表达式锁定范围 <code>/^foo/, /bar$/</code></li>
</ul>
</li>
<li>如果 <code>-n</code> 后，完全都不打印了，但如果又想将处理后的行打印出来，使用 <code>p</code> 命令</li>
<li><code>q</code> 命令的作用是<strong>立即退出</strong>，sed 的默认行为是对第2行处理完后，虽然后面的行都不需要处理，但 sed 仍然会继续将后面的每行往<strong>模式空间</strong>加载。</li>
</ul>
</li>
</ul>
<h2 id="grepripgrep"><a class="markdownIt-Anchor" href="#grepripgrep"></a> grep/ripgrep</h2>
<ul>
<li>
<p><strong>在 Linux 内核源码目录下，搜索 <code>drivers/gpu/drm</code> 下所有的 <code>DRIVER_NAME</code> 定义，并排序后格式化输出</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rg <span class="string">&#x27;#define DRIVER_NAME&#x27;</span> drivers/gpu/drm --no-heading \</span><br><span class="line">	| <span class="built_in">tr</span> -s <span class="string">&#x27;\t&#x27;</span> | <span class="built_in">tr</span> <span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27; &#x27;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span> \</span><br><span class="line">	| awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;printf(&quot;%-52s%-40s\n&quot;,$1,$2)&#125;&#x27;</span> \</span><br><span class="line">	| <span class="built_in">sort</span> -k4</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rg</code> (<a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>) 比 grep 更快，更强大</li>
<li><code>tr</code> 在不带任何选项时，默认执行替换，例子是中将 tab 替换成 空格, <code>-s</code> 表示 <code>squeeze-repeats</code>, 就是去掉重复的字符，例如多个空格只保留一个</li>
<li><code>awk</code> 天生支持 C-Style printf</li>
</ul>
</li>
<li>
<p><code>rg '\[package\]' -ttoml --glob '!Cargo.lock'</code></p>
<ul>
<li>在一个 rust 项目顶层目录，只搜索 .toml 文件中的 <code>[package]</code>, 而忽略所有 Cargo.lock 文件</li>
</ul>
</li>
</ul>
<h2 id="引号"><a class="markdownIt-Anchor" href="#引号"></a> 引号</h2>
<p>当混合使用 awk 和 sed 时，比较便利地处理引号的方法是定义 awk 变量 <code>-v Q=&quot;'&quot;</code></p>
<ul>
<li>awk 的 <code>printf()</code> 函数第一个参数必须使用双引号 <code>printf(&quot;%s: %s%d%s\n&quot;, $1, Q, $2, Q)</code>
<ul>
<li>awk 中的用户自定义变量和内置变量，使用时都不需要加 <code>$</code>， 如 <code>NR</code>, <code>NF</code></li>
</ul>
</li>
<li>awk 和 sed 的命令字串必须用引号括起来，当用 awk 生成 sed 命令时，将单引号定义为 awk 变量尤其方便，可读性也强</li>
</ul>
<h2 id="行范围-line-range"><a class="markdownIt-Anchor" href="#行范围-line-range"></a> 行范围 (Line range)</h2>
<p>sed, awk 都支持行范围，如 <code>sed -n '3,5p'</code>, <code>awk 'NR &gt;= 3 &amp;&amp; NR &lt;= 5'</code>，它们的效果是一样的，都是只打印给定文件的 3 到 5 行， 除了<strong>行号</strong>， sed, awk 还支持通过<strong>正则匹配</strong>来指定行位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;/foo/,$p&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$</code> 表示最后一行</li>
<li><code>p</code> 是 sed <code>print</code> 命令的缩写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;/foo/ &#123;f=1&#125; f&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>awk 实现行范围的方式与 sed 稍有不同，它在满足匹配 <code>foo</code> 这个条件时，将<strong>布尔</strong>变量 <code>f</code> 设置为 1，相当于从这一行开始，开启 <code>print</code> 打印这个默认操作</li>
<li>awk 的一条 rule 里，可以省略 <em>pattern</em>, 或者省略 <em>action</em>, 但<strong>不能同时两个都省略</strong>；如果省略 <em>pattern</em>, 则对每个输入行都执行 <em>action</em>, 如果省略 <em>action</em>, 则对每个匹配行执行 <code>print</code> <em>action</em>。这个例子里面， awk 的 <em>program</em> 包括两条 <em>rules</em>
<ul>
<li><code>/foo/ &#123;f=1&#125;</code> 这条 <em>rule</em> 什么都没有省略</li>
<li><code>f</code> 这条 <em>rule</em> 省略了 <em>action</em>, 所以对每个输入行执行 <code>print</code> <em>action</em></li>
</ul>
</li>
</ul>
<p>它们两个的效果也是一样的，都是从第一个匹配 <code>foo</code> 的行开始，一直打印到文件结束。</p>
<h2 id="正则匹配-regex-match"><a class="markdownIt-Anchor" href="#正则匹配-regex-match"></a> 正则匹配 (Regex match)</h2>
<p>awk 中一个 <em>rule</em> 中的 <em>pattern</em> 部分可以只是一条 <code>/</code> 括起来的正则表达式，默认这个正则表达式的<strong>匹配</strong>对象是 <code>$0</code>, 也就是<strong>整行</strong>， 如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;/foo/&#x27;</span><br></pre></td></tr></table></figure>
<p>它实际上是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;$0~/foo/ &#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>它意思是只要当前行里包含 <code>foo</code> 这个字串，就打印这一行。所以 awk 的正则 <em>pattern</em>, 准确来说是用来<strong>搜索</strong>的</p>
<p>默认情况下是 <code>$0~/foo/</code>, 那么不默认情况下，可以指定哪个 <code>field</code> 去“匹配”， 如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk &#x27;$1~/foo/ &amp;&amp; $3!~/bar/ &#123;print&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>它意思是当前这条记录，如果第1个字段包含 <code>foo</code> <strong>且</strong> 第3个字段<strong>不包含</strong> <code>bar</code>, 那么就打印整条记录</p>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>TeX/LaTex</title>
    <url>/utils/texlive/</url>
    <content><![CDATA[<h1 id="texlatex"><a class="markdownIt-Anchor" href="#texlatex"></a> TeX/LaTeX</h1>
<p>TeX 是高德纳(Donald Knuth)发明的编程式排版语言，而 LaTeX 是莱斯利·兰波特(Leslie Lamport)在 TeX 的基础上开发的 TeX 的扩展宏集。</p>
<h2 id="生成-pdf-的工具"><a class="markdownIt-Anchor" href="#生成-pdf-的工具"></a> 生成 PDF 的工具</h2>
<ul>
<li><a href="https://github.com/jgm/pandoc">pandoc</a> 标记语言转换领域的&quot;瑞士军刀&quot;
<ul>
<li>将 Markdown 生成 PDF</li>
</ul>
</li>
<li><a href="https://ftp.ntou.edu.tw/ctan/systems/texlive/Images/">TexLive</a> 开发最为活跃的 TeX 发行版之一
<ul>
<li>TexLive 是跨平台的，但一般在 Linux 下安装，MacOS 下是 MacTeX, Windows 下是 MiKTeX.</li>
</ul>
</li>
<li><a href="https://github.com/Wandmalfarbe/pandoc-latex-template">eisvogel</a> 简洁的 pandoc LaTex 模板
<ul>
<li>eisvogel 要求一个完整的 TexLive 的安装环境，但通常像 CentOS 这样的 Linux 发行版自带的 TexLive 并不完整。</li>
</ul>
</li>
</ul>
<h1 id="how-to-install-texliveiso"><a class="markdownIt-Anchor" href="#how-to-install-texliveiso"></a> How to Install <a href="https://www.tug.org/texlive/acquire-iso.html"><code>texlive.iso</code></a></h1>
<h2 id="quick-install"><a class="markdownIt-Anchor" href="#quick-install"></a> <a href="https://www.tug.org/texlive/quickinstall.html">Quick Install</a></h2>
<p>将 TexLive 的镜像下载并挂载后，通过顶层目录下的 <code>install-tl</code> 这个 Perl 脚本程序安装，整个安装过程要注意以下几点。</p>
<h2 id="mount-iso-image"><a class="markdownIt-Anchor" href="#mount-iso-image"></a> mount ISO image</h2>
<p>假设在 Linux 下，通过 root 用户或 <code>sudo</code> 挂载镜像文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mnt/iso</span><br><span class="line">mount /path/to/texlive.iso /mnt/iso -o loop</span><br></pre></td></tr></table></figure>
<p>因为 ISO 文件系统是只读文件系统，所以如果想在 <code>/mnt/iso</code> 写入时，还需要借助 Linux 的 <strong>OverlayFS</strong> 进行再次挂载，之后在目录 <code>/mnt/merged</code> 里就有一份可写版的镜像了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mnt/&#123;upper,work,merged&#125;</span><br><span class="line">mount -t overlay overlay -o lowerdir=/mnt/iso,upperdir=/mnt/upper,workdir=/mnt/work /mnt/merged</span><br></pre></td></tr></table></figure>
<h2 id="run-installer"><a class="markdownIt-Anchor" href="#run-installer"></a> run installer</h2>
<p>TexLive 的 installer 是一个 perl script, 提供 text mode 和 GUI mode 两种安装模式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">======================&gt; TeX Live installation procedure &lt;=====================</span><br><span class="line"></span><br><span class="line">======&gt;   Letters/digits in &lt;angle brackets&gt; indicate   &lt;=======</span><br><span class="line">======&gt;   menu items for actions or customizations      &lt;=======</span><br><span class="line">= help&gt;   https://tug.org/texlive/doc/install-tl.html   &lt;=======</span><br><span class="line"></span><br><span class="line"> Detected platform: GNU/Linux on x86_64</span><br><span class="line"></span><br><span class="line"> &lt;B&gt; set binary platforms: 1 out of 6</span><br><span class="line"></span><br><span class="line"> &lt;S&gt; set installation scheme: scheme-full</span><br><span class="line"></span><br><span class="line"> &lt;C&gt; set installation collections:</span><br><span class="line">     40 collections out of 41, disk space required: 7262 MB (free: 168365 MB)</span><br><span class="line"></span><br><span class="line"> &lt;D&gt; set directories:</span><br><span class="line">   TEXDIR (the main TeX directory):</span><br><span class="line">     !! default location: /usr/local/texlive/2022</span><br><span class="line">     !! is not writable or not allowed, please select a different one!</span><br><span class="line">   TEXMFLOCAL (directory for site-wide local files):</span><br><span class="line">     /usr/local/texlive/texmf-local</span><br><span class="line">   TEXMFSYSVAR (directory for variable and automatically generated data):</span><br><span class="line">     /usr/local/texlive/2022/texmf-var</span><br><span class="line">   TEXMFSYSCONFIG (directory for local config):</span><br><span class="line">     /usr/local/texlive/2022/texmf-config</span><br><span class="line">   TEXMFVAR (personal directory for variable and automatically generated data):</span><br><span class="line">     ~/.texlive2022/texmf-var</span><br><span class="line">   TEXMFCONFIG (personal directory for local config):</span><br><span class="line">     ~/.texlive2022/texmf-config</span><br><span class="line">   TEXMFHOME (directory for user-specific files):</span><br><span class="line">     ~/texmf</span><br><span class="line"></span><br><span class="line"> &lt;O&gt; options:</span><br><span class="line">   [ ] use letter size instead of A4 by default</span><br><span class="line">   [X] allow execution of restricted list of programs via \write18</span><br><span class="line">   [X] create all format files</span><br><span class="line">   [X] install macro/font doc tree</span><br><span class="line">   [X] install macro/font source tree</span><br><span class="line">   [ ] create symlinks to standard directories</span><br><span class="line">   [X] after install, set CTAN as source for package updates</span><br><span class="line"></span><br><span class="line"> &lt;V&gt; set up for portable installation</span><br><span class="line"></span><br><span class="line">Actions:</span><br><span class="line"> &lt;I&gt; start installation to hard disk</span><br><span class="line"> &lt;P&gt; save installation profile to &#x27;texlive.profile&#x27; and exit</span><br><span class="line"> &lt;Q&gt; quit</span><br><span class="line"></span><br><span class="line">Enter command:</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>D</code></strong>: 设置安装路径，相当于指定 <code>--prefix</code></li>
<li><strong><code>P</code></strong>: 保存安装的配置到文件 <code>texlive.profile</code>, 之后可以直接编辑这个文件，运行 <code>install-tl</code> 时通过 <code>--profile</code> 可以直接读取这个文件中的安装配置</li>
</ul>
<h2 id="create-symlinks-to-standard-directories"><a class="markdownIt-Anchor" href="#create-symlinks-to-standard-directories"></a> create symlinks to standard directories</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Options customization:</span><br><span class="line"></span><br><span class="line"> &lt;P&gt; use letter size instead of A4 by default: [ ]</span><br><span class="line"> &lt;E&gt; execution of restricted list of programs: [X]</span><br><span class="line"> &lt;F&gt; create all format files:                  [X]</span><br><span class="line"> &lt;D&gt; install font/macro doc tree:              [X]</span><br><span class="line"> &lt;S&gt; install font/macro source tree:           [X]</span><br><span class="line"> &lt;L&gt; create symlinks in standard directories:  [X]</span><br><span class="line">            binaries to: /usr/bin</span><br><span class="line">            manpages to: /usr/man</span><br><span class="line">                info to: /usr/info</span><br><span class="line"> &lt;Y&gt; after install, set CTAN as source for package updates:</span><br><span class="line">                                               [X]</span><br></pre></td></tr></table></figure>
<p>最好勾选此选项，避免使用 TexLive 时各种 <code>Not Found</code>, 原因是 TexLive 默认安装路径并不是标准 Linux 可执行程序的路径(如 <code>/usr/bin</code>), 而是 <code>/usr/local/texlive</code>, 如在 x86_64 安装 <code>texlive2022.iso</code>, 则可执行程序被安装在 <code>/usr/local/texlive/2022/bin/x86_64-linux</code>. 假如不想因为该路径没有在 <code>PATH</code> 里，最好就是在安装时直接在 <code>/usr/bin</code> 下创建相应符号链接。</p>
<h2 id="non-interactive-installation"><a class="markdownIt-Anchor" href="#non-interactive-installation"></a> Non-interactive Installation</h2>
<p>当你有一份 <code>texlive.profile</code> 时，就可以执行非交互式安装，<code>install-tl</code> 会直接按照 <code>texlive.profile</code> 文件里的配置安装，无需干预</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./install-tl --no-interaction --profile=texlive.profile</span><br></pre></td></tr></table></figure>
<h1 id="texlive-full"><a class="markdownIt-Anchor" href="#texlive-full"></a> texlive-full</h1>
<p>在使用 xelatex, pdflatex 等 latex 程序时，可以常常遇到类似</p>
<p><code>! LaTeX Error: File 'fontawesome.sty' not found</code></p>
<p>xxx.sty 这样的报错，一般是缺少某个 texlive 包，但 texlive 的包太多了，如果懒得一个一个安装，可以</p>
<p><code>sudo apt install texlive-full</code></p>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>update-alternatives</title>
    <url>/utils/update-alternatives/</url>
    <content><![CDATA[<h1 id="whats-the-problem"><a class="markdownIt-Anchor" href="#whats-the-problem"></a> What’s the problem</h1>
<p>有时在你的系统上可能已经安装了多个gcc版本(gcc-4.8, gcc-8, gcc-9)或Python版本(Python, Python 2.7, Python 3.8), 那么当你执行gcc或python命令时，到底用的是哪个gcc或python版本呢？而且如何方便地指定我们期望使用的版本呢？在大多数Linux发行版都有一个<strong>update-alternatives</strong>命令专门处理这种情况。</p>
<span id="more"></span>
<h1 id="how-to-solve-it"><a class="markdownIt-Anchor" href="#how-to-solve-it"></a> How to solve it</h1>
<p><code>update-alternatives</code>通过在<code>/etc/alternatives/</code>目录下创建一个符号链接文件，通过修改这个文件的指向达到轻松更换像gcc或Python这类系统软件的版本的目的。</p>
<h2 id="synopsis"><a class="markdownIt-Anchor" href="#synopsis"></a> Synopsis</h2>
<p>update-alternatives [option…] command</p>
<h2 id="commands"><a class="markdownIt-Anchor" href="#commands"></a> Commands</h2>
<p>–install <u>link</u> <u>name</u> <u>path</u> <u>priority</u></p>
<p>–set <u>name</u> <u>path</u></p>
<p>–remove <u>name</u> <u>path</u></p>
<p>–display <u>name</u></p>
<figure class="highlight shell"><figcaption><span>update-alternatives --display python</span></figcaption><table><tr><td class="code"><pre><span class="line">python - auto mode</span><br><span class="line">  link best version is /usr/bin/python3</span><br><span class="line">  link currently points to /usr/bin/python3</span><br><span class="line">  link python is /usr/bin/python</span><br><span class="line">/usr/bin/python3 - priority 5</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><figcaption><span>sudo update-alternatives --install</span><a href="/usr/bin/python">python /usr/bin/python3 3</a></figcaption><table><tr><td class="code"><pre><span class="line">update-alternatives: 使用 /usr/bin/python3 来在自动模式中提供 /usr/bin/python (python)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><figcaption><span>python -V</span></figcaption><table><tr><td class="code"><pre><span class="line">Python 3.12.2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Sogou IM on Ubuntu Jammy Jellyfish</title>
    <url>/utils/upgrade-ubuntu/</url>
    <content><![CDATA[<h1 id="reminiscence"><a class="markdownIt-Anchor" href="#reminiscence"></a> Reminiscence</h1>
<span id="more"></span>
<h1 id="display-drivers-for-nvidia-gt-520m"><a class="markdownIt-Anchor" href="#display-drivers-for-nvidia-gt-520m"></a> Display Drivers for NVIDIA GT 520M</h1>
<p><img src="/images/upgrade-ubuntu/before-install-driver.png" alt="Before NVIDIA Display Driver Installed" /></p>
<h2 id="what-will-be-installed-by-this-installer"><a class="markdownIt-Anchor" href="#what-will-be-installed-by-this-installer"></a> What Will Be Installed By This Installer?</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find /usr/lib/modules -name <span class="string">&#x27;*nvidia*.ko&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l --time-style=long-iso &#123;&#125; \;| awk <span class="string">&#x27;&#123;print $(NF-2), substr($NF, 43)&#125;&#x27;</span> | <span class="built_in">sort</span></span><br><span class="line"></span><br><span class="line">2022-07-12 drivers/i2c/busses/i2c-nvidia-gpu.ko</span><br><span class="line">2022-07-12 drivers/platform/x86/nvidia-wmi-ec-backlight.ko</span><br><span class="line">2022-07-12 drivers/usb/typec/altmodes/typec_nvidia.ko</span><br><span class="line">2022-07-12 drivers/video/fbdev/nvidia/nvidiafb.ko</span><br><span class="line">2022-10-13 drivers/i2c/busses/i2c-nvidia-gpu.ko</span><br><span class="line">2022-10-13 drivers/platform/x86/nvidia-wmi-ec-backlight.ko</span><br><span class="line">2022-10-13 drivers/usb/typec/altmodes/typec_nvidia.ko</span><br><span class="line">2022-10-13 drivers/video/fbdev/nvidia/nvidiafb.ko</span><br><span class="line">2022-11-11 drivers/video/nvidia-drm.ko</span><br><span class="line">2022-11-11 drivers/video/nvidia.ko</span><br><span class="line">2022-11-11 drivers/video/nvidia-modeset.ko</span><br><span class="line">2022-11-11 drivers/video/nvidia-uvm.ko</span><br></pre></td></tr></table></figure>
<p>此外，Installer 允许你备份原来的 Xorg.conf, 使用新的 nvidia.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find /etc -newercc /usr/lib/modules/5.15.0-52-generic/kernel/drivers/video/nvidia.ko</span><br><span class="line"></span><br><span class="line">/etc/X11/xorg.conf</span><br><span class="line">/etc/X11/xorg.conf.nvidia-xconfig-original</span><br></pre></td></tr></table></figure>
<h1 id="sogou-im"><a class="markdownIt-Anchor" href="#sogou-im"></a> Sogou IM</h1>
<p>Sogou 输入法真心做得不错，支持主流的国产 Linux 操作系统。今天将系统升级到 Ubuntu 22.04.1 LTS 后之前安装的 Sogoupinyin 突然不工作了。刚开始没想到是缺少 <code>libqt5qml5</code> 这个依赖，一顿重装 fcitx, sogoupinyin 操作后，还是不行，google 后才发现原来 sogoupinyin 安装后，可执行程序都在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/sogoupinyin/files/bin</span><br></pre></td></tr></table></figure>
<p>通过运行这个目录下的 <code>sogoupinyin-service</code> 这个程序后才发现它无法加载 libqt5qml5.</p>
<p>另外，<code>sogoupinyin-configtool</code> 也在上面这个目录，而且 sogoupinyin 也支持五笔</p>
<p><img src="/images/upgrade-ubuntu/sogoupinyin-configtool.png" alt="sogoupinyin config interface" /></p>
<h1 id="alacritty"><a class="markdownIt-Anchor" href="#alacritty"></a> Alacritty</h1>
<p><a href="https://github.com/alacritty/alacritty">Alacritty</a>是一个 GPU 加速的 Terminal Emulator.</p>
<p>升级系统后，感觉系统默认的 <code>gnome-terminal</code> 的标题栏很碍眼，所以想换一个新的 Terminal Emulator 试试，就选择了之前在学习 Rust 时听说过的 Alacritty, 但目前 Jammy Jellyfish 的官方 PPA 里并没有它的安装包。下面这个 PPA 安装过程很丝滑, 而且它自动将安装好的 <code>/usr/bin/alacritty</code> 设置为默认的 <code>x-terminal-emulator</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:aslatter/ppa</span><br></pre></td></tr></table></figure>
<p>安装后，<code>Ctrl-Alt-T</code>，Good Looking</p>
<p><img src="/images/upgrade-ubuntu/alacritty-first-sight.png" alt="Alacritty" /></p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>virtio</title>
    <url>/utils/virtio/</url>
    <content><![CDATA[<h1 id="virtio-半虚拟化设备标准"><a class="markdownIt-Anchor" href="#virtio-半虚拟化设备标准"></a> virtio - 半虚拟化设备标准</h1>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>全虚拟化</strong>（Emulated）</th>
<th><strong>Virtio</strong>（半虚拟化）</th>
<th><strong>SR-IOV</strong>（直通）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>性能</strong></td>
<td>❌ 低（模拟开销大）</td>
<td>✅ 高</td>
<td>✅✅ 超高（硬件直通）</td>
</tr>
<tr>
<td><strong>驱动支持</strong></td>
<td>无需额外驱动（但慢）</td>
<td>需要<strong>Virtio 驱动</strong></td>
<td>需要<strong>物理设备驱动</strong></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适用于无 Virtio 支持的旧 OS</td>
<td>普遍适用于 VM</td>
<td>适用于高性能网络存储</td>
</tr>
<tr>
<td><strong>硬件需求</strong></td>
<td>无特殊需求</td>
<td>无特殊需求</td>
<td>需要<strong>硬件支持</strong></td>
</tr>
</tbody>
</table>
<span id="more"></span>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 速查手册</title>
    <url>/utils/vim/</url>
    <content><![CDATA[<h1 id="visual-block-selection"><a class="markdownIt-Anchor" href="#visual-block-selection"></a> Visual Block Selection</h1>
<ul>
<li>
<p>选择 <code>&#123;&#125;</code>(curly braces) 之间的行(包括 <code>&#123;&#125;</code>)</p>
<ul>
<li><code>v%</code></li>
</ul>
</li>
<li>
<p>选择 <code>&#123;&#125;</code>(curly braces) 之间的行(不包括 <code>&#123;&#125;</code>)</p>
<ul>
<li><code>vi&#123;</code></li>
</ul>
</li>
</ul>
<p>注意：光标必须放在 <code>&#123;</code> 或者 <code>&#125;</code></p>
<h1 id="copy-paste"><a class="markdownIt-Anchor" href="#copy-paste"></a> Copy &amp; Paste</h1>
<h2 id="copy-to-clipboard"><a class="markdownIt-Anchor" href="#copy-to-clipboard"></a> Copy to clipboard</h2>
<ul>
<li>Normal 模式
<ul>
<li><code>&quot;+y</code></li>
</ul>
</li>
</ul>
<h2 id="paste-from-clipboard"><a class="markdownIt-Anchor" href="#paste-from-clipboard"></a> Paste from clipboard</h2>
<p>X11 window system 有 3 个 selections:</p>
<ul>
<li>PRIMARY 表示当前的可见 selection</li>
<li>SECONDARY</li>
<li>CLIPBOARD 通常所说的剪贴板，用来完成剪贴，复制和粘贴操作</li>
</ul>
<p>Vim 有两个专门的寄存器分别与 PRIMARY selection 和 CLIPBOARD selection 对应</p>
<ul>
<li><code>&quot;*</code> (quotestar) PRIMARY</li>
<li><code>&quot;+</code> (quoteplus) CLIPBOARD</li>
</ul>
<p>如果要在 Vim 内部剪贴，复制/粘贴就使用 <strong>quotestar</strong>, 如果要将内容剪贴，复制/粘贴到系统剪贴板，就使用 <strong>quoteplus</strong></p>
<p>举个例子，在 WSL Ubuntu 里如果想粘贴 Windows 剪贴板里的内容到 vim (最好是 neovim, 因为 vim 可能未使能 clipboard)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello, world!&quot; | clip.exe</span><br></pre></td></tr></table></figure>
<ul>
<li>Normal 模式
<ul>
<li><code>&quot;+p</code></li>
</ul>
</li>
</ul>
<p>如果想粘贴 Ubuntu 剪贴板里的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello, world!&quot; | xclip</span><br></pre></td></tr></table></figure>
<ul>
<li>Normal 模式
<ul>
<li><code>&quot;*p</code></li>
</ul>
</li>
</ul>
<h2 id="copy-from-above-or-below"><a class="markdownIt-Anchor" href="#copy-from-above-or-below"></a> Copy from above or below</h2>
<p>在 Insert 模式下</p>
<ul>
<li><code>&lt;ctrl-y&gt;</code> copies the character from the line above</li>
<li><code>&lt;ctrl-e&gt;</code> copies the character from the line below (本行就是这样输入的)</li>
</ul>
<h1 id="search-replace"><a class="markdownIt-Anchor" href="#search-replace"></a> Search &amp; Replace</h1>
<h2 id="删除多行-c-style-注释"><a class="markdownIt-Anchor" href="#删除多行-c-style-注释"></a> 删除多行 C-style 注释</h2>
<ul>
<li>
<p><code>s;/\*\_.\&#123;-&#125;\*/;;</code></p>
<ul>
<li>
<p><code>;</code> 因为要匹配 <code>/</code>, 为了省去转义 <code>/</code> 的麻烦，将 search 命令的分隔符由 <code>/</code> 改为 <code>;</code></p>
</li>
<li>
<p><code>/\*</code> 匹配开始的 <code>/*</code></p>
</li>
<li>
<p><code>\_.</code> 匹配任意字符，包括 <code>\n</code>, 所以常用在多行匹配</p>
</li>
<li>
<p><code>\&#123;-&#125;</code> 指非贪婪 (non-greedy) 匹配，即匹配最短的字串，默认是贪婪匹配，匹配最长的字串</p>
</li>
<li>
<p><code>\*/</code> 匹配结尾的 <code>*/</code></p>
</li>
<li>
<p><code>;;</code> 指使用空替换匹配结果，即删除</p>
</li>
<li>
<p>以下是 vim 中在单行中使用的通配符 (wildcard), 这些通配符一般不能匹配换行 <code>\n</code></p>
<ul>
<li><code>.</code> 匹配除了 <code>\n</code> 的任意字符</li>
<li><code>^</code> 行首，即锚点 (anchor)</li>
<li><code>$</code> 行尾，即锚点</li>
<li><code>\s</code> 匹配 space, tab, 但不匹配 <code>\n</code></li>
</ul>
</li>
<li>
<p>以上通配符加上 <code>\_</code> 后可以在多行匹配中使用，即也可以匹配 <code>\n</code></p>
<ul>
<li><code>\_.</code> 匹配任意字符，包括 <code>\n</code></li>
<li><code>\_^</code> 多行中第一行行首</li>
<li><code>\_$</code> 多行中最后一行行尾</li>
<li><code>\_s</code> 匹配 space, tab 和 <code>\n</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="删除空白行"><a class="markdownIt-Anchor" href="#删除空白行"></a> 删除空白行</h2>
<ul>
<li>
<p><code>g/^\s*$/d</code></p>
<ul>
<li><code>g</code> 指所有行搜索，而不是默认的光标所在行</li>
<li><code>^\s*$</code> 匹配行首到行尾之间任意个空白字符，即空白行</li>
<li><code>d</code> 删除命令 (delete)</li>
</ul>
</li>
</ul>
<h2 id="搜索不匹配某模式的行即反向搜索"><a class="markdownIt-Anchor" href="#搜索不匹配某模式的行即反向搜索"></a> 搜索不匹配某模式的行，即反向搜索</h2>
<ul>
<li>
<p><code>/^\(\(^# .*$\)\@!.\)*$</code></p>
<ul>
<li><code>/</code> 查找命令 (search) 的提示符</li>
<li><code>^\(\(The_Regex\)\@!.\)*$</code> 反向查找的命令固定模式，本例中 <code>The_Regex</code> 是 <code>^# .*$</code> 即以 <code># </code> 开头的行，所以整个表达式匹配的就是不以 <code># </code> 开头的所有行</li>
</ul>
</li>
<li>
<p><code>:v/^# .*$/p</code></p>
<ul>
<li>与上面的反向查找命令功能相同, 但会将匹配结果显示在 Visual 模式下</li>
</ul>
</li>
</ul>
<h2 id="大小写转换"><a class="markdownIt-Anchor" href="#大小写转换"></a> 大小写转换</h2>
<ul>
<li>
<p><code>s/\(^# .*$\)/\L\1/</code></p>
<ul>
<li><code>\(The_Regex\)</code> 为了<strong>向前索引</strong>，即后面 <code>\1</code> 所指的部分，本例中 <code>The_Regex</code> 是 <code>^# .*$</code>, 意思同上</li>
<li><code>\L\1</code> <code>\L</code> 指 <strong>L</strong>owercase, 即将 <code>\1</code> 匹配的结果中的所有字母都换成小写</li>
</ul>
</li>
<li>
<p><code>s/\(^# .*$\)/\U\1/</code></p>
<ul>
<li>与上面的表达式功能相反，即将 <code>\1</code> 匹配的结果中的所有字母都换成大写 (<strong>U</strong>ppercase)</li>
</ul>
</li>
</ul>
<h2 id="expression-register"><a class="markdownIt-Anchor" href="#expression-register"></a> expression register</h2>
<p>假如你在 markdown 文件里编辑一个 Table, table 的第1列是 <code>find</code> 的输出：一个很长的文件列表，且文件名长短不一(假如最长的文件名是 100 个字符)，你如何在 100 列插入 vertical bar (|)?</p>
<ul>
<li>
<p><code>N,Ms/.*/\=printf('%-101s|', submatch(0))/</code></p>
<ul>
<li><code>N,M</code> 指定替换的范围</li>
<li><code>\=</code> 表示使用 expression register, 这里相当于把 <code>printf()</code> 函数的输出导入到这里</li>
</ul>
</li>
</ul>
<h1 id="tohtml"><a class="markdownIt-Anchor" href="#tohtml"></a> TOhtml</h1>
<p><strong>vim</strong> 有一个内置的扩展 <strong>TOhtml</strong>, 可以将 vim 的 buffer 自动转成 html 文件，这个功能对于 <strong>vimdiff</strong> 时尤其有用。</p>
<ol>
<li><code>:[range]TOhtml</code> <em>range</em> 没有时默认是整个 buffer (vimdiff 时包括左右两个 window 哦)</li>
<li><code>:wqa</code> 生成的 html 默认保存为 <a href="https://pastebin.com/nEtsC1Ce">Diff.html</a></li>
<li>可以将生成的 html 内容直接粘贴到 <a href="https://jsbin.com/cikulin/edit?html,output">jsbin.com</a>, 然后就可以分享给他人</li>
</ol>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Subsystem for Linux</title>
    <url>/utils/wsl/</url>
    <content><![CDATA[<h1 id="wsl"><a class="markdownIt-Anchor" href="#wsl"></a> WSL</h1>
<p><a href="https://zh.wikipedia.org/zh-cn/%E9%80%82%E7%94%A8%E4%BA%8ELinux%E7%9A%84Windows%E5%AD%90%E7%B3%BB%E7%BB%9F">WSL (Windows Subsystem for Linux)</a>是一个能够在 Windows 系统(Windows 10及以上版本)上原生运行 Linux 可执行文件的兼容层。目前有两个版本: WSL, WSL2</p>
<span id="more"></span>
<p>查看 Windows 系统上的 WSL 版本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br></pre></td></tr></table></figure>
<h1 id="wslg"><a class="markdownIt-Anchor" href="#wslg"></a> WSLg</h1>
<p>Microsoft在<code>Build 21364.co_release</code>版本内发布了<a href="https://github.com/microsoft/wslg">WSLg</a>功能，该功能允许在<strong>WSL</strong>里运行<strong>X11</strong>和<strong>Wayland</strong>的客户端程序(GUI Application).</p>
<p><img src="/images/wsl/xeyes.gif" alt="xeyes on WSL2" /></p>
<p>如果你已经加入<a href="https://insider.windows.com/zh-cn/">Windows Insider Program</a>计划并且也正在使用<strong>WSL2</strong>, 那么只需要如下操作即可激活<strong>WSLg</strong>功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Windows\system32&gt; wsl --update</span><br><span class="line">正在检查更新...</span><br><span class="line">正在下载更新...</span><br><span class="line">正在安装更新...</span><br><span class="line">此更改将在 WSL 下次完全重启时生效。若要强制重启，请运行“wsl --shutdown”。</span><br><span class="line">内核版本： 5.10.60.1</span><br></pre></td></tr></table></figure>
<p>升级 WSL2 后，在 <code>/mnt</code> 目录下会比原来多出一个 <code>wslg</code> 的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ cd /mnt/</span><br><span class="line">c/     wsl/   wslg/</span><br></pre></td></tr></table></figure>
<h2 id="nautilus"><a class="markdownIt-Anchor" href="#nautilus"></a> nautilus</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install nautilus -y</span><br></pre></td></tr></table></figure>
<p><img src="/images/wsl/wslg-nautilus.png" alt="WSLg nautilus" /></p>
<h2 id="glmark2"><a class="markdownIt-Anchor" href="#glmark2"></a> glmark2</h2>
<p><img src="/images/wsl/wslg-glmark2.png" alt="WSLg glmark2" /></p>
<h1 id="wsl-如何支持-nvidia"><a class="markdownIt-Anchor" href="#wsl-如何支持-nvidia"></a> WSL 如何支持 Nvidia</h1>
<p>在 <code>/usr/lib/wsl/lib</code> 下默认安装了这些 shared libraries (usermode driver). 而且搭配了自动生成的 <code>/etc/ld.so.conf.d/ld.wsl.conf</code> 文件，能够让动态库加载器正确找到 nvidia 相关的库。</p>
<ul>
<li><a href="http://libcuda.so">libcuda.so</a></li>
<li>libcuda.so.1</li>
<li>libcuda.so.1.1</li>
<li><a href="http://libd3d12.so">libd3d12.so</a></li>
<li><a href="http://libd3d12core.so">libd3d12core.so</a></li>
<li><a href="http://libdxcore.so">libdxcore.so</a></li>
<li><a href="http://libnvcuvid.so">libnvcuvid.so</a></li>
<li>libnvcuvid.so.1</li>
<li><a href="http://libnvdxdlkernels.so">libnvdxdlkernels.so</a></li>
<li><a href="http://libnvidia-encode.so">libnvidia-encode.so</a></li>
<li>libnvidia-encode.so.1</li>
<li>libnvidia-ml.so.1</li>
<li><a href="http://libnvidia-opticalflow.so">libnvidia-opticalflow.so</a></li>
<li>libnvidia-opticalflow.so.1</li>
<li><a href="http://libnvwgf2umx.so">libnvwgf2umx.so</a></li>
<li>nvidia-smi</li>
</ul>
<h1 id="关于-wsl2-需要知道的几件事"><a class="markdownIt-Anchor" href="#关于-wsl2-需要知道的几件事"></a> 关于 WSL2 需要知道的几件事</h1>
<ul>
<li>WSL2 所有的 Distros 使用同一个内核，你可以在同一个 WSL2 安装 Ubuntu, 安装 Debian, 安装 Kali, 但不管安装多少个 Distros, 它们都用同一个 Linux 内核</li>
<li>WSL2 中所有内核模块都是直接被编译进内核的</li>
<li>WSL2 中没有内核线程，或者说你看不到它们</li>
</ul>
]]></content>
      <categories>
        <category>utilities</category>
      </categories>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_explicit_uniform_location</title>
    <url>/gfx/ARB/ARB_explicit_uniform_location/</url>
    <content><![CDATA[<h1 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_explicit_uniform_location.txt">Overview</a></h1>
<p>Numbers <strong>ARB Extension #128</strong></p>
<span id="more"></span>
<p>Requires <strong>OpenGL 3.3 or <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_explicit_attrib_location.txt">ARB_explicit_attrib_location</a></strong></p>
<p>Interacts <strong>ARB_shader_subroutine</strong></p>
<p>Since <strong>OpenGL 4.3 Core Profile Specification</strong></p>
<p>这个扩展相关的话题是<strong>Uniform Variable</strong>。它给应用程序提供一个可以预先分配默认uniform块中的uniform变量的uniform location的方法，也包括subroutine中的uniform变量。这样应用程序就可以不通过调用类似下面的命令去查询uniform location而直接修改uniform变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetUniformLocation</span><br><span class="line">GetSubroutineUniformLocation</span><br><span class="line">GetSubroutineIndex</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>GL_ARB_geometry_shader4</title>
    <url>/gfx/ARB/ARB_geometry_shader4/</url>
    <content><![CDATA[<h1 id="geometry-shader-input-layout-qualifiers"><a class="markdownIt-Anchor" href="#geometry-shader-input-layout-qualifiers"></a> Geometry Shader Input Layout Qualifiers</h1>
<p>Geometry shader只能在接口限定符(interface qualifier)<strong>in</strong>前加Input Layout Qualifiers, 不能在输入块(input block), 块成员(block member), 或变量声明(variable declaration)前加Input Layout Qualifiers。</p>
<p>这些Input Layout Qualifiers有</p>
<span id="more"></span>
<ul>
<li><strong>points</strong></li>
<li><strong>lines</strong></li>
<li><strong>lines_adjacency</strong></li>
<li><strong>triangles</strong></li>
<li><strong>triangles_adjacency</strong></li>
</ul>
<p><a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_gpu_shader5.txt">GL_ARB_gpu_shader5</a>(4.0)增加了对instanced geometry shader的支持，这个扩展引入了一个新的Input Layout Qualifier</p>
<ul>
<li><strong>invocation</strong> = <em>num_instances</em></li>
</ul>
<p>注意，这里的instanced和instanced rendering是两码事，这里的instanced是专门针对GS说的，意思是GS可以对同一个输入图元执行多次。对一个输入图元的每次调用(invocation)都会有一个不同的<code>gl_InvocationID</code>值。请注意这里的&quot;<strong>一个图元</strong>&quot;, 如果你有两个图元，<code>num_instances = 3</code>, 那么GS被执行的顺序和<code>gl_InvocationID</code>的值是这样的</p>
<ol start="0">
<li>(prim0, inst0)</li>
<li>(prim0, inst1)</li>
<li>(prim0, inst2)</li>
<li>(prim1, inst0)</li>
<li>(prim1, inst1)</li>
<li>(prim1, inst2)</li>
</ol>
<p>这就是&quot;对一个输入图元的每次调用<code>gl_InvocationID</code>都会有一个不同的值&quot;的含义。</p>
<h1 id="geometry-shader-output-layout-qualifiers"><a class="markdownIt-Anchor" href="#geometry-shader-output-layout-qualifiers"></a> Geometry Shader Output Layout Qualifiers</h1>
<p>Geometry shader只能在接口限定符<strong>out</strong>前加Output Layout Qualifiers, 不能在输出块(output block)或变量声明前加Output Layout Qualifiers。</p>
<p>这些Output Layout Qualifiers有</p>
<ul>
<li><strong>points</strong></li>
<li><strong>line_strip</strong></li>
<li><strong>triangle_strip</strong></li>
<li><strong>max_vertices</strong> = <em>integer-constant</em></li>
</ul>
<h1 id="geometry-shader-built-in-variables"><a class="markdownIt-Anchor" href="#geometry-shader-built-in-variables"></a> Geometry Shader Built-in Variables</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in gl_PerVertex &#123;</span><br><span class="line">    vec4 gl_Position;</span><br><span class="line">    float gl_PointSize;</span><br><span class="line">    float gl_ClipDistance[];</span><br><span class="line">&#125; gl_in[];</span><br><span class="line"></span><br><span class="line">in int gl_PrimitiveIDIn;</span><br><span class="line"></span><br><span class="line">out gl_PerVertex &#123;</span><br><span class="line">    vec4 gl_Position;</span><br><span class="line">    float gl_PointSize;</span><br><span class="line">    float gl_ClipDistance[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">out int gl_PrimitiveID;</span><br><span class="line">out int gl_Layer;</span><br></pre></td></tr></table></figure>
<h1 id="geometry-shader-built-in-functions"><a class="markdownIt-Anchor" href="#geometry-shader-built-in-functions"></a> Geometry Shader Built-in Functions</h1>
<ul>
<li>
<p><code>void EmitVertex()</code></p>
<p>向当前的输出图元增加一个顶点，也即表示一个顶点完成了。增加一个顶点的意思是，使用 GS 中输出变量的当前值做为这个顶点的相关值，一旦 <code>EmitVertex()</code> 返回后，这些输出变量的值都将变成未定义的，这些输出变量包括</p>
<ul>
<li><code>gl_Position</code> (vec4)</li>
<li><code>gl_PointSize</code> (float)</li>
<li><code>gl_ClipDistance</code> (float)</li>
<li><code>gl_PrimitiveID</code> (integer)</li>
<li><code>gl_Layer</code> (integer)</li>
</ul>
<p>前3个其实就是 <code>gl_PerVertex</code></p>
</li>
<li>
<p><code>void EndPrimitive()</code></p>
<p>表示当前的图元输出完成，开始由后续的 <code>EmitVertex()</code> 输出下一个图元。如果 GS 只写一个图元，可以不用调 <code>EndPrimitive()</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_indirect_parameters</title>
    <url>/gfx/ARB/ARB_indirect_parameters/</url>
    <content><![CDATA[<h1 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_indirect_parameters.txt">Overview</a></h1>
<p>Numbers <strong>ARB Extension #154</strong></p>
<p>Requires <strong>OpenGL 4.2</strong></p>
<p>Since <strong>OpenGL 4.6 Core Profile Specification</strong></p>
<span id="more"></span>
<p>和它相关的OpenGL概念是<strong>Indirect Draw</strong>, 相关的扩展是<a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_draw_indirect.txt">GL_ARB_draw_indirect</a>(since OpenGL 3.2 Compatible Profile and since OpenGL 4.0 Core Profile)和<a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_multi_draw_indirect.txt">GL_ARB_multi_draw_indirect</a>(since OpenGL 4.1 Core Profile). 这个扩展引入了&quot;parameter buffer&quot;的概念，可以让indirect draw的大量的参数集合存储在buffer object, 然后用一个API调用分发整个indirect draw列表，从而提高OpenGL管线的执行效率。</p>
<p>更确切地说，这个扩展新增了一个buffer target，专门用来存放某个indirect drawing command的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PARAMETER_BUFFER_ARB    0x80EE</span><br></pre></td></tr></table></figure>
<p>它可以作为下列命令的参数</p>
<ul>
<li>BindBuffer</li>
<li>BufferData</li>
<li>BufferSubData</li>
<li>MapBuffer</li>
<li>UnmapBuffer</li>
<li>GetBufferSubData</li>
<li>GetBufferPointerv</li>
<li>MapBufferRange</li>
<li>FlushMappedBufferRange</li>
<li>GetBufferParameteriv</li>
<li>CopyBufferSubData</li>
</ul>
<p>新增的<strong>MultiDraw*Indirect</strong>命令的变种是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MultiDrawArraysIndirectCountARB</span><br><span class="line">MultiDrawElementsIndirectCountARB</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_point_parameters</title>
    <url>/gfx/ARB/ARB_point_parameters/</url>
    <content><![CDATA[<h1 id="概述14"><a class="markdownIt-Anchor" href="#概述14"></a> 概述(#14)</h1>
<p>ARB_point_parameters允许用户设置点的扩展几何特征。这些点的几何特征主要用来渲染粒子或微小光源，通常被称为光点(Light Points).</p>
<span id="more"></span>
<p>光栅化后的点的明亮度由多个因素决定: 点的面积(Area), 点的颜色(Color), 点的透明度(Transparency), 以及电子枪和磷光粉之间的反应。而点的面积和点的透明度由点的大小(Size)推导而来，在ARB_point_parameters之前，点的大小<code>size</code>这个参数由 <code>glPointSize</code>指定。</p>
<p>ARB_point_parameters扩展主要实现两个目的:</p>
<ol>
<li>点的大小(Size)要受距离衰减的影响，就是点的大小要随着点离观察点的距离的增大而减小。</li>
</ol>
<p>这个扩展定义的点的明亮度的距离衰减公式是:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>×</mo><mi>d</mi><mo>+</mo><mi>c</mi><mo>×</mo><msup><mi>d</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">Attenuation(d) = \frac{1}{a + b \times d + c \times d^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>B</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>P</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>×</mo><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mo stretchy="false">∣</mo><mi>P</mi><mi>e</mi><mo stretchy="false">∣</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Brightness(Pe) = Brightness \times Attenuation(\lvert Pe \rvert)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mopen">∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mclose">∣</span><span class="mclose">)</span></span></span></span></span></p>
<p>这里，</p>
<ul>
<li><strong>Pe</strong> 指在眼睛坐标系里的一个点(Point in eye coordinates)</li>
<li><strong>Brightness</strong> 是与点的大小成正比的一个初始值</li>
<li><strong>a</strong>, <strong>b</strong>, <strong>c</strong> 是由<code>glPointParameterfv()</code>通过参数<code>GL_POINT_DISTANCE_ATTENUATION</code>传入的衰减因子</li>
</ul>
<ol start="2">
<li>点的大小(Size)到点的面积和透明度的映射要受一个门限的控制，就是点的面积小于一个门限后，点的Alpha分量(一般是Color的第4个分量，它决定透明度，Alpha等于0，表示完全透明)要随面积的减小而减小。</li>
</ol>
<p>这个扩展定义的点的最终的Alpha(Pe)分量的计算公式是:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>r</mi><mi>e</mi><mi>a</mi><mo stretchy="false">(</mo><mi>P</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>B</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>P</mi><mi>e</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>B</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>P</mi><mi>e</mi><mo stretchy="false">)</mo><mo>≥</mo><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi><mi>A</mi><mi>r</mi><mi>e</mi><mi>a</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi><mi>A</mi><mi>r</mi><mi>e</mi><mi>a</mi><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>otherwise </mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">Area(Pe) = \begin{cases}
  Brightness(Pe), &amp; \text{if } Brightness(Pe) \geq ThresholdArea \\
  ThresholdArea,  &amp; \text{otherwise }
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">otherwise </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>P</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>B</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>P</mi><mi>e</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi><mi>A</mi><mi>r</mi><mi>e</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Factor(Pe) = Brightness(Pe) / ThresholdArea
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo stretchy="false">(</mo><mi>P</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mi>α</mi><mo>∗</mo><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>P</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Alpha(Pe) = \alpha * Factor(Pe)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">p</span><span class="mord mathnormal">h</span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></span></p>
<p>这里，</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 是点的Color(RGBA)的第4个分量</li>
<li><strong>ThresholdArea</strong> 是与<code>glPointParameterf()</code>通过参数<code>GL_POINT_FADE_THRESHOLD_SIZE</code>传入的值的平方成正比的一个门限值</li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Draw 命令</title>
    <url>/gfx/ARB/ARB_multi_draw_indirect/</url>
    <content><![CDATA[<h1 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h1>
<p>OpenGL 有很多 Draw 命令， 大体分为 4 类:</p>
<ul>
<li>DrawArrays</li>
<li>DrawElements (Indexed)</li>
<li>DrawInstanced</li>
<li>DrawIndirect</li>
</ul>
<span id="more"></span>
<p>所谓的绘制，如果从pipeline的角度看，实际上主要是顶点着色(vertex shading)的过程。所以这些绘制方式中主要涉及的问题是顶点(vertices)及这些顶点如果构成图元(primitives)。这些绘制方式的不同主要在于它们各自是如何看待顶点，例如，在Basic绘制中，顶点就是顶点，而在Indexed绘制中，除了顶点本身外，还给出了构造三角形的顶点索引，这在特定场景下，是一种更有效率的绘制方式。</p>
<p>OpenGL中的Draw Commands是一组生成GPU渲染Command Stream的API，我们可以将它们简单分为4类:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Drawing</th>
<th style="text-align:left">适用场景</th>
<th style="text-align:left">Vertex Attributes Buffer Object Binding类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Array</td>
<td style="text-align:left">普通</td>
<td style="text-align:left">GL_ARRAY_BUFFER</td>
</tr>
<tr>
<td style="text-align:left">Indexed</td>
<td style="text-align:left">重复的顶点</td>
<td style="text-align:left">GL_ELEMENT_ARRAY_BUFFER</td>
</tr>
<tr>
<td style="text-align:left">Instanced</td>
<td style="text-align:left">重复的模型(Instance/Model)</td>
<td style="text-align:left">GL_ARRAY_BUFFER<br>GL_ELEMENT_ARRAY_BUFFER</td>
</tr>
<tr>
<td style="text-align:left">Indirect</td>
<td style="text-align:left">Drawing命令的参数直接放在GPU</td>
<td style="text-align:left">GL_DRAW_INDIRECT_BUFFER</td>
</tr>
</tbody>
</table>
<p>Array Drawing是最基本的Draw命令，其它3类都是从它衍生来的，为了某种绘制便利或顶点复用对Array Drawing API进行扩展，从而得到相应的索引绘制、实例绘制、间接绘制。</p>
<h1 id="drawarrays"><a class="markdownIt-Anchor" href="#drawarrays"></a> DrawArrays</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">glDrawArrays</span><span class="params">(GLenum mode,</span></span><br><span class="line"><span class="params">                  GLint first,</span></span><br><span class="line"><span class="params">                  GLsizei count)</span>;</span><br></pre></td></tr></table></figure>
<p><code>glDrawArrays</code>是OpenGL中最基本的绘制命令，<code>mode</code>接受的图元类型是下面的一个子集:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Primitives */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_POINTS                         0x0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_LINES                          0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_LINE_LOOP                      0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_LINE_STRIP                     0x0003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_TRIANGLES                      0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_TRIANGLE_STRIP                 0x0005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_TRIANGLE_FAN                   0x0006</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_QUADS                          0x0007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_QUAD_STRIP                     0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_POLYGON                        0x0009</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_LINES_ADJACENCY                0x000A (since OpenGL 3.2) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_LINE_STRIP_ADJACENCY           0x000B (since OpenGL 3.2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_TRIANGLES_ADJACENCY            0x000C (since OpenGL 3.2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_TRIANGLE_STRIP_ADJACENCY       0x000D (since OpenGL 3.2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_PATCHES                        0x000E (since OpenGL 3.2)</span></span><br></pre></td></tr></table></figure>
<p>例如顶点数组如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    vertices</span><br><span class="line">   ----------</span><br><span class="line"><span class="number">0</span> | (<span class="number">-1</span>,  <span class="number">1</span>) |</span><br><span class="line"><span class="number">1</span> | (<span class="number">-1</span>, <span class="number">-1</span>) |</span><br><span class="line"><span class="number">2</span> | ( <span class="number">1</span>, <span class="number">-1</span>) |</span><br><span class="line"><span class="number">3</span> | ( <span class="number">1</span>,  <span class="number">1</span>) |</span><br><span class="line">   ----------</span><br></pre></td></tr></table></figure>
<p>用3个顶点绘制一个三角形，调用命令如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h1 id="drawelements"><a class="markdownIt-Anchor" href="#drawelements"></a> DrawElements</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">glDrawElements</span><span class="params">(GLenum mode,</span></span><br><span class="line"><span class="params">                    GLsizei count,</span></span><br><span class="line"><span class="params">                    GLenum type,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="type">void</span>* indices)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">glDrawElementsBaseVertex</span><span class="params">(GLenum mode,</span></span><br><span class="line"><span class="params">                              GLsizei count,</span></span><br><span class="line"><span class="params">                              GLenum type,</span></span><br><span class="line"><span class="params">                              <span class="type">void</span>* indices</span></span><br><span class="line"><span class="params">                              GLint basevertex)</span>;</span><br></pre></td></tr></table></figure>
<p><code>glDrawElements</code>不是直接用顶点数组去绘制，而是用顶点数组的索引去绘制，例如还是用3个顶点绘制一个三角形</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    vertices</span><br><span class="line">   ----------</span><br><span class="line"><span class="number">0</span> | (<span class="number">-1</span>,  <span class="number">1</span>) |</span><br><span class="line"><span class="number">1</span> | (<span class="number">-1</span>, <span class="number">-1</span>) |</span><br><span class="line"><span class="number">2</span> | ( <span class="number">1</span>, <span class="number">-1</span>) |</span><br><span class="line"><span class="number">3</span> | ( <span class="number">1</span>,  <span class="number">1</span>) |</span><br><span class="line">   ----------</span><br></pre></td></tr></table></figure>
<p>这次除了顶点数组外，我们还要上传一个顶点索引数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  indices</span><br><span class="line">   -----</span><br><span class="line"><span class="number">0</span> |  <span class="number">0</span>  |</span><br><span class="line"><span class="number">1</span> |  <span class="number">1</span>  |</span><br><span class="line"><span class="number">2</span> |  <span class="number">2</span>  |</span><br><span class="line">   -----</span><br></pre></td></tr></table></figure>
<p>调用命令如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_BYTE, &amp;indices);</span><br></pre></td></tr></table></figure>
<p>当然上面这个只有3个顶点的例子体现不出来<code>glDrawElements</code>的复用顶点的好处，但是在三角形很多且这些三角形的顶点有很多重复的情形下就不同了，它的优势就体现出来了:</p>
<ul>
<li>虽然我们额外增加了一个索引数组indices去存储所绘制顶点的索引，但相比一个顶点最多4个float类型的数据量来说，用一个unsigned byte来表示一个顶点还是划算的。</li>
<li>在顶点坐标一样，只需改变顶点顺序的图元绘制中，将大大减少数据量。</li>
</ul>
<p><code>glDrawElementsBaseVertex</code>的行为和<code>glDrawElements</code>一样，除了在所取到的索引数组相应元素值上加basevertex. 考虑如下情况:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    vertices                indices</span><br><span class="line">   ----------                -----</span><br><span class="line"><span class="number">0</span> | (<span class="number">-1</span>,  <span class="number">1</span>) |            <span class="number">0</span> |  <span class="number">0</span>  |</span><br><span class="line"><span class="number">1</span> | (<span class="number">-1</span>, <span class="number">-1</span>) |            <span class="number">1</span> |  <span class="number">1</span>  |</span><br><span class="line"><span class="number">2</span> | ( <span class="number">1</span>, <span class="number">-1</span>) |            <span class="number">2</span> |  <span class="number">2</span>  |</span><br><span class="line"><span class="number">3</span> | ( <span class="number">1</span>,  <span class="number">1</span>) |            <span class="number">3</span> |  <span class="number">3</span>  |</span><br><span class="line">   ----------             <span class="number">4</span> |  <span class="number">0</span>  |</span><br><span class="line">                          <span class="number">5</span> |  <span class="number">2</span>  |</span><br><span class="line">                             -----</span><br></pre></td></tr></table></figure>
<p>这种情况下，我们一般会调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_BYTE, &amp;indices);</span><br></pre></td></tr></table></figure>
<p>但是如果所索引的顶点不在顶点数组的开始，而是从第100个顶点开始</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      vertices                indices2</span><br><span class="line">     ----------                -----</span><br><span class="line">        ....                <span class="number">0</span> | <span class="number">100</span> |</span><br><span class="line"><span class="number">100</span> | (<span class="number">-1</span>,  <span class="number">1</span>) |            <span class="number">1</span> | <span class="number">101</span> |</span><br><span class="line"><span class="number">101</span> | (<span class="number">-1</span>, <span class="number">-1</span>) |            <span class="number">2</span> | <span class="number">102</span> |</span><br><span class="line"><span class="number">102</span> | ( <span class="number">1</span>, <span class="number">-1</span>) |            <span class="number">3</span> | <span class="number">103</span> |</span><br><span class="line"><span class="number">103</span> | ( <span class="number">1</span>,  <span class="number">1</span>) |            <span class="number">4</span> | <span class="number">100</span> |</span><br><span class="line">        ....                <span class="number">5</span> | <span class="number">102</span> |</span><br><span class="line">     ----------                -----</span><br></pre></td></tr></table></figure>
<p>这种情况下原来的indices不能用了，只能再创建并绑定一个新的VBO <code>indices2</code>, 而创建绑定VBO是内存操作开销很大，<code>glDrawElementsBaseVertex</code>就是解决这个问题的。我们只需要在原来的索引值上加一个offset</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glDrawElementsBaseVertex(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_BYTE, &amp;indices, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h1 id="drawinstanced"><a class="markdownIt-Anchor" href="#drawinstanced"></a> Draw*Instanced</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">glDrawArraysInstanced</span><span class="params">(GLenum mode,</span></span><br><span class="line"><span class="params">                           GLint first,</span></span><br><span class="line"><span class="params">                           GLsizei count,</span></span><br><span class="line"><span class="params">                           GLsizei instancecount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">glDrawArraysInstancedBaseInstance</span><span class="params">(GLenum mode,</span></span><br><span class="line"><span class="params">                                       GLint first,</span></span><br><span class="line"><span class="params">                                       GLsizei count,</span></span><br><span class="line"><span class="params">                                       GLsizei instancecount,</span></span><br><span class="line"><span class="params">                                       GLuint baseinstance)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">glDrawElementsInstanced</span><span class="params">(GLenum mode,</span></span><br><span class="line"><span class="params">                             GLsizei count,</span></span><br><span class="line"><span class="params">                             GLenum type,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">void</span>* indices,</span></span><br><span class="line"><span class="params">                             GLsizei instancecount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">glDrawElementsInstancedBaseInstance</span><span class="params">(GLenum mode,</span></span><br><span class="line"><span class="params">                                         GLsizei count,</span></span><br><span class="line"><span class="params">                                         GLenum type,</span></span><br><span class="line"><span class="params">                                         <span class="type">const</span> <span class="type">void</span>* indices,</span></span><br><span class="line"><span class="params">                                         GLsizei instancecount,</span></span><br><span class="line"><span class="params">                                         GLuint baseinstance)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">glDrawElementsInstancedBaseVertex</span><span class="params">(GLenum mode,</span></span><br><span class="line"><span class="params">                                       GLsizei count,</span></span><br><span class="line"><span class="params">                                       GLenum type,</span></span><br><span class="line"><span class="params">                                       <span class="type">void</span>* indices,</span></span><br><span class="line"><span class="params">                                       GLsizei instancecount,</span></span><br><span class="line"><span class="params">                                       GLint basevertex)</span>;</span><br></pre></td></tr></table></figure>
<p>要理解上面这些OpenGL Instanced Draw命令，首先我们要理解一个OpenGL里并不存在的Draw命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glDrawArraysOneInstance(GLenum mode,</span><br><span class="line">                             GLint first,</span><br><span class="line">                             GLsizei count,</span><br><span class="line">                             GLint instance,</span><br><span class="line">                             GLuint baseinstance);</span><br></pre></td></tr></table></figure>
<p>Instanced Drawing简单说就是一次Draw Call绘制多个实例，比如一个布满树叶的场景，每片树叶的顶点数据可能是相似的，可能就是在世界坐标系中的位置不同，其它顶点属性可能都相同。那么Instanced Drawing是如何复制相同的实例到不同的位置上的呢?</p>
<p>OpenGL主要通过以下两个变量控制Instanced Drawing</p>
<ul>
<li>gl_InstanceID (Vertex Shader)</li>
<li>divisor (glVertexAttribDivisor)</li>
</ul>
<h2 id="gl_instanceid"><a class="markdownIt-Anchor" href="#gl_instanceid"></a> gl_InstanceID</h2>
<p>gl_InstanceID是Vertex Shader里的内置变量，如果你这样调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glDrawArraysInstanced(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>那么<code>gl_InstanceID</code>的取值范围就是[0, 99]</p>
<h2 id="divisor"><a class="markdownIt-Anchor" href="#divisor"></a> divisor</h2>
<p>假设location为2的Vertex Attribute用来设置每个实例的位置偏移，shader如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec2 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 aOffset;</span><br><span class="line"></span><br><span class="line">out vec3 fColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = vec4(aPos + aOffset, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过下面的API告诉OpenGL, 每画一个实例更新一下index=2这个属性，而不是默认的，每一个顶点更新一次属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);</span><br><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">glVertexAttribDivisor(<span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h1 id="drawindirect"><a class="markdownIt-Anchor" href="#drawindirect"></a> Draw*Indirect</h1>
<p>Indirect Drawing是将Array/Indexed Drawing命令的参数存入专门的Buffer Object，也就是GPU Storage里，这里的Buffer Object的绑定类型是<code>GL_DRAW_INDIRECT_BUFFER</code>。之所以这样做，是为了能让GPU直接写回这些值，比方Compute Shader, 或者为Transform Feedback设计的Geometry Shader, 亦或是OpenCL/CUDA kernel函数。这样避免了这些参数在GPU和CPU之间来回地复制(round-trip)</p>
<h2 id="drawarraysindirect"><a class="markdownIt-Anchor" href="#drawarraysindirect"></a> DrawArraysIndirect</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">glDrawArraysIndirect</span><span class="params">(GLenum mode, <span class="type">const</span> <span class="type">void</span> *indirect)</span>;</span><br></pre></td></tr></table></figure>
<p>在OpenGL ES 3.1及以上，DrawArraysIndirect的Draw Parameters被定义成下面的结构体:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uint count;</span><br><span class="line">    uint instanceCount;</span><br><span class="line">    uint first;</span><br><span class="line">    uint reservedMustBeZero;</span><br><span class="line">&#125; DrawArraysIndirectCommand;</span><br></pre></td></tr></table></figure>
<p>在OpenGL 4.0及以上，DrawArraysIndirect的Draw Parameters被定义成下面的结构体:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uint count;</span><br><span class="line">    uint instanceCount;</span><br><span class="line">    uint first;</span><br><span class="line">    uint baseInstance;</span><br><span class="line">&#125; DrawArraysIndirectCommand;</span><br></pre></td></tr></table></figure>
<p>之所以 ES 的 DrawIndirectCommand 里没有 <code>baseInstance</code>，是因为 ES 没有下面的命令:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">glDrawArraysIntancedBaseInstance</span><span class="params">(GLenum mode,</span></span><br><span class="line"><span class="params">				      GLint first,</span></span><br><span class="line"><span class="params">				      GLsizei count,</span></span><br><span class="line"><span class="params">				      GLsizei instancecount,</span></span><br><span class="line"><span class="params">				      GLuint baseinstance)</span>;</span><br></pre></td></tr></table></figure>
<p>因此在 ES 中，<code>glDrawArraysIndirect()</code> 可以分解成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DrawArraysIndirectCommand *cmd = (DrawArraysIndirectCommand *)indirect;</span><br><span class="line">DrawArraysInstanced(mode, cmd-&gt;first, cmd-&gt;count, cmd-&gt;instanceCount);</span><br></pre></td></tr></table></figure>
<p>而在OpenGL中，<code>glDrawArraysIndirect()</code> 可以分解成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DrawArraysIndirectCommand *cmd = (DrawArraysIndirectCommand *)indirect;</span><br><span class="line">DrawArraysInstancedBaseInstance(mode, cmd-&gt;first, cmd-&gt;count,</span><br><span class="line">                cmd-&gt;instanceCount, cmd-&gt;baseInstance);</span><br></pre></td></tr></table></figure>
<p>下面是 <a href="https://github.com/linzj/sb7code_withmedia/blob/master/src/multidrawindirect/multidrawindirect.cpp">SuperBible7 multidrawindirect</a> 中 MultiDraw 的实现 (<a href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_multi_draw_indirect.txt">GL_ARB_multi_draw_indirect</a> 是 4.1 引入的新扩展)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == MODE_MULTIDRAW)</span><br><span class="line">&#123;</span><br><span class="line">    glMultiDrawArraysIndirect(GL_TRIANGLES, <span class="literal">NULL</span>, NUM_DRAWS, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mode == MODE_SEPARATE_DRAWS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NUM_DRAWS; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        GLuint first, count;</span><br><span class="line">        object.get_sub_object_info(j % object.get_sub_object_count(), first, count);</span><br><span class="line">        glDrawArraysInstancedBaseInstance(GL_TRIANGLES,</span><br><span class="line">                                          first,</span><br><span class="line">                                          count,</span><br><span class="line">                                          <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="drawelementsindirect"><a class="markdownIt-Anchor" href="#drawelementsindirect"></a> DrawElementsIndirect</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect);</span><br></pre></td></tr></table></figure>
<p>在ES 3.1中, DrawElementsIndirect的Draw Parameters被定义成下面这个结构体:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uint count;</span><br><span class="line">    uint instanceCount;</span><br><span class="line">    uint firstIndex;</span><br><span class="line">    <span class="type">int</span>  baseVertex;</span><br><span class="line">    uint reservedMustBeZero;</span><br><span class="line">&#125; DrawElementsIndirectCommand;</span><br></pre></td></tr></table></figure>
<p>而在OpenGL 4.0及以上, DrawElementsIndirect的<code>indirect</code>指向的Draw Parameters被定义成下面的结构体:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uint count;</span><br><span class="line">    uint primCount;</span><br><span class="line">    uint firstIndex;</span><br><span class="line">    uint baseVertex;</span><br><span class="line">    uint baseInstance;</span><br><span class="line">&#125; DrawElementsIndirectCommand;</span><br></pre></td></tr></table></figure>
<h2 id="mesa-实现-indirect-draw"><a class="markdownIt-Anchor" href="#mesa-实现-indirect-draw"></a> Mesa 实现 Indirect Draw</h2>
<p>应该很少有直接支持 Indirect Draw 的硬件，Mesa 中提供一个 utility 函数 <code>util_draw_indirect()</code>, 它将 indirect buffer 中的参数分析后把 indirect draw 展开成普通的 gallium-&gt;draw_vbo(), 像 sb7code 中 multidrawindirect 这个 demo, 展开后的循环次数是 50000 次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This extracts the draw arguments from the indirect resource,</span></span><br><span class="line"><span class="comment"> * puts them into a new instance of pipe_draw_info, and calls draw_vbo on it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">util_draw_indirect</span><span class="params">(<span class="keyword">struct</span> pipe_context *pipe,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="keyword">struct</span> pipe_draw_info *info_in,</span></span><br><span class="line"><span class="params">                   <span class="type">unsigned</span> drawid_offset,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="keyword">struct</span> pipe_draw_indirect_info *indirect)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; draw_count; i++) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">pipe_draw_start_count_bias</span> <span class="title">draw</span>;</span></span><br><span class="line"></span><br><span class="line">      draw.count = params[<span class="number">0</span>];</span><br><span class="line">      info.instance_count = params[<span class="number">1</span>];</span><br><span class="line">      draw.start = params[<span class="number">2</span>];</span><br><span class="line">      draw.index_bias = info_in-&gt;index_size ? params[<span class="number">3</span>] : <span class="number">0</span>;</span><br><span class="line">      info.start_instance = info_in-&gt;index_size ? params[<span class="number">4</span>] : params[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">      pipe-&gt;draw_vbo(pipe, &amp;info, i + drawid_offset, <span class="literal">NULL</span>, &amp;draw, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      params += indirect-&gt;stride / <span class="number">4</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h1>
<ul>
<li><a href="https://learnopengl.com/Advanced-OpenGL/Instancing">https://learnopengl.com/Advanced-OpenGL/Instancing</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_program_interface_query</title>
    <url>/gfx/ARB/ARB_program_interface_query/</url>
    <content><![CDATA[<h1 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_program_interface_query.txt">Overview</a></h1>
<p>Numbers <strong>ARB Extension #134</strong></p>
<p>Requires <strong>OpenGL 2.0</strong></p>
<span id="more"></span>
<p>Affected By</p>
<ul>
<li>ARB_transform_feedback</li>
<li>EXT_transform_feedback</li>
<li>ARB_uniform_buffer_object</li>
<li>ARB_shader_subroutine</li>
<li>ARB_shader_atomic_counters</li>
<li>ARB_shader_storage_buffer_object</li>
<li>ARB_arrays_of_arrays</li>
<li>ARB_compute_shader</li>
<li>ARB_explicit_uniform_location</li>
</ul>
<p>Since <strong>OpenGL 4.3 Core Profile Specification</strong></p>
<p>这个扩展给应用程序提供一组统一的查询命令。这组命令用来查询被program objects用来与应用程序代码或其它program object通信的各种interfaces和resources的属性。</p>
<p>这个扩展定义了两个概念：<strong>interfaces</strong>和<strong>active resources</strong></p>
<h2 id="interfaces"><a class="markdownIt-Anchor" href="#interfaces"></a> Interfaces</h2>
<p>Provides a way for the program to communicate with application code, fixed-function OpenGL pipeline stages, and other programs.</p>
<p>例如：</p>
<ul>
<li>inputs</li>
<li>outputs</li>
<li>uniforms</li>
<li>uniform blocks</li>
<li>subroutines and subroutine uniforms</li>
<li>atomic counter buffers</li>
</ul>
<h2 id="active-resources"><a class="markdownIt-Anchor" href="#active-resources"></a> Active Resources</h2>
<p>Each interface of a program has a set of active resources used by the program.</p>
<pre><code class="highlight mermaid">graph TD
    A[Data]
    B[Vertex Shader]
    C[Tess Control Shader]
    D[Tess Eval Shader]
    E[Geometry Shader]
    F[Fragment Shader]
    G[Output]

    A --&gt; B
    B --&gt; C
    C --&gt; D
    D --&gt; E
    E --&gt; F
    F --&gt; G</code></pre>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_shader_ballot</title>
    <url>/gfx/ARB/ARB_shader_ballot/</url>
    <content><![CDATA[<h1 id="概述183"><a class="markdownIt-Anchor" href="#概述183"></a> 概述(#183)</h1>
<p>ARB_shader_ballot给一组线程(a group of invocations)提供某些形式的线程间(cross-invocation)通信的能力。它要么是通过广播某个线程作用域里的值，要么是通过一个位数组(bitarray)表示一组线程中每个线程作用域里的可能的值。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>GL_ARB_shader_storage_buffer_object</title>
    <url>/gfx/ARB/ARB_shader_storage_buffer_object/</url>
    <content><![CDATA[<h1 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_shader_storage_buffer_object.txt">Overview</a></h1>
<p>Numbers <strong>ARB Extension #137</strong></p>
<span id="more"></span>
<p>Requires <strong>ARB_program_interface_query</strong></p>
<p>Interacts</p>
<ul>
<li>ARB_compute_shader</li>
<li>ARB_program_interface_query</li>
</ul>
<p>Since <strong>OpenGL 4.3 Core Profile Specification</strong></p>
<p>这个扩展提供能让应用Shader Code对存储在buffer object中的变量进行随机的读写，原子存储操作的能力。这里的buffer objects即为**“shader storage buffers”**.</p>
<h1 id="gl_arb_uniform_buffer_object"><a class="markdownIt-Anchor" href="#gl_arb_uniform_buffer_object"></a> <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt">GL_ARB_uniform_buffer_object</a></h1>
<p><strong>GL_ARB_uniform_buffer_object</strong>引入了一个新的概念<strong>uniform block</strong>用来存放一组uniform变量，调用API将uinform blocks与buffer objects绑定。实际上相当于让shader可以访问buffer objects里的uniforms.</p>
<p>与 UBO 相比， SSBO 有以下特点</p>
<ul>
<li>大容量数据存储
<ul>
<li>SSBO 的大小可以达到 128MB 甚至更多</li>
</ul>
</li>
<li>读写操作
<ul>
<li>SSBO 支持读写操作，而 UBO 通常是<strong>只读</strong>的。这使用 SSBO 在需要频繁更新数据的场景中非常有用。</li>
</ul>
</li>
<li>灵活的数据结构
<ul>
<li>SSBO 可以包含<strong>可变长度</strong>的数据，这在处理动态数据时非常方便</li>
</ul>
</li>
</ul>
<h1 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h1>
<ul>
<li>声明 SSBO</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout(std430, binding = 0) buffer BufferName &#123;</span><br><span class="line">    vec4 data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建和初始化 SSBO</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GLuint ssbo;</span><br><span class="line">glGenBuffers(1, &amp;ssbo);</span><br><span class="line">glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo);</span><br><span class="line">glBufferData(GL_SHADER_STORAGE_BUFFER, bufferSize, NULL, GL_DYNAMIC_COPY);</span><br><span class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, bindingPoint, ssbo);</span><br></pre></td></tr></table></figure>
<p>但是与uniform blocks最大的不同是，uniform blocks是只读的，而interface blocks也即<strong>shader storage buffer</strong>是可读可写的。<br />
也即多个独立的shader可以读写同一块内存。所以这里同样有内存互斥访问的问题存在。OpenGL Specification和Shading Language都提供了一些机制来控制内存访问。</p>
<ul>
<li>OpenGL API</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glMemoryBarrier()</span><br></pre></td></tr></table></figure>
<ul>
<li>GLSL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memoryBarrier()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_shading_language_420pack</title>
    <url>/gfx/ARB/ARB_shading_language_420pack/</url>
    <content><![CDATA[<h1 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_shading_language_420pack.txt">Overview</a></h1>
<p>Numbers <strong>ARB Extension #108</strong></p>
<span id="more"></span>
<p>Interacts</p>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_shader_image_load_store.txt">ARB_shader_image_load_store</a></li>
</ul>
<p>Since <strong>OpenGL 4.2 Core Profile Specification</strong></p>
<p>这个扩展是一个<strong>Language feature only extension</strong>, 即它完全只跟GLSL相关。它增加了以下改变</p>
<ul>
<li>增加续行符<code>\</code></li>
<li>把GLSL的字符集由ASCII改为UTF-8</li>
<li>允许隐式地将返回值类型转换为函数声明的类型</li>
<li><strong>const</strong>关键字可以在函数体内声明变量，同时允许使用一个非常量表达式初始化该变量</li>
<li>变量声明的修饰符不再必须有严格的顺序。<strong>layout qualifier</strong>可以被使用多次，多个<strong>parameter qualifiers</strong>可以被用，但并不是说变量声明可以有任意的初始化列表。只是说某一类的修饰符只可以用一个，它们之间的顺序限制被取消了。</li>
<li>增加layout qualifier identifier <code>binding</code>用来绑定一个uniform block的location. uniform block本身需要GLSL 1.4的支持。</li>
<li>增加layout qualifier identifier <code>binding</code>用来绑定units到sampler和image variable声明。</li>
<li>增加C语言风格的初始化列表，即 <code>a[10] = &#123; 0 &#125;;</code></li>
<li>增加vectors和matrices的<code>.length()</code>方法，返回vector的分量个数或matrix的列数。</li>
<li>允许标量的swizzle操作。</li>
<li>增加内置常量<code>gl_MinProgramTexelOffset</code>和<code>gl_MaxProgramTexelOffset</code></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_sparse_texture</title>
    <url>/gfx/ARB/ARB_sparse_texture/</url>
    <content><![CDATA[<h1 id="overview158"><a class="markdownIt-Anchor" href="#overview158"></a> Overview(#158)</h1>
<p>复杂的OpenGL应用和对高分辨率的追求使纹理的大小巨增，但是可供一个GPU使用的物理内存是有限的，一旦内存使用殆尽，内存换页就可能发生，性能严重下降，或者更糟，应用直接挂了。但另一方面GPU可访问的地址空间目前已经可以达到GB，甚至TB.</p>
<span id="more"></span>
<p>ARB_sparse_texture允许你使用一个比GPU物理内存大得多的纹理(e.g. 16384x16384 32bpp)，它使用一种虚拟页的方法将大的纹理分成多个页， 这些页有的驻留在物理内存，有的没有，只有当需要的时候才加载它们。比方我们根据相机的视角变化，只加载那些在视野范围内可见的pages. 因此sparse texture也叫做tiled texture或mega texture.</p>

<h1 id="restrictions"><a class="markdownIt-Anchor" href="#restrictions"></a> Restrictions</h1>
<ul>
<li>只有Immutable-Format Texture才能作为Sparse Texture</li>
<li>不是所有的internalformat都可以作为Sparse Texture, 具体哪些支持参见<a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_sparse_texture.txt">ARB_sparse_texture spec</a></li>
</ul>
<h1 id="how-to-use"><a class="markdownIt-Anchor" href="#how-to-use"></a> How to Use</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GLuint page_texture;</span><br><span class="line"></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;page_texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, page_texture);</span><br><span class="line"></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_SPARSE_ARB, GL_TRUE);</span><br><span class="line">glTexStorage2D(GL_TEXTURE_2D, <span class="number">15</span>, GL_RGBA32F, <span class="number">16384</span>, <span class="number">16384</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// commit a level 0 page.</span></span><br><span class="line">glTexPageCommitmentARB(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">64</span>, <span class="number">0</span>, GL_TRUE);</span><br><span class="line"><span class="comment">// 4KB increase here.</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_texture_storage</title>
    <url>/gfx/ARB/ARB_texture_storage/</url>
    <content><![CDATA[<h1 id="overview117"><a class="markdownIt-Anchor" href="#overview117"></a> Overview(#117)</h1>
<p>ARB_texture_storage的主要目的是简化纹理一致性(consistency)和完整性(completeness)检查，以减小实现的开销。</p>
<span id="more"></span>
<p>在ARB_texture_storage之前，OpenGL允许给每个Mipmap级别分别指定不同的大小，像素格式(format), 数据类型(type)等等，把纹理一致性检查放在draw time阶段，这给实现增加了开销。</p>
<p>而ARB_texture_storage可以一次性(in a single call)指定纹理的整个结构，把一致性检查和内存申请提前。一旦指定，这个纹理的像素格式和维度都不可再变(Immutable)，这样就简化了纹理完整性检查的实现。</p>
<p>使用ARB_texture_storage, 就不能再用<code>TexImage*</code>上传纹理数据了(mutable), 而是用<code>TexSubImage*</code>(immutable)。或是用其它方式动态生成纹理数据(immutable), 比如<em>render-to-texture, mipmap generation, rendering to a sibling EGLImage</em>.</p>
<h1 id="immutable-format-texture-images"><a class="markdownIt-Anchor" href="#immutable-format-texture-images"></a> Immutable-Format Texture Images</h1>
<p>Immutable-Format Texture与ARB_texture_storage有直接的关系。所谓Immutable-Format Texture，就是有一组GL命令，他们可以一次性设定纹理所有level的属性，一旦调用成功，所有level的format和dimensions都不能再改变，除非它是一个代理纹理。然而它的内容和纹理parameters仍然可以修改，这样的纹理就是Immutable-Format Texture.</p>
<h2 id="a-set-of-commands-for-immutable-format-texture"><a class="markdownIt-Anchor" href="#a-set-of-commands-for-immutable-format-texture"></a> A set of commands for immutable-format texture</h2>
<ul>
<li>glTexStorage1D</li>
<li>glTexStorage2D</li>
<li>glTexStorage3D</li>
<li>glTexStorage2DMultisample</li>
<li>glTexStorage3DMultisample</li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_texture_swizzle</title>
    <url>/gfx/ARB/ARB_texture_swizzle/</url>
    <content><![CDATA[<h1 id="概述84"><a class="markdownIt-Anchor" href="#概述84"></a> 概述(#84)</h1>
<p>传统的OpenGL纹理格式(texture format)的纹理数据存储和解释是统一的，纹理就是被解释成颜色。而在现代OpenGL应用中，大多数纹理并不是代表颜色，而是代表像shadow maps, normal maps, page tables, occlusion data等等这样的数据。对于后者，我们将纹理数据称作&quot;RGBA&quot;，只是对数据在现有模型上的一种方便的映射，但并不是数据实际上的准确解释。</p>
<span id="more"></span>
<p>已有的纹理格式几乎是纹理数据的类型，分量的个数，分量的位数的集合的正交组合，但是对于着色器或固定管线所读取的数据如何解解并不那么正交。之前的扩展也增加了一些最迫切要求的纹理格式，但问题没有被完全解决。</p>
<p>ARB_texture_swizzle提供了一种被使用之前或者被着色器读取之前，重排一个纹理像素的分量的机制。比方说可以设置让shader读取纹理数据时只取Red分量。</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>ARB_texture_view</title>
    <url>/gfx/ARB/ARB_texture_view/</url>
    <content><![CDATA[<h1 id="概述124"><a class="markdownIt-Anchor" href="#概述124"></a> 概述(#124)</h1>
<p>ARB_texture_view的主要目的是通过创建已有纹理对象的视图(view), 来产生新的纹理对象，以达到共享同一纹理存储(data store)的目的。它可以从以下3个方面创建纹理视图：</p>
<span id="more"></span>
<ul>
<li>texture type 它可以指定一个新的纹理类型(在约束范围内)来创建新的纹理对象</li>
<li>internal format 它可以定义一个新的纹理格式(在约束范围内)来解释已有的data store</li>
<li>sub mipmap/array range 它可以从已有纹理的mipmap levels或array slices中截取一个子集作为新的纹理对象</li>
</ul>
<p>NOTE: 上述最后一种方式只指定新的范围(level/index)，而不进行data store拷贝。</p>
<p>没有增加新的纹理类型，原来的纹理对象被划分为以下几个部分:</p>
<ul>
<li>数据存储(Data Store)</li>
<li>状态信息，用来描述Data Store的哪一部分被使用，如何解释所用的数据元素</li>
<li>嵌入的采样器对象(Sampler)</li>
<li>各种其它纹理参数，像Filter, Mipmap等</li>
</ul>
<h1 id="原则"><a class="markdownIt-Anchor" href="#原则"></a> 原则</h1>
<p>ARB_texture_view规定的关于创建Texture View的几个原则(限制)主要有以下3个:</p>
<ul>
<li>只能给Immutable纹理创建View,也就是那些由TexStorage创建的纹理</li>
<li>原纹理和新纹理的格式要兼容</li>
<li>原纹理和新纹理的类型要兼容</li>
</ul>
<h2 id="为什么只给immutable纹理类型创建texture-view"><a class="markdownIt-Anchor" href="#为什么只给immutable纹理类型创建texture-view"></a> 为什么只给Immutable纹理类型创建Texture View</h2>
<p>Texture View本质上并没有上传纹理data store, 而是像指针一样，增加了对已有纹理对象的引用。如果是Mutable纹理，那么它的格式，大小等都是可以修改的，这样就无法保证纹理的consistency和completeness. 而Immutable纹理不会存在这样的问题。</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>GL_ARB_transform_feedback</title>
    <url>/gfx/ARB/ARB_transform_feedback3/</url>
    <content><![CDATA[<h1 id="transform-feedback"><a class="markdownIt-Anchor" href="#transform-feedback"></a> <a href="https://www.khronos.org/opengl/wiki/Transform_Feedback">Transform Feedback</a> 引入</h1>
<p>Transform Feedback首先是DirectX3D引入的，但在DirectX3D中它不叫TF, 而是叫<strong>Stream Output Stage</strong>. 它第一次被引入OpenGL是在2006年，但当时是以扩展的形式<a href="https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_transform_feedback.txt">GL_EXT_transform_feedback</a>引入的，它正式成为OpenGL Required Core Features是在OpenGL 3.0(2008), 在这之后，OpenGL 4.0, 4.2, 4.6又分别引入了一些TF相关的新特性。</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th style="text-align:left">Extensions</th>
<th style="text-align:left">OpenGL Version</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_EXT_transform_feedback</td>
<td style="text-align:left">3.0</td>
</tr>
<tr>
<td style="text-align:left">GL_ARB_transform_feedback2</td>
<td style="text-align:left">4.0</td>
</tr>
<tr>
<td style="text-align:left">GL_ARB_transform_feedback3</td>
<td style="text-align:left">4.0</td>
</tr>
<tr>
<td style="text-align:left">GL_ARB_transform_feedback_instanced</td>
<td style="text-align:left">4.2</td>
</tr>
<tr>
<td style="text-align:left">GL_ARB_transform_feedback_overflow_query</td>
<td style="text-align:left">4.6</td>
</tr>
</tbody>
</table>
<h1 id="transform-feedback-是什么"><a class="markdownIt-Anchor" href="#transform-feedback-是什么"></a> Transform Feedback 是什么</h1>
<p>TF是将Vertex_Processing阶段产生的图元的顶点属性(vertex attributes)保存(capture/record)在<strong>Transform Feedback Buffer</strong>, 保存之后你可以:</p>
<ul>
<li>CPU侧读取这些数据重新应用到你的渲染引擎</li>
<li>GPU直接将这些数据反馈到另一个Draw Call</li>
</ul>
<p>某种意义上讲，TF是OpenGL第一种compute shader的形式，在TF之前，唯一能从shader的输出读取数据的方式是<code>glReadPixels</code>和其同族API.</p>
<p><img src="/images/tf-gles-31.jpg" alt="OpenGL 3.1 Pipeline" /></p>
<h2 id="vertex-processing"><a class="markdownIt-Anchor" href="#vertex-processing"></a> <a href="https://www.khronos.org/opengl/wiki/Vertex_Processing">Vertex Processing</a></h2>
<p>TF的输入来自Vertex Processing, 所以首先要确定Vertex Processing阶段都做什么，输出什么。Vertex Processing的输出是图元(Primitives), 它至少包含一个vertex shader.</p>
<table>
<thead>
<tr>
<th style="text-align:left">着色器</th>
<th style="text-align:left">是否必需</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">VERTEX</td>
<td style="text-align:left">Y</td>
</tr>
<tr>
<td style="text-align:left">TESSELLATION</td>
<td style="text-align:left">N</td>
</tr>
<tr>
<td style="text-align:left">GEOMETRY</td>
<td style="text-align:left">N</td>
</tr>
</tbody>
</table>
<h2 id="capturing"><a class="markdownIt-Anchor" href="#capturing"></a> Capturing</h2>
<p>当Vertex Processing最后的shader是geometry或tessellation evaluation时，则所记录的图元就是geometry或tessellation evaluation输出的图元，否则那些顶点数据来自vertex shader. 另外所记录的顶点数据也不一定都保存在同一个buffer里，这即为<code>bufferMode</code>的含义。</p>
<h3 id="capturing-setting"><a class="markdownIt-Anchor" href="#capturing-setting"></a> Capturing Setting</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glTransformFeedbackVaryings(GLuint program,</span><br><span class="line">				 GLsizei count,</span><br><span class="line">				 const char **varyings,</span><br><span class="line">				 GLenum bufferMode);</span><br></pre></td></tr></table></figure>
<p>这个API设置:</p>
<ul>
<li>
<p>哪些program的输出变量被<strong>captured</strong></p>
</li>
<li>
<p>capturing模式， capturing模式有两种</p>
<ul>
<li><code>GL_INTERLEAVED_ATTRIBS</code></li>
<li><code>GL_SEPARATE_ATTRIBS</code></li>
</ul>
</li>
<li>
<p>interleaved mode</p>
</li>
</ul>
<p>这种模式下，所有captured的输出被保存在同一个buffer object.</p>
<ul>
<li>separate mode</li>
</ul>
<p>这种模式下，输出未必被captured到不同的buffer object, 它仅仅是指输出被captured到不同的<strong>buffer binding points</strong>. 因为同一个buffer object的不同区域也可以被绑定到不同的<strong>buffer binding points</strong>.</p>
<h3 id="captured-output-variables"><a class="markdownIt-Anchor" href="#captured-output-variables"></a> Captured Output Variables</h3>
<p>那么可以记录的顶点属性有多少个呢？大小如何？</p>
<h3 id="多少顶点属性或总共多少数据可以被记录"><a class="markdownIt-Anchor" href="#多少顶点属性或总共多少数据可以被记录"></a> 多少顶点属性或总共多少数据可以被记录</h3>
<ul>
<li>separate capture</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Limitation</th>
<th style="text-align:center">Minimal Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:left">GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<ul>
<li>interleaved capture</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Limitation</th>
<th style="text-align:center">Minimal Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS</td>
<td style="text-align:center">64</td>
</tr>
</tbody>
</table>
<ul>
<li>advanced interleaved capture (不同的变量放在不同的buffers)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Limitation</th>
<th style="text-align:center">Minimal Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GL_MAX_TRANSFORM_FEEDBACK_BUFFERS</td>
<td style="text-align:center">64</td>
</tr>
</tbody>
</table>
<p>注意到在interleaved capture mode下，没有顶点属性个数的限制，原因是在interleaved mode下，所有顶点属性都是在同一个buffer中，所以限制了总的components的个数后，无论你记录多少个属性，这些属性总的components个数不能超过这个最大值, 而在separate mode下，每个列出的变量是保存在各自不同的buffer中，所以除了对components设限外，还要对属性个数设限。所以这里<code>GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS</code>的一个更好的名字应该是<code>GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_BUFFERS</code>.</p>
<h3 id="顶点属性的数据类型是什么"><a class="markdownIt-Anchor" href="#顶点属性的数据类型是什么"></a> 顶点属性的数据类型是什么</h3>
<ul>
<li>structs</li>
<li>arrays</li>
<li>members of interface blocks</li>
</ul>
<h2 id="varyings"><a class="markdownIt-Anchor" href="#varyings"></a> Varyings</h2>
<h1 id="transform-feedback-处理过程"><a class="markdownIt-Anchor" href="#transform-feedback-处理过程"></a> Transform Feedback 处理过程</h1>
<h2 id="feedback-buffer-binding"><a class="markdownIt-Anchor" href="#feedback-buffer-binding"></a> Feedback Buffer Binding</h2>
<p>当设置好要capturing program中的哪些输出变量，以何种模式captured后，接下来就要设置(申请)保存captured的数据的buffer objects.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glBindBufferRange(GLenum target,</span><br><span class="line">		       GLuint index,</span><br><span class="line">		       GLuint buffer,</span><br><span class="line">		       GLintptr offset,</span><br><span class="line">		       GLsizeiptr size);</span><br></pre></td></tr></table></figure>
<p>这里<code>target</code>就是<code>GL_TRANSFORM_FEEDBACK_BUFFER</code>. <code>offset</code>必须是4字节对齐，如果存进buffer的值包含<strong>double-precision</strong>, 则需要8字节对齐。</p>
<h2 id="feedback-beginend"><a class="markdownIt-Anchor" href="#feedback-beginend"></a> Feedback Begin/End</h2>
<p>Capture设置好，Buffer绑定好之后，就可以开始<strong>Recording</strong> Vertex Processing产出的数据了。通过调用下面的API开始Feedback:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glBeginTransformFeedback(GLenum primitiveMode);</span><br></pre></td></tr></table></figure>
<p>这里<code>primitiveMode</code>只能是以下3种之一:</p>
<ul>
<li>GL_POINTS</li>
<li>GL_LINES</li>
<li>GL_TRIANGLES</li>
</ul>
<p>Transform Feedback模式被激活后，在没有调用<code>glPauseTransformFeedback</code>或<code>glEndTransformFeedback</code>之前，以下行为不被允许:</p>
<ul>
<li>修改<code>GL_TRANSFORM_FEEDBACK_BUFFER</code>的bindings</li>
<li>任何对这些绑定的<code>GL_TRANSFORM_FEEDBACK_BUFFER</code>的读写操作</li>
<li>重新申请这些绑定的<code>GL_TRANSFORM_FEEDBACK_BUFFER</code>的存储</li>
<li>修改当前使用的program, 也就是不能调用<code>glUseProgram</code>或<code>glBindProgramPipeline</code>, 还有<code>glUseProgramStages</code></li>
</ul>
<p>退出Transform Feedback模式调用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glEndTransformFeedback();</span><br></pre></td></tr></table></figure>
<h2 id="feedback-objects"><a class="markdownIt-Anchor" href="#feedback-objects"></a> Feedback Objects</h2>
<p>跟其它OpenGL的功能一样，Transform Feedback也有一大堆state需要track, 所以这些state被封装进<strong>Transform Feedback Objects</strong>, 这些Feedback Objects和其它OpenGL Object一样需要<code>Gen</code>, <code>Delete</code>和<code>Bind</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glGenTransformFeedbacks(GLsizei n, GLuint *ids);</span><br><span class="line">void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids);</span><br><span class="line">void glBindTransformFeedback(GLenum target, GLuint id);</span><br></pre></td></tr></table></figure>
<p>NOTE:</p>
<ul>
<li><code>glBindTransformFeedback</code>的<code>target</code>永远是<code>GL_TRANSFORM_FEEDBACK</code></li>
<li>不能绑定一个Feedback Object，如果当前的Feedback Object还是active或没有被paused.</li>
</ul>
<p>那么Feedback Object里封装了哪些Transform Feedback state呢？</p>
<ul>
<li>generic buffer bindings, 即调用<code>glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER, ...)</code>绑定的那些buffers</li>
<li>indexed buffer bindings, 即调用<code>glBindBufferRange(GL_TRANSFORM_FEEDBACK, ...)</code>绑定的那些buffers</li>
<li>transform feedback是否是active还是paused</li>
<li>被当前的feedback操作记录的count of primitives等等</li>
</ul>
<h2 id="feedback-rendering"><a class="markdownIt-Anchor" href="#feedback-rendering"></a> Feedback Rendering</h2>
<p>OK, 我们现在获得了Vertex Processing的结果，并记录了这次Transform Feedback操作的状态到Transform Feedback Objects(例如captured count of primitives, the number of vertices). 但是我们如何利用这些captured数据呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void glDrawTransformFeedback(GLenum mode,</span><br><span class="line">			     GLuint id);</span><br><span class="line"></span><br><span class="line">void glDrawTransformFeedbackInstanced(GLenum mode,</span><br><span class="line">				      GLuint id,</span><br><span class="line">				      GLsizei instancecount);</span><br><span class="line">void glDrawTransformFeedbackStream(GLenum mode,</span><br><span class="line">				   GLuint id,</span><br><span class="line">				   GLuint stream);</span><br><span class="line">void glDrawTransformFeedbackStreamInstanced(GLenum mode,</span><br><span class="line">					    GLuint id,</span><br><span class="line">					    GLuint stream,</span><br><span class="line">					    GLsizei instancecount);</span><br></pre></td></tr></table></figure>
<p>NOTE:</p>
<ul>
<li>在调用这些<code>Draw</code>命令前，一定要先调用<code>glEndTransformFeedback</code>, 因为只有当调用了<code>glEndTransformFeedback</code>后，OpenGL状态机才知道一次完整的Transform Feedback操作完成了。</li>
</ul>
<h1 id="transform-feedback-应用"><a class="markdownIt-Anchor" href="#transform-feedback-应用"></a> Transform Feedback 应用</h1>
<p>TF最常见的应用是粒子系统(Particle System), 即包含许许多多小颗粒的场景，如烟，雾，火等，这些场景的共同点是包含大量顶点，而且顶点属性在不断变化，如果没有TF, 会大大增加CPU向GPU传送顶点数据的开销，不论是总线的带宽还是CPU的使用率都可能无法承受。</p>
<h2 id="例子-springmass"><a class="markdownIt-Anchor" href="#例子-springmass"></a> 例子 springmass</h2>
<ul>
<li>两个Shader programs
<ul>
<li><code>m_update_program</code>, 用来更新(重新计算)顶点属性</li>
<li><code>m_render_program</code>, 用来渲染最后的画面</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void render(double t)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    glUseProgram(m_update_program);</span><br><span class="line"></span><br><span class="line">    glEnable(GL_RASTERIZER_DISCARD);</span><br><span class="line"></span><br><span class="line">    for (i = iterations_per_frame; i != 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        glBindVertexArray(m_vao[m_iteration_index &amp; 1]);</span><br><span class="line">        glBindTexture(GL_TEXTURE_BUFFER, m_pos_tbo[m_iteration_index &amp; 1]);</span><br><span class="line">        m_iteration_index++;</span><br><span class="line">        glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, m_vbo[POSITION_A + (m_iteration_index &amp; 1)]);</span><br><span class="line">        glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 1, m_vbo[VELOCITY_A + (m_iteration_index &amp; 1)]);</span><br><span class="line">        glBeginTransformFeedback(GL_POINTS);</span><br><span class="line">        glDrawArrays(GL_POINTS, 0, POINTS_TOTAL);</span><br><span class="line">        glEndTransformFeedback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glDisable(GL_RASTERIZER_DISCARD);</span><br><span class="line"></span><br><span class="line">    static const GLfloat black[] = &#123; 0.0f, 0.0f, 0.0f, 0.0f &#125;;</span><br><span class="line"></span><br><span class="line">    glViewport(0, 0, info.windowWidth, info.windowHeight);</span><br><span class="line">    glClearBufferfv(GL_COLOR, 0, black);</span><br><span class="line"></span><br><span class="line">    glUseProgram(m_render_program);</span><br><span class="line"></span><br><span class="line">    if (draw_points)</span><br><span class="line">    &#123;</span><br><span class="line">        glPointSize(4.0f);</span><br><span class="line">        glDrawArrays(GL_POINTS, 0, POINTS_TOTAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (draw_lines)</span><br><span class="line">    &#123;</span><br><span class="line">        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_index_buffer);</span><br><span class="line">        glDrawElements(GL_LINES, CONNECTIONS_TOTAL * 2, GL_UNSIGNED_INT, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段<code>render()</code>函数的前半段是一个双缓冲交替的模式, 用来倒换TFB和Vertex Array Buffer的数据。后半段是简单的<code>DrawArrays()</code>或<code>DrawElements()</code>。我们简单说下前半段的for-loop.</p>
<p>首先定义了3个Buffer数组：分别用作Vertex Array Buffer, Transform Feedback Buffer和Texture Buffer</p>
<ul>
<li><code>m_vao[2] = &#123;1, 2&#125;</code></li>
<li><code>m_vbo[5] = &#123;1, 2, 3, 4, 5&#125;</code></li>
<li><code>m_pos_tbo[2] = &#123;1, 2&#125;</code></li>
</ul>
<p>循环展开后:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0</span></span><br><span class="line">glBindVertexArray(<span class="number">1</span>);</span><br><span class="line">glBindTexture(GL_TEXTURE_BUFFER, <span class="number">1</span>);</span><br><span class="line">m_iteration_index++;</span><br><span class="line">glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">glBeginTransformFeedback(GL_POINTS);</span><br><span class="line">glDrawArrays(GL_POINTS, <span class="number">0</span>，POINTS_TOTAL);</span><br><span class="line">glEndTransformFeedback();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">glBindVertexArray(<span class="number">2</span>);</span><br><span class="line">glBindTexture(GL_TEXTURE_BUFFER, <span class="number">2</span>);</span><br><span class="line">m_iteration_index++;</span><br><span class="line">glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">glBeginTransformFeedback(GL_POINTS);</span><br><span class="line">glDrawArrays(GL_POINTS, <span class="number">0</span>，POINTS_TOTAL);</span><br><span class="line">glEndTransformFeedback();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">glBindVertexArray(<span class="number">1</span>);</span><br><span class="line">glBindTexture(GL_TEXTURE_BUFFER, <span class="number">1</span>);</span><br><span class="line">m_iteration_index++;</span><br><span class="line">glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">glBeginTransformFeedback(GL_POINTS);</span><br><span class="line">glDrawArrays(GL_POINTS, <span class="number">0</span>，POINTS_TOTAL);</span><br><span class="line">glEndTransformFeedback();</span><br></pre></td></tr></table></figure>
<p><img src="/images/ompparticles.png" alt="ompparticles" /></p>
<p><a href="https://github.com/lwtbn1/OpenGL_Superbible_7th/blob/master/src/ompparticles/ompparticles.cpp">ompparticles.cpp</a></p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li><a href="http://jason-blog.jlekstrand.net/2018/10/transform-feedback-is-terrible-so-why.html">Transform Feedback Is Terrible, So Why Are We Doing It</a></li>
<li><a href="https://community.arm.com/cn/b/blog/posts/transform-feedback-1547554897">Transform Feedback的前世今生(一)</a></li>
<li><a href="https://ogldev.org/www/tutorial28/tutorial28.html">Particle System using Transform Feedback</a></li>
</ul>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Build X Server (Xorg) from Source</title>
    <url>/gfx/X/build-xserver/</url>
    <content><![CDATA[<h1 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h1>
<p>Given that a difficulty to add a custom X11 device driver or module or extension for Xserver, I try to find out how an Xserver is built and its dependent drivers and modules and extensions are orgnized together by building it from <a href="https://gitlab.freedesktop.org/xorg/xserver.git">source</a>.</p>
<span id="more"></span>
<h1 id="build"><a class="markdownIt-Anchor" href="#build"></a> Build</h1>
<p>Xorg 的源码库克隆下来后，checkout 到目标分支或 tag, 假设我们想编译 xorg-server-1.20.4 这个版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout xorg-server-1.20.4 -b 1.20.4  // 将这个 tag 检出后命名为 1.20.4 分支</span><br></pre></td></tr></table></figure>
<p>X Server 的源码库中除了 Xorg，还包含 modesetting_drv.so, xnest, xwin, xvfb 等，这些组件并不全都需要，如果全都编译，可能会有更多的依赖。<br />
另外，Xorg 本身安装在 /usr/bin/ 目录, 其它相关 DDX 驱动安装在 /usr/lib/xorg/modules 目录，为了让编译好的 Xorg 和相关驱动安装后能够覆盖原来的，需要通过指定 meson 的 <code>prefix</code> 和 <code>libdir</code> 构建变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">meson build -Dprefix=/usr -Dlibdir=lib -Dxnest=false -Dxwin=false -Dxvfb=false</span><br></pre></td></tr></table></figure>
<p>NOTES: 默认情况下，<code>prefix=/usr/local</code>, <code>libdir=lib/x86_64-linux-gnu</code></p>
<p>构建配置完成后，进行编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ninja -C build</span><br></pre></td></tr></table></figure>
<p>编译完成后，使用 sudo 进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ninja install -C build</span><br></pre></td></tr></table></figure>
<p>安装成功后，使用 systemd 重启 X Server 服务 （假设使用的窗口管理器是 lightdm)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart lightdm</span><br></pre></td></tr></table></figure>
<p>It is easy to find what are built with <code>find build -type f -perm /a+x -regex '.*[^0-9h]$'</code></p>
<pre>
./build/meson-private/sanitycheckc.exe
./build/test/tests
./build/test/simple-xinit
./build/hw/xnest/Xnest
./build/hw/vfb/Xvfb
./build/hw/xfree86/gtf
./build/hw/xfree86/vgahw/libvgahw.so
./build/hw/xfree86/libxorgserver.so
./build/hw/xfree86/fbdevhw/libfbdevhw.so
./build/hw/xfree86/drivers/modesetting/modesetting_drv.so
./build/hw/xfree86/dixmods/libglx.so
./build/hw/xfree86/dixmods/libwfb.so
./build/hw/xfree86/dixmods/libshadow.so
./build/hw/xfree86/shadowfb/libshadowfb.so
./build/hw/xfree86/cvt
./build/hw/xfree86/exa/libexa.so
./build/hw/xfree86/Xorg
./build/hw/xfree86/int10/libint10.so
./build/hw/xfree86/loader/xorg_symbol_test
</pre>
<p>where <code>./build/hw/xfree86/Xorg</code> is newly built Xserver.</p>
<h2 id="replacement"><a class="markdownIt-Anchor" href="#replacement"></a> Replacement</h2>
<p>Now that we have an Xorg out there, we can try it. I have an <em>xrdp</em> installed on my WSL as its desktop environment. We can replace <code>xorgxrdp</code> with this new one for testing. To do it, we need to modify xrdp’s init configuration file <code>/etc/xrdp/sesman.ini</code></p>
<pre>
[Xorg]
; Specify the path of non-suid Xorg executable. It might differ depending
; on your distribution and version. The typical path is shown as follows:
;
; Fedora 26 or later    :  param=/usr/libexec/Xorg
; Debian 9 or later     :  param=/usr/lib/xorg/Xorg
; Ubuntu 16.04 or later :  param=/usr/lib/xorg/Xorg
; Arch Linux            :  param=/usr/lib/xorg-server/Xorg
; CentOS 7              :  param=/usr/bin/Xorg or param=Xorg
;
;param=/usr/lib/xorg/Xorg
;
param=/home/luc/github/xserver/build/hw/xfree86/Xorg
</pre>
<p>But it failed on restart xrdp.service. We check the log and <code>/etc/X11/xrdp/xorg.conf</code>. It turns out some drivers related xrdp do not exist. It is xrdp that customizes Xorg.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;(EE) Failed to&#x27; ~/.xorgxrdp.25.log</span><br></pre></td></tr></table></figure>
<pre>
[ 22862.100] (EE) Failed to load module "glx" (module does not exist, 0)
[ 22862.100] (EE) Failed to load module "int10" (module does not exist, 0)
[ 22862.100] (EE) Failed to load module "vbe" (module does not exist, 0)
[ 22862.100] (EE) Failed to load module "glamoregl" (module does not exist, 0)
[ 22862.100] (EE) Failed to load module "xorgxrdp" (module does not exist, 0)
[ 22862.100] (EE) Failed to load module "xrdpdev" (module does not exist, 0)
[ 22862.100] (EE) Failed to load module "xrdpmouse" (module does not exist, 0)
[ 22862.100] (EE) Failed to load module "xrdpkeyb" (module does not exist, 0)
</pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -E &#x27;(Driver | Load)&#x27; /etc/X11/xrdp/xorg.conf</span><br></pre></td></tr></table></figure>
<pre>
    Load "dbe"
    Load "ddc"
    Load "extmod"
    Load "glx"
    Load "int10"
    Load "record"
    Load "vbe"
    Load "glamoregl"
    Load "xorgxrdp"
    Load "fb"
    Driver "xrdpkeyb"
    Driver "xrdpmouse"
    Driver "xrdpdev"
</pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h2>
<p>Xserver/Xorg is built in a flexible and easy way. We can implement our own device-dependent functionality and add it to Xserver as its another driver or module.</p>
<h1 id="xserver-相关工具"><a class="markdownIt-Anchor" href="#xserver-相关工具"></a> Xserver 相关工具</h1>
<h2 id="xinit"><a class="markdownIt-Anchor" href="#xinit"></a> xinit</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ dpkg --contents /var/cache/apt/archives/xinit_1.4.1-0ubuntu2_amd64.deb | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | rg -v <span class="string">&#x27;/$&#x27;</span></span><br><span class="line">./etc/X11/xinit/xinitrc</span><br><span class="line">./etc/X11/xinit/xserverrc</span><br><span class="line">./usr/bin/startx</span><br><span class="line">./usr/bin/xinit</span><br><span class="line">./usr/share/doc/xinit/NEWS.Debian.gz</span><br><span class="line">./usr/share/doc/xinit/changelog.Debian.gz</span><br><span class="line">./usr/share/doc/xinit/copyright</span><br><span class="line">./usr/share/man/man1/startx.1.gz</span><br><span class="line">./usr/share/man/man1/xinit.1.gz</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>Debugging X11 with tcpdump</title>
    <url>/gfx/X/debug-x11-with-tcpdump/</url>
    <content><![CDATA[<p>X11 is designed as client-server mode. The communication between the X client and server complies with TCP protocol. Recently I have a Windows X server VcXsrv installed on my Windows 10 and I debug an OpenGL demo glxgears on the WSL2 with tcpdump.</p>
<h2 id="environment"><a class="markdownIt-Anchor" href="#environment"></a> Environment</h2>
<p>WSL2 is equipped with its own networking interface like a virtual machine.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.28.233.193  netmask 255.255.240.0  broadcast 172.28.239.255</span><br><span class="line">        inet6 fe80::215:5dff:fe27:9562  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:15:5d:27:95:62  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 221579  bytes 15160108 (15.1 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 306691  bytes 15714800233 (15.7 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 392  bytes 43340 (43.3 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 392  bytes 43340 (43.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -C <span class="string">&quot;ipconfig&quot;</span></span><br><span class="line"></span><br><span class="line">Windows IP Configuration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ethernet adapter vEthernet (WSL):</span><br><span class="line"></span><br><span class="line">   Connection-specific DNS Suffix  . : </span><br><span class="line">   Link-<span class="built_in">local</span> IPv6 Address . . . . . : fe80::412b:ad3:5548:67ba%38</span><br><span class="line">   IPv4 Address. . . . . . . . . . . : 172.28.224.1</span><br><span class="line">   Subnet Mask . . . . . . . . . . . : 255.255.240.0</span><br><span class="line">   Default Gateway . . . . . . . . . : </span><br><span class="line"></span><br><span class="line">Wireless LAN adapter ±¾µØÁ¬½Ó* 1:</span><br><span class="line"></span><br><span class="line">   Media State . . . . . . . . . . . : Media disconnected</span><br><span class="line">   Connection-specific DNS Suffix  . : </span><br><span class="line"></span><br><span class="line">Wireless LAN adapter ±¾µØÁ¬½Ó* 10:</span><br><span class="line"></span><br><span class="line">   Media State . . . . . . . . . . . : Media disconnected</span><br><span class="line">   Connection-specific DNS Suffix  . : </span><br><span class="line"></span><br><span class="line">Wireless LAN adapter WLAN:</span><br><span class="line"></span><br><span class="line">   Connection-specific DNS Suffix  . : DHCP HOST</span><br><span class="line">   Link-<span class="built_in">local</span> IPv6 Address . . . . . : fe80::954b:e66f:4065:20af%20</span><br><span class="line">   IPv4 Address. . . . . . . . . . . : 192.168.2.100</span><br><span class="line">   Subnet Mask . . . . . . . . . . . : 255.255.255.0</span><br><span class="line">   Default Gateway . . . . . . . . . : 192.168.2.1</span><br></pre></td></tr></table></figure>
<p>After starting up the X server VcXsrv, you need to export the environmnet variable <strong><code>DISPLAY</code></strong> on the WSL. In case of the vEthernet configuration changed after rebooting you’d better do it like this:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=$(grep <span class="string">&#x27;nameserver&#x27;</span> /etc/resolv.conf | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>):0</span><br></pre></td></tr></table></figure>
<p>NOTE: The Firewall between the host and WSL2 must be disabled or your X client can not connect VcXsrv.</p>
<h2 id="debugging"><a class="markdownIt-Anchor" href="#debugging"></a> Debugging</h2>
<p>I trace the demo glxgears using gdb and tcpdump at the same time.</p>
<ul>
<li>gdb</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb -q -tui glxgears</span><br></pre></td></tr></table></figure>
<ul>
<li>tcpdump</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -vvX not icmp and not arp and not udp and portrange 37900-37999 -w x110224.pcap</span><br></pre></td></tr></table></figure>
<ul>
<li>vv: verboser than -v</li>
<li>X: show the packet’s content</li>
<li>not icmp: filter out icmp packets</li>
<li>not arp: filter out arp packets</li>
<li>not udp: filter out udp packets</li>
<li>portrange 37900-37999: listening on the ports from 37900 to 37999</li>
<li>w x110224.pcap: save the packet captures into the file</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -X -r x110224.pcap</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reading from file /home/luc/github/x110224.pcap, link-type EN10MB (Ethernet)</span><br><span class="line">09:11:56.659816 IP 172.28.233.193.37950 &gt; 172.28.224.1.x11: Flags [P.], seq 2796598646:2796598658, ack 1053772981, win 259, length 12</span><br><span class="line">	0x0000:  4500 0034 1d84 4000 4006 fb43 ac1c e9c1  E..4..@.@..C....</span><br><span class="line">	0x0010:  ac1c e001 943e 1770 a6b0 b576 3ecf 4cb5  .....&gt;.p...v&gt;.L.</span><br><span class="line">	0x0020:  5018 0103 2223 0000 6200 0300 0400 0000  P...&quot;#..b.......</span><br><span class="line">	0x0030:  4452 4932                                DRI2</span><br><span class="line">09:11:56.660218 IP 172.28.224.1.x11 &gt; 172.28.233.193.37950: Flags [P.], seq 1:33, ack 12, win 8211, length 32</span><br><span class="line">	0x0000:  4500 0048 d9d7 4000 8006 fedb ac1c e001  E..H..@.........</span><br><span class="line">	0x0010:  ac1c e9c1 1770 943e 3ecf 4cb5 a6b0 b582  .....p.&gt;&gt;.L.....</span><br><span class="line">	0x0020:  5018 2013 cf36 0000 0100 0a00 0000 0000  P....6..........</span><br><span class="line">	0x0030:  0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class="line">	0x0040:  0000 0000 0000 0000                      ........</span><br><span class="line">09:11:56.660232 IP 172.28.233.193.37950 &gt; 172.28.224.1.x11: Flags [.], ack 33, win 259, length 0</span><br><span class="line">	0x0000:  4500 0028 1d85 4000 4006 fb4e ac1c e9c1  E..(..@.@..N....</span><br><span class="line">	0x0010:  ac1c e001 943e 1770 a6b0 b582 3ecf 4cd5  .....&gt;.p....&gt;.L.</span><br><span class="line">	0x0020:  5010 0103 2217 0000                      P...&quot;...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>what codes sends and receives these packets? The first two twenty-byted segments are IP header (20 bytes without option) and TCP header (20 bytes without option) separately in these packets.</p>
<p>The source code snippet:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Bool</span><br><span class="line"><span class="title function_">XQueryExtension</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">register</span> Display *dpy,</span></span><br><span class="line"><span class="params">    _Xconst <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> *major_opcode,  <span class="comment">/* RETURN */</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *first_event,   <span class="comment">/* RETURN */</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *first_error)</span>	<span class="comment">/* RETURN */</span></span><br><span class="line">&#123;</span><br><span class="line">    xQueryExtensionReply rep;</span><br><span class="line">    <span class="keyword">register</span> xQueryExtensionReq *req;</span><br><span class="line"></span><br><span class="line">    LockDisplay(dpy);</span><br><span class="line">    GetReq(QueryExtension, req);</span><br><span class="line">    req-&gt;nbytes = name ? <span class="built_in">strlen</span>(name) : <span class="number">0</span>;</span><br><span class="line">    req-&gt;length += (req-&gt;nbytes+(<span class="type">unsigned</span>)<span class="number">3</span>)&gt;&gt;<span class="number">2</span>;</span><br><span class="line">    _XSend(dpy, name, (<span class="type">long</span>)req-&gt;nbytes);</span><br><span class="line">    (<span class="type">void</span>) _XReply (dpy, (xReply *)&amp;rep, <span class="number">0</span>, xTrue);</span><br><span class="line">    *major_opcode = rep.major_opcode;</span><br><span class="line">    *first_event = rep.first_event;</span><br><span class="line">    *first_error = rep.first_error;</span><br><span class="line">    UnlockDisplay(dpy);</span><br><span class="line">    SyncHandle();</span><br><span class="line">    <span class="keyword">return</span> (rep.present);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The gdb log:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting program: /mnt/c/Users/lulu/Documents/github/demos/src/xdemos/glxgears </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, XextAddDisplay (extinfo=0x7ffff7e77380 &lt;_dri2Info_data&gt;, dpy=0x55555555d2a0, </span><br><span class="line">    ext_name=0x7ffff7e76780 &lt;dri2ExtensionName&gt; &quot;DRI2&quot;, hooks=0x7ffff7e767a0 &lt;dri2ExtensionHooks&gt;, nevents=0, data=0x0)</span><br><span class="line">    at extutil.c:103</span><br><span class="line">XInitExtension (dpy=dpy@entry=0x55555555d2a0, name=name@entry=0x7ffff7e76780 &lt;dri2ExtensionName&gt; &quot;DRI2&quot;)</span><br><span class="line">    at InitExt.c:44</span><br><span class="line">XQueryExtension (dpy=dpy@entry=0x55555555d2a0, name=name@entry=0x7ffff7e76780 &lt;dri2ExtensionName&gt; &quot;DRI2&quot;, </span><br><span class="line">    major_opcode=major_opcode@entry=0x7fffffffd984, first_event=first_event@entry=0x7fffffffd988, </span><br><span class="line">    first_error=first_error@entry=0x7fffffffd98c) at QuExt.c:39</span><br><span class="line">$2 = &#123;</span><br><span class="line">  reqType = 0x62, </span><br><span class="line">  pad = 0x0, </span><br><span class="line">  length = 0x3, </span><br><span class="line">  nbytes = 0x4, </span><br><span class="line">  pad1 = 0x0, </span><br><span class="line">  pad2 = 0x0</span><br><span class="line">&#125;</span><br><span class="line">$3 = &#123;</span><br><span class="line">  type = 0x1, </span><br><span class="line">  pad1 = 0x0, </span><br><span class="line">  sequenceNumber = 0xa, </span><br><span class="line">  length = 0x0, </span><br><span class="line">  present = 0x0, </span><br><span class="line">  major_opcode = 0x0, </span><br><span class="line">  first_event = 0x0, </span><br><span class="line">  first_error = 0x0, </span><br><span class="line">  pad3 = 0x0, </span><br><span class="line">  pad4 = 0x0, </span><br><span class="line">  pad5 = 0x0, </span><br><span class="line">  pad6 = 0x0, </span><br><span class="line">  pad7 = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>$2</code> is <strong>Request</strong> packet content to VcXsrv, <code>$3</code> is <strong>Reply</strong> packet content from VcXsrv. Even that we can notice the three-way handshake of TCP from the zero-lengthed packet in x110224.pcap.</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>Kylin V10 窗口透明问题</title>
    <url>/gfx/X/kylin-alpha-issue/</url>
    <content><![CDATA[<p>最近在看<a href="https://gitlab.freedesktop.org/xorg/xserver">X11 Server的代码</a>,顺手做下笔记。X11 Server的代码很古老了，有的是1993年写的，目前的X Server实现<a href="https://zh.wikipedia.org/wiki/X.Org_Server">X.org</a>是从最早的一个X Server实现<a href="https://zh.wikipedia.org/wiki/XFree86">XFree86</a> 4.4 RC2版本(2004年)派生出来的。</p>
<span id="more"></span>
<p>X11 Server编译后会生成若干动态链接库形式的驱动程序和一个可执行程序Xorg. Xorg本质上是一个服务器程序，像其它所有服务器程序一样，它的main函数里有一个while循环，以保证在程序启动后，到程序退出前能够为客户端持续提供服务。Xorg的另一个特点是极具扩展性，所有动态链接库形式的DDX(Device Dependent X)驱动都是以Xorg Module的方式动态加载的，具体加载哪个DDX Driver由Xorg的Config文件配置。</p>
<h1 id="同一个使用glfw的opengl程序在kylin-v10系统上可以修改alpha通道改变窗口背景的透明度而在ubuntu-focal-fossa系统上却不能"><a class="markdownIt-Anchor" href="#同一个使用glfw的opengl程序在kylin-v10系统上可以修改alpha通道改变窗口背景的透明度而在ubuntu-focal-fossa系统上却不能"></a> 同一个使用glfw的OpenGL程序在Kylin V10系统上可以修改alpha通道改变窗口背景的透明度，而在Ubuntu Focal Fossa系统上却不能？</h1>
<p>Alpha通道控制窗口的透明度(transparency)。而X11窗口系统上，alpha通道是否可用，和X11 Server的RENDER扩展有关，下面来自glfw的代码是自明的(self-explanatory)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GLFWbool _glfwIsVisualTransparentX11(Visual* visual)</span><br><span class="line">&#123;</span><br><span class="line">    if (!_glfw.x11.xrender.available)</span><br><span class="line">        return GLFW_FALSE;</span><br><span class="line"></span><br><span class="line">    XRenderPictFormat* pf = XRenderFindVisualFormat(_glfw.x11.display, visual);</span><br><span class="line">    return pf &amp;&amp; pf-&gt;direct.alphaMask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于系统上的 X11 Server 的 RENDER 扩展的信息可以通过 <code>xdpyinfo</code> 命令查看(此命令输出很多信息)</p>
<ul>
<li>Render formats</li>
</ul>
<p><code>xdpyinfo -ext RENDER | awk '/Render formats/,/Screen formats/'</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Render formats :</span><br><span class="line"> pict format:</span><br><span class="line">format id:    0x25</span><br><span class="line">type:         Direct</span><br><span class="line">depth:        1</span><br><span class="line">alpha:         0 mask 0x1</span><br><span class="line">red:           0 mask 0x0</span><br><span class="line">green:         0 mask 0x0</span><br><span class="line">blue:          0 mask 0x0</span><br><span class="line"> pict format:</span><br><span class="line"> ...</span><br><span class="line"> pict format:</span><br><span class="line">format id:    0x40</span><br><span class="line">type:         Direct</span><br><span class="line">depth:        32</span><br><span class="line">alpha:         0 mask 0x0</span><br><span class="line">red:           0 mask 0x3ff</span><br><span class="line">green:        10 mask 0x3ff</span><br><span class="line">blue:         20 mask 0x3ff</span><br><span class="line"> Screen formats :</span><br></pre></td></tr></table></figure>
<ul>
<li>Screen formats</li>
</ul>
<p><code>xdpyinfo -ext RENDER | awk '/Screen formats/,/depth formats/'</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Screen formats :</span><br><span class="line">  Screen 0 (sub-pixel order Unknown)</span><br><span class="line">    filters: nearest, bilinear, convolution, fast(nearest), good(bilinear), best(bilinear)</span><br><span class="line">    visual format:</span><br><span class="line">      visual id:      0x23</span><br><span class="line">      pict format id: 0x2c</span><br><span class="line">      ...</span><br><span class="line">    visual format:</span><br><span class="line">      visual id:      0x3a0</span><br><span class="line">      pict format id: 0x28</span><br><span class="line">   depth formats:</span><br></pre></td></tr></table></figure>
<p>上面使用 <code>xdpyinfo</code> 命令得到两张表：</p>
<ul>
<li><strong>Render formats</strong> 表列出了所有 RENDER 扩展支持的颜色格式的信息，包括它们的位深 (depth), 以及每个 Component 的位深 (mask)</li>
<li><strong>Screen formats</strong> 表实际上列出的是所有 X Visual 与 Render formats 的绑定关系</li>
</ul>
<p>接下来只需要查看一下程序(或者 GLFW )选取的 X Visual 的 Render format 的 Alpha 分量的位深是否为 0。 0 意味着 GLFW 获取的 <code>GLFW_TRANSPARENT_FRAMEBUFFER</code> 属性是<code>FALSE</code>, 也就意味着 GLFW 创建的这个窗口中，无法通过修改颜色的 Alpha 分量来改变窗口的透明度, 因为应用的窗口和桌面背景的融合(你是否能透过窗口看到桌面)是 X11 控制的。</p>
<p>我系统上(WSL Ubuntu 20.04)绝大部分VISUAL对应的都是这个ID为<code>0x2c</code>的<strong>pict format</strong>, 所以我不能通过修改alpha通道改变窗口背景或内容的透明度，除非我强制让glfw选择其它的VISUAL(对应的<strong>pict format</strong>不是<code>0x2c</code>)。</p>
<p>为了确定这个问题的确是VISUAL惹的祸，我想摆脱glfw，在单纯的GLX环境下测试一下，正好<a href="https://gitlab.freedesktop.org/mesa/demos">mesa/demos</a>这个工程下有一个<strong>glxgears_fbconfig</strong>，这个demo允许通过<code>GLX_FBCONFIG_ID</code>来指定你想要的 <code>GLXFBConfig</code>， 而 <code>GLXFBConfig</code> 和 <code>XVisualInfo</code> 虽然是不同组件里定义的描述 FB 配置的数据结构(前者是 <strong>Mesa GLX</strong> 里定义的，而后者是 <strong>X11 Util</strong> 里定义的), 但两者存在一一对应的关系。</p>
<p><img src="/images/kylin-alpha-issue/fbconfig.png" alt="GLXFBConfig vs XVisualInfo" /></p>
<ul>
<li>
<p>visual id: 0x5b, pict format id 0x28</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pict format:</span><br><span class="line">      format id:    0x28</span><br><span class="line">      type:         Direct</span><br><span class="line">      depth:        32</span><br><span class="line">      alpha:        24 mask 0xff</span><br><span class="line">      red:          16 mask 0xff</span><br><span class="line">      green:         8 mask 0xff</span><br><span class="line">      blue:          0 mask 0xff</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>visual id: 0x23, pict format id 0x2c</p>
</li>
</ul>
<p>注意，为了更清楚地看出不同，我使用<code>glClearBufferfv</code>将背景设置为半透明</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/src/xdemos/glxgears_fbconfig.c b/src/xdemos/glxgears_fbconfig.c</span></span><br><span class="line"><span class="comment">index 8806dd1c..7d6cbd29 100644</span></span><br><span class="line"><span class="comment">--- a/src/xdemos/glxgears_fbconfig.c</span></span><br><span class="line"><span class="comment">+++ b/src/xdemos/glxgears_fbconfig.c</span></span><br><span class="line">@@ -35,0 +36 @@</span><br><span class="line"><span class="addition">+#define GL_GLEXT_PROTOTYPES</span></span><br><span class="line">@@ -242,0 +244 @@ draw(void)</span><br><span class="line"><span class="addition">+    static const GLfloat bg[] = &#123;0.0, 0.0, 0.0, 0.5&#125;;</span></span><br><span class="line"><span class="addition">+    @@ -243,0 +246 @@ draw(void)</span></span><br><span class="line"><span class="addition">+    +   glClearBufferfv(GL_COLOR, 0, bg);</span></span><br><span class="line"><span class="addition">+    @@ -439,0 +443 @@ make_window( Display *dpy, const char *name,</span></span><br><span class="line"><span class="addition">+    +            GLX_VISUAL_ID,     0x23,)</span></span><br></pre></td></tr></table></figure>
<p>测试结果如下:</p>
<p><img src="/images/kylin-alpha-issue/visual_0x23.png" alt="VisualID=0x23" /><br />
<img src="/images/kylin-alpha-issue/visual_0x5b.png" alt="VisualID=0x5b" /></p>
<p>从测试结果看，在<code>VisualID=0x23</code>的情况下，这个VISUAL对应的<code>pict format</code>没有alpha通道，所以修改<code>bg</code>的alpha值不会对窗口背景的透明度有任何影响。</p>
<h1 id="glx-visual-和-fbconfig-不是一回事"><a class="markdownIt-Anchor" href="#glx-visual-和-fbconfig-不是一回事"></a> glx visual 和 fbconfig 不是一回事</h1>
<p>所以 <strong>GLX_VISUAL_ID</strong> 和 <strong>GLX_FBCONFIG_ID</strong> 也不是一回事， 虽然它俩都是 <code>XID</code>, 但 mesa 的实现虽然将 glx visual 和 fbconfig 统一用 <code>glx_config</code> 来表示, 但</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_GLX_PUBLIC XVisualInfo *</span><br><span class="line"><span class="title function_">glXChooseVisual</span><span class="params">(Display * dpy, <span class="type">int</span> screen, <span class="type">int</span> *attribList)</span>;</span><br><span class="line"></span><br><span class="line">_GLX_PUBLIC GLXFBConfig *</span><br><span class="line"><span class="title function_">glXChooseFBConfig</span><span class="params">(Display * dpy, <span class="type">int</span> screen, <span class="type">const</span> <span class="type">int</span> *attribList, <span class="type">int</span> *nitems)</span></span><br></pre></td></tr></table></figure>
<p>是完全不同的实现，而且 mesa 的 <code>glXChooseVisual()</code> 实际上无法通过指定 <strong>GLX_VISUAL_ID</strong> 来选择某个特定的 X Visual (这可能是一个 Bug)。</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>Pixmap in X</title>
    <url>/gfx/X/pixmap/</url>
    <content><![CDATA[<h1 id="xypixmap"><a class="markdownIt-Anchor" href="#xypixmap"></a> XYPixmap</h1>
<p>The data for a XYPixmap is organized as a set of bitmaps representing individual bit planes, with the planes appearing from MSB to LSB in bit order just as demonstrated below. Every pixel value is 0x55 (b’01010101) in this example.</p>
<span id="more"></span>
<pre>
                              ┌────────────────────────────┐
                              │1111111111111111111111111111│        
                            ┌─┴──────────────────────────┐1│
                            │0000000000000000000000000000│1│        
                          ┌─┴──────────────────────────┐0│1│
                          │1111111111111111111111111111│0│1│        
                        ┌─┴──────────────────────────┐1│0│1│
                        │0000000000000000000000000000│1│0│1│        
                      ┌─┴──────────────────────────┐0│1│0│1│
                      │1111111111111111111111111111│0│1│0│1│        
                    ┌─┴──────────────────────────┐1│0│1│0│1│◀────────────────── plane_7 
                    │0000000000000000000000000000│1│0│1│0│─┘        
                  ┌─┴──────────────────────────┐0│1│0│1│0│◀────────────────── plane_6 
                  │1111111111111111111111111111│0│1│0│1│─┘       
                ┌─┴──────────────────────────┐1│0│1│0│1│◀────────────────── plane_5 
                │0000000000000000000000000000│1│0│1│0│─┘      
                │0000000000000000000000000000│1│0│1│0│◀────────────────── plane_4       
                │0000000000000000000000000000│1│0│1│─┘      
                │0000000000000000000000000000│1│0│1│◀────────────────── plane_3       
                │0000000000000000000000000000│1│0│─┘      
                │0000000000000000000000000000│1│0│◀────────────────── plane_2  
                │0000000000000000000000000000│1│─┘       
                │0000000000000000000000000000│1│◀────────────────── plane_1        
                │0000000000000000000000000000│─┘       
                │0000000000000000000000000000│◀────────────────── plane_0       
                └────────────────────────────┘
</pre>
<h1 id="pixel-buffer"><a class="markdownIt-Anchor" href="#pixel-buffer"></a> Pixel buffer</h1>
<p>As a core feature of GLX &amp; EGL, pixel buffer or pBuffer is allowed for off-screen rendering. Pixel buffer is essentially a renderable area allocated by OpenGL itself (most likely a framebuffer) and is bound to an OpenGL rendering context.</b><br />
With respect to GLX, <code>glXCreatePbuffer</code> creates a pixel buffer and return its <code>XID</code>. In the implementation of Mesa, it calls <code>XCreatPixmap</code> to get an <code>XID</code> which is bound to the pixel buffer.</p>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>mesa中的winsys层</title>
    <url>/gfx/X/winsys/</url>
    <content><![CDATA[<h1 id="winsys有什么用"><a class="markdownIt-Anchor" href="#winsys有什么用"></a> winsys有什么用</h1>
<p>winsys像一个桥梁，它要将GPU渲染的结果传输到窗口系统的framebuffer，由显示系统将其呈现在屏幕上。</p>
<span id="more"></span>
<img src="/gfx/X/winsys/winsys-Page-2.drawio.png" class="" title="winsys">
<h1 id="mesa中的实现"><a class="markdownIt-Anchor" href="#mesa中的实现"></a> mesa中的实现</h1>
<p>mesa中winsys有两种实现: 一种是基于dri的，另一种是不基于dri的。两者的主要区别在以下几点:</p>
<ul>
<li>winsys提供的FBO(上图中的framebuffer)的来源</li>
</ul>
<h2 id="基于dri"><a class="markdownIt-Anchor" href="#基于dri"></a> 基于dri</h2>
<ul>
<li>amdgpu_winsys</li>
<li>radeon_winsys</li>
<li>nouveau_winsys</li>
</ul>
<p>基于dri的winsys的实现代码在<code>src/gallium/frontends/dri</code>目录</p>
<h3 id="基于dri-winsys的gallium-driver的加载"><a class="markdownIt-Anchor" href="#基于dri-winsys的gallium-driver的加载"></a> 基于dri winsys的gallium driver的加载</h3>
<p>所有使用基于dri的winsys的gallium drivers都会利用下面的宏声明和定义一个函数符号(除了swrast)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define DEFINE_LOADER_DRM_ENTRYPOINT(drivername)                          \</span><br><span class="line">const __DRIextension **__driDriverGetExtensions_##drivername(void);       \</span><br><span class="line">PUBLIC const __DRIextension **__driDriverGetExtensions_##drivername(void) \</span><br><span class="line">&#123;                                                                         \</span><br><span class="line">   globalDriverAPI = &amp;galliumdrm_driver_api;                              \</span><br><span class="line">   return galliumdrm_driver_extensions;                                   \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，<code>const __DRIextension **__driDriverGetExtensions_r600(void);</code>. 你可以在相应的动态库里查找到该符号。<br />
上面宏中的<code>galliumdrm_driver_api</code>和<code>galliumdrm_driver_extensions</code>都是全局的。</p>
<ul>
<li><code>galliumdrm_driver_api</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const struct __DriverAPIRec galliumdrm_driver_api = &#123;</span><br><span class="line">   .InitScreen = dri2_init_screen,</span><br><span class="line">   .DestroyScreen = dri_destroy_screen,</span><br><span class="line">   .CreateContext = dri_create_context,</span><br><span class="line">   .DestroyContext = dri_destroy_context,</span><br><span class="line">   .CreateBuffer = dri2_create_buffer,</span><br><span class="line">   .DestroyBuffer = dri_destroy_buffer,</span><br><span class="line">   .MakeCurrent = dri_make_current,</span><br><span class="line">   .UnbindContext = dri_unbind_context,</span><br><span class="line"></span><br><span class="line">   .AllocateBuffer = dri2_allocate_buffer,</span><br><span class="line">   .ReleaseBuffer  = dri2_release_buffer,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>galliumdrm_driver_extensions</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* This is the table of extensions that the loader will dlsym() for. */</span><br><span class="line">const __DRIextension *galliumdrm_driver_extensions[] = &#123;</span><br><span class="line">    &amp;driCoreExtension.base,</span><br><span class="line">    &amp;driImageDriverExtension.base,</span><br><span class="line">    &amp;driDRI2Extension.base,</span><br><span class="line">    &amp;gallium_config_options.base,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里出现的4个数组元素都是<code>__DRIextension</code>的子类，同时他们都是全局的。例如<code>driImageDriverExtension</code>被定义在<code>src/mesa/drivers/dri/common/dri_util.c</code>文件中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Image driver interface */</span><br><span class="line">const __DRIimageDriverExtension driImageDriverExtension = &#123;</span><br><span class="line">    .base = &#123; __DRI_IMAGE_DRIVER, 1 &#125;,</span><br><span class="line"></span><br><span class="line">    .createNewScreen2           = driCreateNewScreen2,</span><br><span class="line">    .createNewDrawable          = driCreateNewDrawable,</span><br><span class="line">    .getAPIMask                 = driGetAPIMask,</span><br><span class="line">    .createContextAttribs       = driCreateContextAttribs,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了这个<code>driImageDriverExtension</code>，基于dri的winsys还定义了一个与<code>__DRIimage</code>有关的<code>__DRIextension</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* The image loader extension record for DRI3</span><br><span class="line"> */</span><br><span class="line">static const __DRIimageLoaderExtension imageLoaderExtension = &#123;</span><br><span class="line">   .base = &#123; __DRI_IMAGE_LOADER, 3 &#125;,</span><br><span class="line"></span><br><span class="line">   .getBuffers          = loader_dri3_get_buffers,</span><br><span class="line">   .flushFrontBuffer    = dri3_flush_front_buffer,</span><br><span class="line">   .flushSwapBuffers    = dri3_flush_swap_buffers,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个所谓的image loader extension是在多GPU的场景下会用到，也就是当系统中同时存在两个GPU时，可以通过设置mesa提供的环境变量<code>DRI_PRIME</code>，启用PRIME模式，此时其中一个GPU作为Display GPU(server GPU), 用做X11显示，另外一个GPU作为Render GPU, 用做3D渲染，当我们申请<code>__DRI_IMAGE_BUFFER_FRONT</code>时，我们不能直接使用pixmap,<br />
因为所有pixmaps都是被server GPU所有，这种pixmap的格式可能不能被render GPU所理解。这种情况下，在<code>loader_dri3_get_buffers</code>中，会在render GPU的VRAM里创建一个Fake Front Buffer, 最后<code>dri3_flush_front_buffer</code>会将Fake Front Buffer的内容同步到真正的Front Buffer，即display GPU的pixmap里。</p>
<ul>
<li><code>xcb_dri3_pixmap_from_buffer</code></li>
</ul>
<p>这个函数是由<code>c_client.py</code>自动生成的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcb_void_cookie_t</span><br><span class="line">xcb_dri3_pixmap_from_buffer (xcb_connection_t *c,</span><br><span class="line">                             xcb_pixmap_t      pixmap,</span><br><span class="line">                             xcb_drawable_t    drawable,</span><br><span class="line">                             uint32_t          size,</span><br><span class="line">                             uint16_t          width,</span><br><span class="line">                             uint16_t          height,</span><br><span class="line">                             uint16_t          stride,</span><br><span class="line">                             uint8_t           depth,</span><br><span class="line">                             uint8_t           bpp,</span><br><span class="line">                             int32_t           pixmap_fd)</span><br><span class="line">&#123;</span><br><span class="line">    static const xcb_protocol_request_t xcb_req = &#123;</span><br><span class="line">        .count = 2,</span><br><span class="line">        .ext = &amp;xcb_dri3_id,</span><br><span class="line">        .opcode = XCB_DRI3_PIXMAP_FROM_BUFFER,</span><br><span class="line">        .isvoid = 1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    struct iovec xcb_parts[4];</span><br><span class="line">    xcb_void_cookie_t xcb_ret;</span><br><span class="line">    xcb_dri3_pixmap_from_buffer_request_t xcb_out;</span><br><span class="line">    int fds[1];</span><br><span class="line">    int fd_index = 0;</span><br><span class="line"></span><br><span class="line">    xcb_out.pixmap = pixmap;</span><br><span class="line">    xcb_out.drawable = drawable;</span><br><span class="line">    xcb_out.size = size;</span><br><span class="line">    xcb_out.width = width;</span><br><span class="line">    xcb_out.height = height;</span><br><span class="line">    xcb_out.stride = stride;</span><br><span class="line">    xcb_out.depth = depth;</span><br><span class="line">    xcb_out.bpp = bpp;</span><br><span class="line"></span><br><span class="line">    xcb_parts[2].iov_base = (char *) &amp;xcb_out;</span><br><span class="line">    xcb_parts[2].iov_len = sizeof(xcb_out);</span><br><span class="line">    xcb_parts[3].iov_base = 0;</span><br><span class="line">    xcb_parts[3].iov_len = -xcb_parts[2].iov_len &amp; 3;</span><br><span class="line"></span><br><span class="line">    fds[fd_index++] = pixmap_fd;</span><br><span class="line">    xcb_ret.sequence = xcb_send_request_with_fds(c, 0, xcb_parts + 2, &amp;xcb_req, 1, fds);</span><br><span class="line">    return xcb_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而X Server收到这个request后的处理函数如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int</span><br><span class="line">dri3_pixmap_from_fds(PixmapPtr *ppixmap, ScreenPtr screen,</span><br><span class="line">                     CARD8 num_fds, const int *fds,</span><br><span class="line">                     CARD16 width, CARD16 height,</span><br><span class="line">                     const CARD32 *strides, const CARD32 *offsets,</span><br><span class="line">                     CARD8 depth, CARD8 bpp, CARD64 modifier)</span><br><span class="line">&#123;</span><br><span class="line">    dri3_screen_priv_ptr        ds = dri3_screen_priv(screen);</span><br><span class="line">    const dri3_screen_info_rec *info = ds-&gt;info;</span><br><span class="line">    PixmapPtr                   pixmap;</span><br><span class="line"></span><br><span class="line">    if (!info)</span><br><span class="line">        return BadImplementation;</span><br><span class="line"></span><br><span class="line">    if (info-&gt;version &gt;= 2 &amp;&amp; info-&gt;pixmap_from_fds != NULL) &#123;</span><br><span class="line">        pixmap = (*info-&gt;pixmap_from_fds) (screen, num_fds, fds, width, height,</span><br><span class="line">                                           strides, offsets, depth, bpp, modifier);</span><br><span class="line">    &#125; else if (info-&gt;pixmap_from_fd != NULL &amp;&amp; num_fds == 1) &#123;</span><br><span class="line">        pixmap = (*info-&gt;pixmap_from_fd) (screen, fds[0], width, height,</span><br><span class="line">                                          strides[0], depth, bpp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return BadImplementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!pixmap)</span><br><span class="line">        return BadAlloc;</span><br><span class="line"></span><br><span class="line">    *ppixmap = pixmap;</span><br><span class="line">    return Success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终是调用了<code>pixmap_from_fds</code>或<code>pixmap_from_fd</code>, 接下来的工作由display GPU的kmd完成，最后当display GPU <code>gbm_bo_import</code>调用了<code>drmPrimeFDToHandle</code>函数后，X Server进程进入内核态，接下来内核DRM子系统的ioctl会调用<code>drm_prime_fd_to_handle_ioctl</code>, 它会调用display GPU的<code>prime_fd_to_handle</code> callback. 整个过程其实是将显存(buffer, 确切说是back buffer)抽象成dma-buf(dma-buf实际上是一个文件，所以它有fd, 可供在进程间传递)来实现用户应用进程与X Server进程间的Buffer共享。</p>
<img src="/gfx/X/winsys/winsys-Page-9.drawio.png" class="" title="dma-buf">
<p>下面是内核函数<code>dma_buf_get</code>的实现，从这个小函数的实现我们可以清楚地看到fd -&gt; file -&gt; dma_buf的转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dma_buf_get - returns the struct dma_buf related to an fd</span></span><br><span class="line"><span class="comment"> * @fd:	[in]	fd associated with the struct dma_buf to be returned</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success, returns the struct dma_buf associated with an fd; uses</span></span><br><span class="line"><span class="comment"> * file&#x27;s refcounting done by fget to increase refcount. returns ERR_PTR</span></span><br><span class="line"><span class="comment"> * otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dma_buf *<span class="title function_">dma_buf_get</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	file = fget(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!file)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EBADF);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_dma_buf_file(file)) &#123;</span><br><span class="line">		fput(file);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> file-&gt;private_data;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(dma_buf_get);</span><br></pre></td></tr></table></figure>
<h3 id="基于dri-winsys的gallium-driver的winsys实现"><a class="markdownIt-Anchor" href="#基于dri-winsys的gallium-driver的winsys实现"></a> 基于dri winsys的gallium driver的winsys实现</h3>
<p>winsys是一个桥梁，它主要要实现的就是将color buffer传输到窗口系统的framebuffer.那么基于dri的winsys是怎么实现这个桥梁的? 它主要依赖下面两个对象:</p>
<ul>
<li>DRIimage
<ul>
<li><code>__DRIimageRec</code></li>
<li><code>__DRIimageExtensionRec</code></li>
</ul>
</li>
</ul>
<p>DRIimage通过调用<code>pipe_screen.resource_create</code>函数创建，创建后还需要queryImage一些信息，这些信息为X11所需要。</p>
<ul>
<li>PIPE_RESOURCE_PARAM_NPLANES</li>
<li>PIPE_RESOURCE_PARAM_STRIDE</li>
<li>PIPE_RESOURCE_PARAM_OFFSET</li>
<li>PIPE_RESOURCE_PARAM_MODIFIER</li>
<li>PIPE_RESOURCE_PARAM_HANDLE_TYPE_FD</li>
</ul>
<p><code>PIPE_RESOURCE_PARAM_HANDLE_TYPE_FD</code>通过向kernel发送下面请求，由一个gem handle返回一个file descriptor. 有了这个FD, 不同的进程间就可以共享内存。比方，当xserver获取到这个FD后，它可以通过<code>DRM_IOCTL_PRIME_FD_TO_HANDLE</code>又重新获取到gem bo的handle.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int</span><br><span class="line">panfrost_bo_export(struct panfrost_bo *bo)</span><br><span class="line">&#123;</span><br><span class="line">        struct drm_prime_handle args = &#123;</span><br><span class="line">                .handle = bo-&gt;gem_handle,</span><br><span class="line">                .flags = DRM_CLOEXEC,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        int ret = drmIoctl(bo-&gt;dev-&gt;fd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &amp;args);</span><br><span class="line">        if (ret == -1)</span><br><span class="line">                return -1;</span><br><span class="line"></span><br><span class="line">        bo-&gt;flags |= PAN_BO_SHARED;</span><br><span class="line">        return args.fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>X11 present extension</li>
</ul>
<h2 id="非dri"><a class="markdownIt-Anchor" href="#非dri"></a> 非dri</h2>
<ul>
<li>sw_winsys</li>
</ul>
<p>非dri的winsys的实现代码在<code>src/gallium/winsys/sw/xlib</code>目录</p>
<p>不同的winsys实际上是不同的接口(函数)，下面以sw_winsys为例说明一下mesa里的winsys的接口与实现。</p>
<table>
<thead>
<tr>
    <th>接口</th>
    <th>实现</th>
    <th>功能</th>
</tr>
</thead>
<tbody>
<tr>
    <td>void<br>(*destroy)(struct sw_winsys *ws);</td>
    <td>xlib_displaytarget_destroy</td>
    <td>销毁这个winsys</td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
<tr>
    <td></td>
    <td></td>
    <td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
  <entry>
    <title>X11中的Display, Screen, Depth和Visual</title>
    <url>/gfx/X/x-display/</url>
    <content><![CDATA[<h1 id="x窗口系统"><a class="markdownIt-Anchor" href="#x窗口系统"></a> X窗口系统</h1>
<p><a href="https://en.wikipedia.org/wiki/X_Window_System">X窗口系统</a>诞生于1984年MIT的研究，后来成为Unix, 类UNIX等操作系统所一致适用的标准化软件工具包及显示架构的运作协议。目前使用最普遍最受欢迎的一个实现是<a href="https://www.x.org/wiki/">X.Org</a>，它所用的协议版本是<strong>X11</strong>, 所以Xorg也经常被叫做X11。</p>
<span id="more"></span>
<h1 id="它们是什么"><a class="markdownIt-Anchor" href="#它们是什么"></a> 它们是什么</h1>
<h2 id="display"><a class="markdownIt-Anchor" href="#display"></a> Display</h2>
<p>Display datatype maintaining display specific data. The contents of this structure are implementation dependent. A Display should be treated as oqaque by application code.</p>
<h2 id="screen"><a class="markdownIt-Anchor" href="#screen"></a> Screen</h2>
<pre><code>Information about the screen. The contents of this structure are implementation dependent. A Screen should be treated as opaque by application code.
</code></pre>
<h2 id="depth"><a class="markdownIt-Anchor" href="#depth"></a> Depth</h2>
<pre><code>Depth structure; contains information for each possible depth.
</code></pre>
<h2 id="visual"><a class="markdownIt-Anchor" href="#visual"></a> Visual</h2>
<pre><code>Visual structure; contains information about colormapping possible.
</code></pre>
<p>以上4个结构体都被定义在<a href="https://gitlab.freedesktop.org/xorg/lib/libx11/-/blob/master/include/X11/Xlib.h">Xlib.h</a>,它们四者之间的关系是前者包含多个后者，依次类推。这里注意区分两组概念:</p>
<table>
<caption><em>Comparison between Display and DISPLAY</em></caption>
<tr><th><th>Display<th>DISPLAY
<tr><th>Category<td>struct<td>env var
<tr><th>Usage<td>Display *dpy<br>as most Xlib API's first argument<td>e.g. export DISPLAY=:0
</table>
<h1 id="它们之间的层级关系"><a class="markdownIt-Anchor" href="#它们之间的层级关系"></a> 它们之间的层级关系</h1>
<pre><code class="highlight mermaid">graph TD
    D[Display]
    D --&gt; s0(Screen0)
    D --&gt; s1(Screen1)
    D --&gt; sN(ScreenN)
    subgraph Screen0
    s0 --&gt; d0(Depth0)
    s0 --&gt; d1(Depth1)
    s0 --&gt; d2(Depth2)
    s0 --&gt; d3(Depth3)
    s0 --&gt; dN(DepthN)
    end
    subgraph Depth0
    d0 --&gt; v0(Visual0)
    d0 --&gt; v1(Visual1)
    d0 --&gt; v2(Visual2)
    d0 --&gt; v3(Visual3)
    d0 --&gt; v4(Visual4)
    d0 --&gt; v5(Visual5)
    d0 --&gt; vN(VisualN)
    end</code></pre>
<h1 id="xdpyinfo"><a class="markdownIt-Anchor" href="#xdpyinfo"></a> <code>xdpyinfo</code></h1>
<p><code>xdpyinfo</code>来自X11的工具包<code>x11-utils</code>, 它可以打印当前<code>DISPLAY</code>的Display, Screen, Depth, Visual信息，当然和其它的X的工具一样，使用前要确保环境变量<code>DISPLAY</code>已经为有效值。下面是在Xorg作为X Server时查看到的系统X11 Window的相关信息。(只截取前面部分)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name of display:    :18.0</span><br><span class="line">version number:    11.0</span><br><span class="line">vendor string:    The X.Org Foundation</span><br><span class="line">vendor release number:    12008000</span><br><span class="line">X.Org version: 1.20.8</span><br><span class="line">maximum request size:  16777212 bytes</span><br><span class="line">motion buffer size:  256</span><br><span class="line">bitmap unit, bit order, padding:    32, LSBFirst, 32</span><br><span class="line">image byte order:    LSBFirst</span><br><span class="line">number of supported pixmap formats:    7</span><br><span class="line">supported pixmap formats:</span><br><span class="line">    depth 1, bits_per_pixel 1, scanline_pad 32</span><br><span class="line">    depth 4, bits_per_pixel 8, scanline_pad 32</span><br><span class="line">    depth 8, bits_per_pixel 8, scanline_pad 32</span><br><span class="line">    depth 15, bits_per_pixel 16, scanline_pad 32</span><br><span class="line">    depth 16, bits_per_pixel 16, scanline_pad 32</span><br><span class="line">    depth 24, bits_per_pixel 32, scanline_pad 32</span><br><span class="line">    depth 32, bits_per_pixel 32, scanline_pad 32</span><br><span class="line">keycode range:    minimum 8, maximum 255</span><br><span class="line">focus:  window 0x300000f, revert to PointerRoot</span><br><span class="line">number of extensions:    25</span><br><span class="line">    BIG-REQUESTS</span><br><span class="line">    DAMAGE</span><br><span class="line">    DOUBLE-BUFFER</span><br><span class="line">    DRI2</span><br><span class="line">    GLX</span><br><span class="line">    Generic Event Extension</span><br><span class="line">    MIT-SCREEN-SAVER</span><br><span class="line">    MIT-SHM</span><br><span class="line">    Present</span><br><span class="line">    RANDR</span><br><span class="line">    RECORD</span><br><span class="line">    RENDER</span><br><span class="line">    SECURITY</span><br><span class="line">    SHAPE</span><br><span class="line">    SYNC</span><br><span class="line">    X-Resource</span><br><span class="line">    XC-MISC</span><br><span class="line">    XFIXES</span><br><span class="line">    XFree86-DGA</span><br><span class="line">    XFree86-VidModeExtension</span><br><span class="line">    XINERAMA</span><br><span class="line">    XInputExtension</span><br><span class="line">    XKEYBOARD</span><br><span class="line">    XTEST</span><br><span class="line">    XVideo</span><br><span class="line">default screen number:    0</span><br><span class="line">number of screens:    1</span><br><span class="line"></span><br><span class="line">screen #0:</span><br><span class="line">  dimensions:    1920x1080 pixels (508x286 millimeters)</span><br><span class="line">  resolution:    96x96 dots per inch</span><br><span class="line">  depths (7):    24, 1, 4, 8, 15, 16, 32</span><br><span class="line">  root window id:    0x34d</span><br><span class="line">  depth of root window:    24 planes</span><br><span class="line">  number of colormaps:    minimum 1, maximum 1</span><br><span class="line">  default colormap:    0x20</span><br><span class="line">  default number of colormap cells:    256</span><br><span class="line">  preallocated pixels:    black 0, white 16777215</span><br><span class="line">  options:    backing-store NO, save-unders NO</span><br><span class="line">  largest cursor:    1920x1080</span><br><span class="line">  current input event mask:    0xfa800f</span><br><span class="line">    KeyPressMask             KeyReleaseMask           ButtonPressMask          </span><br><span class="line">    ButtonReleaseMask        ExposureMask             StructureNotifyMask      </span><br><span class="line">    SubstructureNotifyMask   SubstructureRedirectMask FocusChangeMask          </span><br><span class="line">    PropertyChangeMask       ColormapChangeMask       </span><br><span class="line">  number of visuals:    240</span><br><span class="line">  default visual id:  0x21</span><br><span class="line">  visual:</span><br><span class="line">    visual id:    0x21</span><br><span class="line">    class:    TrueColor</span><br><span class="line">    depth:    24 planes</span><br><span class="line">    available colormap entries:    256 per subfield</span><br><span class="line">    red, green, blue masks:    0xff0000, 0xff00, 0xff</span><br><span class="line">    significant bits in color specification:    8 bits</span><br><span class="line">  visual:</span><br><span class="line">    visual id:    0x22</span><br><span class="line">    class:    DirectColor</span><br><span class="line">    depth:    24 planes</span><br><span class="line">    available colormap entries:    256 per subfield</span><br><span class="line">    red, green, blue masks:    0xff0000, 0xff00, 0xff</span><br><span class="line">    significant bits in color specification:    8 bits</span><br><span class="line">  visual:</span><br><span class="line">    visual id:    0x25e</span><br><span class="line">    class:    TrueColor</span><br><span class="line">    depth:    24 planes</span><br><span class="line">    available colormap entries:    256 per subfield</span><br><span class="line">    red, green, blue masks:    0xff0000, 0xff00, 0xff</span><br><span class="line">    significant bits in color specification:    8 bits</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>graphics</category>
      </categories>
      <tags>
        <tag>X11</tag>
      </tags>
  </entry>
</search>
